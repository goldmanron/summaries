#LyX 2.3 created this file. For more info see http://www.lyx.org/
\lyxformat 544
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass article
\begin_preamble
\usepackage{centernot}
\usepackage{enumitem}
\usepackage{chngcntr}
\usepackage{tikz}
\usepackage{tikz-qtree}
\usepackage{wrapfig}
\usepackage{pgfplots}
\usepackage{hyperref}
\usepackage{xcolor}
\usepackage[cm]{fullpage}
\usepackage{polynom}
\usepackage{booktabs}

\setlength{\tabcolsep}{1pt}
\renewcommand{\arraystretch}{1.25} % Default value: 1

\usetikzlibrary{math}
\usetikzlibrary{shadows,trees}
\counterwithin*{section}{part}
\setlist{nosep, noitemsep}
% \setlist[enumerate,levels]{format}
\setlist[enumerate,1]{label = \arabic*., ref = \arabic*}
\setlist[enumerate,2]{label = \emph{\alph*}), ref = \theenumi.\emph{\alph*}}
\setlist[enumerate,3]{label = .\roman*, ref = \theenumii.\roman*}


% Convert the Lyx colors into more pleasent colors:
\definecolor{blue}{RGB}{14,107,217}
\definecolor{green}{RGB}{0,158,40}
\definecolor{red}{RGB}{235,16,16}
\definecolor{brown}{RGB}{164,66,0}
\definecolor{orange}{RGB}{231,135,26}
\definecolor{purple}{RGB}{94,53,177}


% Program Listing colors
\definecolor{keywordcolor}{RGB}{255,117,0}
\definecolor{commentcolor}{RGB}{128,128,128}
\definecolor{stringcolor}{RGB}{0,168,0}


% Trees formating
\tikzset{edge from parent fork down, level distance=2cm, every node/.style= {rectangle,rounded corners, minimum height=8mm, very thick, align=center}}


\hypersetup{
    colorlinks=true,
    linkcolor=blue,
    urlcolor=blue,
    }


\setmathfont{NewCMMath-Regular.otf}
\let\RonMikhelmanLol\implies
\renewcommand{\implies}{\negthickspace\RonMikhelmanLol\negthickspace}
\let\RonMikhelmanLoll\iff
\renewcommand{\iff}{\negthickspace\RonMikhelmanLoll\negthickspace}
\let\RonMikhelmanLolll\impliedby
\renewcommand{\impliedby}{\negthickspace\RonMikhelmanLolll\negthickspace}
\end_preamble
\use_default_options true
\begin_modules
theorems-ams-chap-bytype
theorems-ams-extended-chap-bytype
\end_modules
\maintain_unincluded_children false
\language hebrew
\language_package default
\inputencoding auto
\fontencoding global
\font_roman "default" "David"
\font_sans "default" "David"
\font_typewriter "default" "David"
\font_math "auto" "default"
\font_default_family default
\use_non_tex_fonts true
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype true
\use_dash_ligatures true
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize 12
\spacing onehalf
\use_hyperref false
\papersize letterpaper
\use_geometry false
\use_package amsmath 2
\use_package amssymb 2
\use_package cancel 2
\use_package esint 2
\use_package mathdots 2
\use_package mathtools 2
\use_package mhchem 2
\use_package stackrel 2
\use_package stmaryrd 2
\use_package undertilde 0
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\use_minted 0
\branch LinearAlgebra2Recap
\selected 0
\filename_suffix 0
\color #faf0e6
\end_branch
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation 0bp
\is_math_indent 0
\math_numbering_side default
\quotes_style english
\dynamic_quotes 0
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand include
filename "E:/University/macros.lyx"

\end_inset


\end_layout

\begin_layout Standard

\lang american
\begin_inset FormulaMacro
\newcommand{\len}{\text{len}}
{\text{len}}
\end_inset


\end_layout

\begin_layout Standard

\series bold
\lang british
Integrated development environment (IDE)
\series default
: a software that provides facilities to computer programmers.
\end_layout

\begin_layout Standard

\series bold
\lang british
String (
\lang american
str
\lang british
)
\series default
: type to represent text.
\end_layout

\begin_layout Standard

\series bold
\lang british
Integer (int)
\series default
: type to represent an element in 
\begin_inset Formula $\bbz$
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
\lang british
Floating point (float)
\series default
: type to represent an element in 
\begin_inset Formula $\bbr$
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
\lang american
Integer
\series default
 
\series bold
division
\series default
: let 
\begin_inset Formula $x,y\in\bbr$
\end_inset

 then 
\begin_inset Formula $x//y=\floor{x/y}$
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
\lang american
Modulo
\series default
: let 
\begin_inset Formula $x,y\in\bbr$
\end_inset

 then 
\begin_inset Formula $x\%y=x\mod y$
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
\lang american
Exponent
\series default
: let 
\begin_inset Formula $x,y\in\bbr$
\end_inset

 then 
\begin_inset Formula $x**y=x^{y}$
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
\lang american
Assignment
\series default
: giving a variable a value.
\end_layout

\begin_layout Standard

\series bold
\color blue
\lang american
Boolean (bool)
\series default
\color inherit
: type to represent True/False.
\end_layout

\begin_layout Standard

\series bold
\color blue
\lang american
Length of string
\series default
\color inherit
: let 
\begin_inset Formula $S$
\end_inset

 be a string then 
\begin_inset Formula $\text{len}\left(S\right)$
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
\color blue
\lang american
Lexicogrphical
\series default
 
\series bold
order
\series default
\color inherit
: let 
\begin_inset Formula $S,T$
\end_inset

 be str then 
\begin_inset Formula $\left(S<T\right)\iff\exists i\ge0.\left(\forall j<i.S_{j}=T_{j}\right)\land\left(\left(S_{i}<T_{i}\right)\lor\left(\text{len}\left(S\right)<\text{len}\left(T\right)\right)\right)$
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
\color blue
\lang american
Conditional
\series default
 
\series bold
statement
\series default
\color inherit
: bool statement used to direct the flow of the program.
\end_layout

\begin_layout Standard

\series bold
\color blue
\lang american
Iteration
\series default
\color inherit
: repeating the flow of the program until a requirement is met.
\end_layout

\begin_layout Standard

\series bold
\color blue
\lang american
Break
\series default
\color inherit
: aborting iteration.
\end_layout

\begin_layout Standard

\series bold
\color blue
\lang american
Continue
\series default
\color inherit
: skip iteration.
\end_layout

\begin_layout Standard

\series bold
\color red
\lang american
List
\series default
\color inherit
: oreded collection of elements.
\end_layout

\begin_layout Standard

\series bold
\color red
\lang american
List
\series default
 
\series bold
comprehension
\series default
\color inherit
: let 
\begin_inset Formula $S$
\end_inset

 be a collection 
\begin_inset Formula $f\left(x\right)$
\end_inset

 a function and 
\begin_inset Formula $p\left(x\right)$
\end_inset

 a predicate then 
\begin_inset Formula $\left[f\left(e\right)\:\text{for}\:e\:\text{in}\:S\:\text{if}\:p\left(e\right)\right]$
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
\color red
\lang american
Slicing
\series default
\color inherit
: sub-list based on indices.
\end_layout

\begin_layout Standard

\series bold
\color red
\lang american
Function (func)
\series default
\color inherit
: procces that returns a value given an input.
\end_layout

\begin_layout Standard

\series bold
\color red
\lang american
Palindrom
\series default
\color inherit
: string 
\begin_inset Formula $S$
\end_inset

 such that 
\begin_inset Formula $\forall i\in\left[\len\left(S\right)\right].S_{i}=S_{\len\left(S\right)-i}$
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
\color red
\lang american
theorem
\series default
\color inherit
: every object is stored at a specific memory location.
\end_layout

\begin_layout Standard

\series bold
\color red
\lang american
Equality
\series default
\color inherit
: objects 
\begin_inset Formula $x,y$
\end_inset

 such that (value of 
\begin_inset Formula $x$
\end_inset

)
\begin_inset Formula $=$
\end_inset

(value of 
\begin_inset Formula $y$
\end_inset

).
\end_layout

\begin_layout Standard

\series bold
\color red
\lang american
symbol
\series default
\color inherit
: if 
\begin_inset Formula $x,y$
\end_inset

 are equal then 
\begin_inset Formula $x==y$
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
\color red
\lang american
symbol
\series default
\color inherit
: if 
\begin_inset Formula $x,y$
\end_inset

 are not equal then 
\begin_inset Formula $x!=y$
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
\color red
\lang american
Identity
\series default
\color inherit
: objects 
\begin_inset Formula $x,y$
\end_inset

 such that (memory address of 
\begin_inset Formula $x$
\end_inset

)
\begin_inset Formula $=$
\end_inset

(memory address of 
\begin_inset Formula $y$
\end_inset

).
\end_layout

\begin_layout Standard

\series bold
\color red
\lang american
Mutate
\series default
\color inherit
: let 
\begin_inset Formula $x$
\end_inset

 be an object than to change an attribute of 
\begin_inset Formula $x$
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
\color red
\lang american
claim
\series default
\color inherit
: let 
\begin_inset Formula $x$
\end_inset

 be an object and 
\begin_inset Formula $y$
\end_inset

 a mutation of 
\begin_inset Formula $x$
\end_inset

 then 
\begin_inset Formula $x$
\end_inset

 is identical to 
\begin_inset Formula $y$
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
\color green
\lang american
Pass
\series default
 
\series bold
by
\series default
 
\series bold
value
\series default
\color inherit
: when an input to a function is passed as a value.
\end_layout

\begin_layout Standard

\series bold
\color green
\lang american
Pass
\series default
 
\series bold
by
\series default
 
\series bold
refrence
\series default
\color inherit
: when an input to a function is passed as an address.
\end_layout

\begin_layout Standard

\series bold
\color green
\lang american
Global
\series default
 
\series bold
variable
\series default
\color inherit
: a variable that is possible to access from anywhere.
\end_layout

\begin_layout Standard

\series bold
\color green
\lang american
Tuple
\series default
\color inherit
: an immutable list data structure.
\end_layout

\begin_layout Standard

\series bold
\color green
\lang american
Set
\series default
\color inherit
: an unordered mutable data structure not contains duplicates.
\end_layout

\begin_layout Standard

\series bold
\color green
\lang american
Dictionary/Map (dict)
\series default
\color inherit
: an unordered mutable data structure that maps keys to values.
\end_layout

\begin_layout Standard

\series bold
\color green
\lang american
Syntax
\series default
\color inherit
: the form of a valid program.
\end_layout

\begin_layout Standard

\series bold
\color green
\lang american
Semantics
\series default
\color inherit
: the meaning of the program.
\end_layout

\begin_layout Standard

\series bold
\color magenta
\lang american
True random number generators (TRNG)
\series default
\color inherit
: random function.
\end_layout

\begin_layout Standard

\series bold
\color magenta
\lang american
Pseudo-random Number Generators (PRNG)
\series default
\color inherit
: function that generates a long sequence that appears random.
\end_layout

\begin_layout Standard

\series bold
\color magenta
\lang american
Seed
\series default
\color inherit
: the starting point of a PRNG.
\end_layout

\begin_layout Standard

\series bold
\color magenta
\lang american
Linear congruential generator
\series default
\color inherit
: let 
\begin_inset Formula $a,c,m,x_{0}\in\bbn$
\end_inset

 then 
\begin_inset Formula $x_{i+1}=\left(a\cdot x_{i}+c\right)\mod m$
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
\color magenta
\lang american
Period
\series default
\color inherit
: let 
\begin_inset Formula $a_{n}$
\end_inset

 be a PRNG then 
\begin_inset Formula $\min\left(i\in\bbn_{+}\mid a_{i}=a_{0}\right)$
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
\color magenta
\lang american
theorem
\series default
\color inherit
: every PRNG has a finite period.
\end_layout

\begin_layout Standard

\series bold
\color magenta
\lang american
Mersenne prime
\series default
\color inherit
: 
\begin_inset Formula $p\in\bbp$
\end_inset

 such that 
\begin_inset Formula $\exists n\in\bbn.p=2^{n}-1$
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
\color magenta
\lang american
1D random walk
\series default
\color inherit
: let 
\begin_inset Formula $a\in\left\{ \pm1\right\} ^{\bbn}$
\end_inset

 then 
\begin_inset Formula $S\in\bbz^{\bbn}$
\end_inset

 such that 
\begin_inset Formula $S_{n}=\sum_{j=1}^{n}a_{j}$
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
\color magenta
\lang american
claim
\series default
\color inherit
: let 
\begin_inset Formula $S_{n}$
\end_inset

 be a 1D Random walk then 
\begin_inset Formula $\left|S_{n}\right|$
\end_inset

 is the distance from 
\begin_inset Formula $0$
\end_inset

 after 
\begin_inset Formula $n$
\end_inset

 steps.
\end_layout

\begin_layout Standard

\series bold
\color magenta
\lang american
theorem
\series default
\color inherit
: let 
\begin_inset Formula $S_{n}$
\end_inset

 be a 1D Random walk then 
\begin_inset Formula $\frac{\bbe\left[\left|S_{n}\right|\right]}{\sqrt{n}}\to\sqrt{\frac{2}{\pi}}$
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
\color magenta
\lang american
Compilation error
\series default
\color inherit
: a syntax error that is discovered before execution.
\end_layout

\begin_layout Standard

\series bold
\color magenta
\lang american
Runtime
\series default
 
\series bold
error
\series default
\color inherit
: error that is discovered durings execution.
\end_layout

\begin_layout Standard

\series bold
\color magenta
\lang american
Transistor
\series default
\color inherit
: electricity switch in the CPU.
\end_layout

\begin_layout Standard

\series bold
\color purple
\lang american
Base
\series default
 
\series bold
representation
\series default
\color inherit
: let 
\begin_inset Formula $b,n\in\bbn$
\end_inset

 and 
\begin_inset Formula $a\in\left[b\right]^{\left[k\right]}$
\end_inset

 if 
\begin_inset Formula $n=\sum_{i=0}^{k-1}a_{i}b^{i}$
\end_inset

 then 
\begin_inset Formula $\left\langle a_{k-1}\ldots a_{0}\right\rangle $
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
\color purple
\lang american
claim
\series default
\color inherit
: let 
\begin_inset Formula $b,n\in\bbn$
\end_inset

 then 
\begin_inset Formula $b^{k-1}\le N<b^{k}$
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
\color purple
\lang american
concllusion
\series default
\color inherit
: let 
\begin_inset Formula $b,n\in\bbn$
\end_inset

 then the number of digits needed to represent 
\begin_inset Formula $n$
\end_inset

 in base 
\begin_inset Formula $b$
\end_inset

 is 
\begin_inset Formula $\floor{\log_{b}\left(n\right)}+1$
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
\color purple
\lang american
symbol
\series default
\color inherit
: let 
\begin_inset Formula $b\in\bbn$
\end_inset

 and 
\begin_inset Formula $n\in\bbz$
\end_inset

 then 
\begin_inset Formula $n$
\end_inset

 in base 
\begin_inset Formula $b$
\end_inset

 is 
\begin_inset Formula $\left(n\right)_{b}$
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
\color purple
\lang american
name
\series default
\color inherit
: unary - base 1, binary - base 2, ternary - base 3, octaldecimal - base
 8, decimal - base 10, hexadecimal - base 16.
\end_layout

\begin_layout Standard

\series bold
\color purple
\lang american
claim
\series default
\color inherit
: addition and multiplication algorithms work for every base.
\end_layout

\begin_layout Standard

\series bold
\color purple
\lang american
One's
\series default
 
\series bold
complement
\series default
\color inherit
: let 
\begin_inset Formula $k\in\bbn$
\end_inset

 and 
\begin_inset Formula $a\in\left[2^{k-1}\right]$
\end_inset

 then 
\begin_inset Formula $\left(-a\right)_{2}=\left(2^{k-1}\right)_{2}+\left(a\right)_{2}$
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
\color purple
\lang american
Two's
\series default
 
\series bold
complement
\series default
\color inherit
: let 
\begin_inset Formula $k\in\bbn$
\end_inset

 and 
\begin_inset Formula $a\in\left[2^{k-1}\right]$
\end_inset

 then 
\begin_inset Formula $\left(-a\right)_{2}=\left(2^{k}-a\right)_{2}$
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
\color purple
\lang american
Fixed
\series default
 
\series bold
point
\series default
\color inherit
: let 
\begin_inset Formula $i\in\bbn$
\end_inset

 and 
\begin_inset Formula $x\in\bbr$
\end_inset

 then 
\begin_inset Formula $\frac{\floor{10^{i}x}}{10^{i}}$
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
\color purple
\lang american
Floating point
\series default
\color inherit
: let 
\begin_inset Formula $s\in\left\{ 0,1\right\} $
\end_inset

 and 
\begin_inset Formula $x\in\left\{ 0,1\right\} ^{11}$
\end_inset

 and 
\begin_inset Formula $f\in\left\{ 0,1\right\} ^{52}$
\end_inset

 then 
\begin_inset Formula $\left(-2\left(s\right)_{10}+1\right)\cdot2^{\left(x\right)_{10}-1023}\cdot\left(1+\sum_{i=1}^{52}\frac{\left(f_{i}\right)_{10}}{2^{i}}\right)$
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
\color purple
\lang american
note
\series default
\color inherit
: 
\begin_inset Formula $0$
\end_inset

 is represented by 
\begin_inset Formula $x,f=0$
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
\color purple
\lang american
note
\series default
\color inherit
: 
\begin_inset Formula $\pm\infty$
\end_inset

 is represented by 
\begin_inset Formula $x=1$
\end_inset

 and 
\begin_inset Formula $f=0$
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
\color purple
\lang american
theorem
\series default
\color inherit
: forall 
\begin_inset Formula $y\ne0$
\end_inset

 exists one uniqe representation as floating point.
\end_layout

\begin_layout Standard

\series bold
\color purple
\lang american
claim
\series default
\color inherit
: 
\begin_inset Formula $0.3$
\end_inset

 cannot be represented in floating point.
\end_layout

\begin_layout Standard

\series bold
\color purple
\lang american
American Standard Code for Information Interchange (ASCII)
\series default
\color inherit
: encoding of simple characters to numbers.
\end_layout

\begin_layout Standard

\series bold
\color purple
\lang american
Unicode
\series default
\color inherit
: encoding of complex characters to numbers.
\end_layout

\begin_layout Standard

\series bold
\color brown
\lang american
Sequential search
\series default
\color inherit
: let 
\begin_inset Formula $\ell$
\end_inset

 be a list and 
\begin_inset Formula $k$
\end_inset

 a key then
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
SetKwProg{Fn}{Function}{ is}{}
\end_layout

\begin_layout Plain Layout


\backslash
begin{algorithm}
\end_layout

\begin_layout Plain Layout


\backslash
Fn{sequentialSearch $
\backslash
left(
\backslash
ell, k
\backslash
right)$}{
\end_layout

\begin_layout Plain Layout

	
\backslash
For{$0
\backslash
le i<$ len $
\backslash
left(
\backslash
ell
\backslash
right)$}{
\end_layout

\begin_layout Plain Layout

		
\backslash
uIf{$
\backslash
ell
\backslash
left[i
\backslash
right]==k$}{
\end_layout

\begin_layout Plain Layout

			
\backslash
Return{i}
\backslash
;
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout


\backslash
end{algorithm}
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\series bold
\color brown
\lang american
Binary search
\series default
\color inherit
: let 
\begin_inset Formula $\ell$
\end_inset

 be a sorted list and 
\begin_inset Formula $k$
\end_inset

 a key then
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{algorithm}
\end_layout

\begin_layout Plain Layout


\backslash
Fn{binarySearch $
\backslash
left(
\backslash
ell, k
\backslash
right)$}{
\end_layout

\begin_layout Plain Layout

	$
\backslash
left(s=0
\backslash
right)
\backslash
land
\backslash
left(e=
\backslash
right.$ len $
\backslash
left.
\backslash
left(
\backslash
ell
\backslash
right)-1
\backslash
right)$
\backslash
;
\end_layout

\begin_layout Plain Layout

	
\backslash
While{$s
\backslash
le e$}{
\end_layout

\begin_layout Plain Layout

		$m=
\backslash
lfloor{
\backslash
frac{s+e}{2}}
\backslash
rfloor$
\backslash
;
\end_layout

\begin_layout Plain Layout

		
\backslash
uIf{$
\backslash
ell
\backslash
left[m
\backslash
right]==k$}{
\end_layout

\begin_layout Plain Layout

			
\backslash
Return{m}
\backslash
;
\end_layout

\begin_layout Plain Layout

		}
\backslash
uIf{$
\backslash
ell
\backslash
left[m
\backslash
right]<k$}{
\end_layout

\begin_layout Plain Layout

			$s=m+1$
\backslash
;
\end_layout

\begin_layout Plain Layout

		}
\backslash
uIf{$
\backslash
ell
\backslash
left[m
\backslash
right]>k$}{
\end_layout

\begin_layout Plain Layout

			$e=m-1$
\backslash
;
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout


\backslash
end{algorithm}
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\lang american
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Standard

\series bold
\color brown
\lang english
claim
\series default
\color inherit
: after 
\begin_inset Formula $i\in\bbn$
\end_inset

 iterations of binary search 
\begin_inset Formula $e-s+1\le\floor{\frac{\len\left(\ell\right)}{2^{i}}}$
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
\color brown
\lang english
Selection sort
\series default
\color inherit
: 
\lang american
let 
\begin_inset Formula $\ell$
\end_inset

 be a list then
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{algorithm}
\end_layout

\begin_layout Plain Layout


\backslash
Fn{selectionSort $
\backslash
left(
\backslash
ell
\backslash
right)$}{
\end_layout

\begin_layout Plain Layout

	
\backslash
For{$0
\backslash
le i<$ len $
\backslash
left(
\backslash
ell
\backslash
right)$}{
\end_layout

\begin_layout Plain Layout

		$m=
\backslash
min
\backslash
left(j
\backslash
in
\backslash
left[i
\backslash
ldots
\backslash
right.
\backslash
right.$ len $
\backslash
left.
\backslash
left.
\backslash
left(
\backslash
ell
\backslash
right)-1
\backslash
right]
\backslash
mid
\backslash
ell
\backslash
left[j
\backslash
right]
\backslash
right)$
\backslash
;
\end_layout

\begin_layout Plain Layout

		swap $
\backslash
left(
\backslash
ell
\backslash
left[i 
\backslash
right], 
\backslash
ell
\backslash
left[m 
\backslash
right]
\backslash
right)$
\backslash
;
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout


\backslash
end{algorithm}
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\series bold
\color brown
\lang american
Concatenate merge
\series default
\color inherit
: let 
\begin_inset Formula $\ell_{1},\ell_{2}$
\end_inset

 be lists then
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{algorithm}
\end_layout

\begin_layout Plain Layout


\backslash
Fn{concatenateMerge $
\backslash
left(
\backslash
ell_{1},
\backslash
ell_{2}
\backslash
right)$}{
\end_layout

\begin_layout Plain Layout

	
\backslash
For{$0
\backslash
le i<$ len $
\backslash
left(
\backslash
ell_{1}
\backslash
right)$}{
\end_layout

\begin_layout Plain Layout

		$
\backslash
ell_{3}
\backslash
left[i
\backslash
right]=
\backslash
ell_{1}
\backslash
left[i
\backslash
right]$
\backslash
;
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

	
\backslash
For{$0
\backslash
le i<$ len $
\backslash
left(
\backslash
ell_{2}
\backslash
right)$}{
\end_layout

\begin_layout Plain Layout

		$
\backslash
ell_{3}
\backslash
left[i+
\backslash
right.$ len $
\backslash
left.
\backslash
left(
\backslash
ell_{1}
\backslash
right)
\backslash
right]=
\backslash
ell_{1}
\backslash
left[i
\backslash
right]$
\backslash
;
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

	selectionSort $
\backslash
left(
\backslash
ell_{3}
\backslash
right)$
\backslash
;
\end_layout

\begin_layout Plain Layout

	
\backslash
Return{$
\backslash
ell_3$}
\backslash
;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout


\backslash
end{algorithm}
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\series bold
\color brown
\lang american
Merge algorithm
\series default
\color inherit
: let 
\begin_inset Formula $\ell_{1},\ell_{2}$
\end_inset

 be sorted lists then
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{algorithm}
\end_layout

\begin_layout Plain Layout


\backslash
Fn{mergeSorted $
\backslash
left(
\backslash
ell_{1},
\backslash
ell_{2}
\backslash
right)$}{
\end_layout

\begin_layout Plain Layout

	$
\backslash
left(a=0
\backslash
right)
\backslash
land
\backslash
left(b=0
\backslash
right)
\backslash
land
\backslash
left(c=0
\backslash
right)$
\backslash
;
\end_layout

\begin_layout Plain Layout

	
\backslash
While{$
\backslash
left(a<
\backslash
right.$ len $
\backslash
left.
\backslash
left(
\backslash
ell_{1}
\backslash
right)
\backslash
right)
\backslash
land
\backslash
left(b<
\backslash
right.$ len $
\backslash
left.
\backslash
left(
\backslash
ell_{2}
\backslash
right)
\backslash
right)$}{
\end_layout

\begin_layout Plain Layout

		
\backslash
uIf{$
\backslash
ell_{1}
\backslash
left[a
\backslash
right]<
\backslash
ell_{2}
\backslash
left[b
\backslash
right]$}{
\end_layout

\begin_layout Plain Layout

			$
\backslash
ell_{3}
\backslash
left[c
\backslash
right]=
\backslash
ell_{1}
\backslash
left[a
\backslash
right]$
\backslash
;
\end_layout

\begin_layout Plain Layout

			$a+=1$
\backslash
;
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\begin_layout Plain Layout

		
\backslash
uElse{
\end_layout

\begin_layout Plain Layout

			$
\backslash
ell_{3}
\backslash
left[c
\backslash
right]=
\backslash
ell_{2}
\backslash
left[b
\backslash
right]$
\backslash
;
\end_layout

\begin_layout Plain Layout

			$b+=1$
\backslash
;
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\begin_layout Plain Layout

		$c+=1$
\backslash
;
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

	
\backslash
uIf{len $
\backslash
left(
\backslash
ell_{1}
\backslash
right)==a$}{
\end_layout

\begin_layout Plain Layout

		
\backslash
While{$b<$ len $
\backslash
left(
\backslash
ell_{2}
\backslash
right)$}{
\end_layout

\begin_layout Plain Layout

			$
\backslash
ell_{3}
\backslash
left[c
\backslash
right]=
\backslash
ell_{2}
\backslash
left[b
\backslash
right]$
\backslash
;
\end_layout

\begin_layout Plain Layout

			$
\backslash
left(b+=1
\backslash
right)
\backslash
land
\backslash
left(c+=1
\backslash
right)$
\backslash
;
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

	
\backslash
uElse{
\end_layout

\begin_layout Plain Layout

		
\backslash
While{$a<$ len $
\backslash
left(
\backslash
ell_{1}
\backslash
right)$}{
\end_layout

\begin_layout Plain Layout

			$
\backslash
ell_{3}
\backslash
left[c
\backslash
right]=
\backslash
ell_{1}
\backslash
left[a
\backslash
right]$
\backslash
;
\end_layout

\begin_layout Plain Layout

			$
\backslash
left(a+=1
\backslash
right)
\backslash
land
\backslash
left(c+=1
\backslash
right)$
\backslash
;
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

	
\backslash
Return{$
\backslash
ell_3$}
\backslash
;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout


\backslash
end{algorithm}
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\series bold
\color orange
\lang american
Upper bound (Big O)
\series default
\color inherit
: let 
\begin_inset Formula $f,g\in\bbr_{+}^{\bbn}$
\end_inset

 then 
\begin_inset Formula $\left(\exists c>0.\exists N\in\bbn.\forall n\ge N.\left|f\left(n\right)\right|\le c\cdot\left|g\left(n\right)\right|\right)\implies\left(f\in\O\left(g\right)\right)$
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
\color orange
\lang american
theorem
\series default
\color inherit
: let 
\begin_inset Formula $n,m\in\bbn$
\end_inset


\end_layout

\begin_layout Itemize

\size tiny
\lang american
\begin_inset Formula $\left(\substack{\text{for }\left(0\le i<n\right)\\
\O\left(1\right)
}
\right)$
\end_inset


\size default
 is 
\begin_inset Formula $\O\left(n\right)$
\end_inset

.
\end_layout

\begin_layout Itemize

\size tiny
\lang american
\begin_inset Formula $\left(\substack{\text{for }\left(0\le i<n\right)\\
\O\left(1\right)\\
\text{for }\left(0\le i<m\right)\\
\O\left(1\right)
}
\right)$
\end_inset


\size default
 is 
\begin_inset Formula $\O\left(n+m\right)$
\end_inset

.
\end_layout

\begin_layout Itemize

\size tiny
\lang american
\begin_inset Formula $\left(\substack{\text{for }\left(0\le i<n\right)\qquad\\
\qquad\text{for }\left(0\le j<m\right)\\
\quad\O\left(1\right)
}
\right)$
\end_inset


\size default
 is 
\begin_inset Formula $\O\left(n\cdot m\right)$
\end_inset

.
\end_layout

\begin_layout Itemize

\size tiny
\lang american
\begin_inset Formula $\left(\substack{\text{for }\left(0\le i<n\right)\qquad\\
\qquad\text{for }\left(0\le j<f\left(i\right)\right)\\
\quad\O\left(1\right)
}
\right)$
\end_inset


\size default
 is 
\begin_inset Formula $\O\left(\sum_{k=1}^{n}f\left(k\right)\right)$
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
\color orange
\lang american
conclusion
\series default
\color inherit
: let 
\begin_inset Formula $\ell_{1},\ell_{2}$
\end_inset

 be sorted lists of size 
\begin_inset Formula $n,m$
\end_inset

 and a key 
\begin_inset Formula $k$
\end_inset


\end_layout

\begin_layout Itemize

\lang american
Sequential search 
\begin_inset Formula $\in\O\left(n\right)$
\end_inset

.
\end_layout

\begin_layout Itemize

\lang american
Binary search 
\begin_inset Formula $\in\O\left(\log\left(n\right)\right)$
\end_inset

.
\end_layout

\begin_layout Itemize

\lang english
Selection sort 
\lang american

\begin_inset Formula $\in\O\left(n^{2}\right)$
\end_inset

.
\end_layout

\begin_layout Itemize

\lang american
Concatenate merge 
\begin_inset Formula $\in\O\left(n^{2}+m^{2}\right)$
\end_inset

.
\end_layout

\begin_layout Itemize

\lang american
Merge algorithm 
\begin_inset Formula $\in\O\left(n+m\right)$
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
\color orange
\lang american
Best case (bc)
\series default
\color inherit
: 
\begin_inset Formula $T_{best}\left(n\right)=\min\left\{ \O\left(f\left(a\right)\right)\mid\len\left(a\right)=n\right\} $
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
\color orange
\lang american
Worst
\series default
 
\series bold
case (wc)
\series default
\color inherit
: 
\begin_inset Formula $T_{worst}\left(n\right)=\max\left\{ \O\left(f\left(a\right)\right)\mid\len\left(a\right)=n\right\} $
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
\color orange
\lang american
claim
\series default
\color inherit
: Binary search is bc 
\begin_inset Formula $\O\left(1\right)$
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
\color orange
\lang american
Good
\series default
 
\series bold
algorithm
\series default
\color inherit
: algorithm 
\begin_inset Formula $f$
\end_inset

 for which 
\begin_inset Formula $\exists p\in\bbn\left[x\right].f\in\O\left(p\right)$
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
\color orange
\lang american
Tight bound (Big 
\begin_inset Formula $\boldsymbol{\Theta}$
\end_inset

)
\series default
\color inherit
: let 
\begin_inset Formula $f,g\in\bbr_{+}^{\bbn}$
\end_inset

 then 
\begin_inset Formula $\left(\left(f\in O\left(g\right)\right)\land\left(g\in O\left(f\right)\right)\right)\implies\left(f\in\Theta\left(g\right)\right)$
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
\color orange
\lang american
theorem
\series default
\color inherit
: let 
\begin_inset Formula $f,g\in\bbr_{+}^{\bbn}$
\end_inset

 then 
\begin_inset Formula $O\left(f+g\right)=O\left(\max\left\{ f,g\right\} \right)$
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
\color teal
\lang american
Recursive
\series default
 
\series bold
function
\series default
\color inherit
: function that calls itself.
\end_layout

\begin_layout Standard

\series bold
\color teal
\lang american
Base
\series default
 
\series bold
case
\series default
\color inherit
: let 
\begin_inset Formula $f\in B^{A}$
\end_inset

 be recursive then 
\begin_inset Formula $a\in A$
\end_inset

 such that 
\begin_inset Formula $f\left(a\right)$
\end_inset

 doesn't call itself.
\end_layout

\begin_layout Standard

\series bold
\color teal
\lang american
Recursion
\series default
 
\series bold
tree
\series default
\color inherit
: visualization of recursion via recursive relation.
\end_layout

\begin_layout Standard

\series bold
\color teal
\lang american
Fathers
\series default
\color inherit
: let 
\begin_inset Formula $\left<V,E\right>$
\end_inset

 be a tree and 
\begin_inset Formula $v\in V$
\end_inset

 then 
\begin_inset Formula $\left\{ u\in V\mid\left<u,v\right>\in E\right\} $
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
\color teal
\lang american
Sons
\series default
\color inherit
: let 
\begin_inset Formula $\left<V,E\right>$
\end_inset

 be a tree and 
\begin_inset Formula $v\in V$
\end_inset

 then 
\begin_inset Formula $\left\{ u\in V\mid\left<v,u\right>\in E\right\} $
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
\color teal
\lang american
Root
\series default
\color inherit
: let 
\begin_inset Formula $\left<V,E\right>$
\end_inset

 be a tree then 
\begin_inset Formula $\iota v\in V.\forall u\in V.\left<u,v\right>\notin E$
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
\color teal
\lang american
Envelope
\series default
 
\series bold
functions
\series default
\color inherit
: let 
\begin_inset Formula $f\in B^{A}$
\end_inset

 then 
\begin_inset Formula $g\in B^{C}$
\end_inset

 that calls 
\begin_inset Formula $f$
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
\color teal
\lang american
Quicksort
\series default
\color inherit
: let 
\begin_inset Formula $\ell$
\end_inset

 be a list and 
\begin_inset Formula $\left(s=0\right)\land\left(e=\len\left(\ell\right)\right)$
\end_inset

 then
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{algorithm}
\end_layout

\begin_layout Plain Layout


\backslash
Fn{quicksort $
\backslash
left(
\backslash
ell , s = 0, e = 
\backslash
text{len}
\backslash
left(
\backslash
ell
\backslash
right)
\backslash
right)$}{
\end_layout

\begin_layout Plain Layout

	$
\backslash
left(i = s
\backslash
right)
\backslash
land
\backslash
left(j = e
\backslash
right)$
\backslash
;
\end_layout

\begin_layout Plain Layout

	$p = $ Random $
\backslash
left(0,
\backslash
right.$ len $
\backslash
left.
\backslash
left(
\backslash
ell
\backslash
right)
\backslash
right)$
\backslash
;
\end_layout

\begin_layout Plain Layout

	
\backslash
uIf{$e 
\backslash
le s$}{
\backslash
Return{}
\backslash
;}
\end_layout

\begin_layout Plain Layout

	
\backslash
While{$i < j$}{
\end_layout

\begin_layout Plain Layout

		
\backslash
While{$
\backslash
left(
\backslash
ell
\backslash
left[ i
\backslash
right] 
\backslash
le 
\backslash
ell
\backslash
left[ p
\backslash
right]
\backslash
right)
\backslash
land
\backslash
left(i < e
\backslash
right)$}{$i+=1$
\backslash
;}
\end_layout

\begin_layout Plain Layout

		
\backslash
While{$
\backslash
ell
\backslash
left[ j
\backslash
right] > 
\backslash
ell
\backslash
left[ p
\backslash
right]$}{$j-=1$
\backslash
;}
\end_layout

\begin_layout Plain Layout

		
\backslash
uIf{$i < j$}{
\end_layout

\begin_layout Plain Layout

			$t = 
\backslash
ell
\backslash
left[ i
\backslash
right]$
\backslash
;
\end_layout

\begin_layout Plain Layout

			$
\backslash
ell
\backslash
left[ i
\backslash
right] = 
\backslash
ell
\backslash
left[ j
\backslash
right]$
\backslash
;
\end_layout

\begin_layout Plain Layout

			$
\backslash
ell
\backslash
left[ j
\backslash
right] = t$
\backslash
;
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

	$t = 
\backslash
ell
\backslash
left[ p
\backslash
right]$
\backslash
;
\end_layout

\begin_layout Plain Layout

	$
\backslash
ell
\backslash
left[ p
\backslash
right] = 
\backslash
ell
\backslash
left[ j
\backslash
right]$
\backslash
;
\end_layout

\begin_layout Plain Layout

	$
\backslash
ell
\backslash
left[ j
\backslash
right] = t$
\backslash
;
\end_layout

\begin_layout Plain Layout

	quicksort $
\backslash
left(
\backslash
ell ,s, j - 1
\backslash
right)$
\backslash
;
\end_layout

\begin_layout Plain Layout

	quicksort $
\backslash
left(
\backslash
ell ,j + 1, e
\backslash
right)$
\backslash
;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout


\backslash
end{algorithm}
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\series bold
\color teal
\lang american
claim
\series default
\color inherit
: quicksort holds 
\begin_inset Formula $\left(T_{worst}\left(n\right)=cn+T_{worst}\left(n-1\right)\right)\land\left(T_{best}\left(n\right)=cn+2T_{best}\left(\frac{n}{2}\right)\right)$
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
\color teal
\lang american
conclusion
\series default
\color inherit
: quicksort is (wc 
\begin_inset Formula $\O\left(n^{2}\right)$
\end_inset

)
\begin_inset Formula $\land$
\end_inset

(bc 
\begin_inset Formula $\O\left(n\log\left(n\right)\right)$
\end_inset

).
\end_layout

\begin_layout Standard

\series bold
\color teal
\lang american
Average
\series default
 
\series bold
case
\series default
\color inherit
: 
\begin_inset Formula $T_{average}\left(n\right)=\text{avg}\left\{ \O\left(f\left(a\right)\right)\mid\len\left(a\right)=n\right\} .$
\end_inset


\end_layout

\begin_layout Standard

\series bold
\color teal
\lang american
theorem
\series default
\color inherit
: quicksort is ac 
\begin_inset Formula $\O\left(n\log\left(n\right)\right)$
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
\lang american
Merge sort
\series default
: let 
\begin_inset Formula $\ell$
\end_inset

 be a list then
\end_layout

\begin_layout Standard

\lang american
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{algorithm}
\end_layout

\begin_layout Plain Layout


\backslash
Fn{mergeSort $
\backslash
left(
\backslash
ell
\backslash
right)$}{
\end_layout

\begin_layout Plain Layout

	$n = $ len $
\backslash
left(
\backslash
ell
\backslash
right)$
\backslash
;
\end_layout

\begin_layout Plain Layout

	
\backslash
uIf{$n 
\backslash
le 1$}{
\backslash
Return{$
\backslash
ell$}
\backslash
;}
\end_layout

\begin_layout Plain Layout

	
\backslash
uElse{
\end_layout

\begin_layout Plain Layout

		
\backslash
Return{$
\backslash
text{mergeSorted}
\backslash
left(
\end_layout

\begin_layout Plain Layout

			
\backslash
text{mergeSort}
\backslash
left(
\backslash
ell
\backslash
left[0
\backslash
ldots
\backslash
lfloor
\backslash
frac{n}{2}
\backslash
rfloor - 1
\backslash
right]
\backslash
right),
\end_layout

\begin_layout Plain Layout

			
\backslash
text{mergeSort}
\backslash
left(
\backslash
ell
\backslash
left[
\backslash
lfloor
\backslash
frac{n}{2}
\backslash
rfloor
\backslash
ldots n
\backslash
right]
\backslash
right)
\end_layout

\begin_layout Plain Layout

			
\backslash
right)$
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout


\backslash
end{algorithm}
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\series bold
\lang american
claim
\series default
: merge sort holds 
\begin_inset Formula $T\left(n\right)=cn+2\cdot T\left(\frac{n}{2}\right)$
\end_inset

 for wc and bc.
\end_layout

\begin_layout Standard

\series bold
\lang american
conclusion
\series default
: merge sort is 
\begin_inset Formula $\O\left(n\log\left(n\right)\right)$
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
\lang american
Hanoi
\series default
 
\series bold
towers
\series default
: the steps for beating the hanoi towers game are given by
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Standard

\lang american
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{algorithm}
\end_layout

\begin_layout Plain Layout


\backslash
Fn{hanoiTowers $
\backslash
left(n, s = 
\backslash
text{
\begin_inset Quotes eld
\end_inset

A
\begin_inset Quotes erd
\end_inset

}, v = 
\backslash
text{
\begin_inset Quotes eld
\end_inset

B
\begin_inset Quotes erd
\end_inset

}, e = 
\backslash
text{
\begin_inset Quotes eld
\end_inset

C
\begin_inset Quotes erd
\end_inset

}
\backslash
right)$}{
\end_layout

\begin_layout Plain Layout

	
\backslash
uIf{$n > 0$}{
\end_layout

\begin_layout Plain Layout

		$
\backslash
text{hanoiTowers}
\backslash
left(n - 1, s, e, v
\backslash
right)$
\backslash
;
\end_layout

\begin_layout Plain Layout

		$
\backslash
text{print}
\backslash
left(
\backslash
text{
\begin_inset Quotes eld
\end_inset

move disk
\begin_inset Quotes erd
\end_inset

} + n + 
\backslash
text{
\begin_inset Quotes eld
\end_inset

from
\begin_inset Quotes erd
\end_inset

} + s + 
\backslash
text{
\begin_inset Quotes eld
\end_inset

to
\begin_inset Quotes erd
\end_inset

} + t
\backslash
right)$
\backslash
;
\end_layout

\begin_layout Plain Layout

		$
\backslash
text{hanoiTowers}
\backslash
left(n - 1, v, s, e
\backslash
right)$
\backslash
;
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout


\backslash
end{algorithm}
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\series bold
\lang american
claim
\series default
: hanoi towers holds 
\begin_inset Formula $T\left(n\right)=2\cdot T\left(n-1\right)+1$
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
\lang american
conclusion
\series default
: hanoi towers is 
\begin_inset Formula $\O\left(2^{n}\right)$
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
\lang american
Hanoi
\series default
 
\series bold
monster
\series default
: the 
\begin_inset Formula $k^{th}$
\end_inset

 step in the hanoi towers algorithm is
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{algorithm}
\end_layout

\begin_layout Plain Layout


\backslash
Fn{hanoiMove $
\backslash
left(n, k, s = 
\backslash
text{
\begin_inset Quotes eld
\end_inset

A
\begin_inset Quotes erd
\end_inset

}, v = 
\backslash
text{
\begin_inset Quotes eld
\end_inset

B
\begin_inset Quotes erd
\end_inset

}, e = 
\backslash
text{
\begin_inset Quotes eld
\end_inset

C
\begin_inset Quotes erd
\end_inset

}
\backslash
right)$}{
\end_layout

\begin_layout Plain Layout

	
\backslash
uIf{$k == 2^{n - 1}$}{
\end_layout

\begin_layout Plain Layout

		$
\backslash
text{print}
\backslash
left(
\backslash
text{
\begin_inset Quotes eld
\end_inset

move disk
\begin_inset Quotes erd
\end_inset

} + n + 
\backslash
text{
\begin_inset Quotes eld
\end_inset

from
\begin_inset Quotes erd
\end_inset

} + s + 
\backslash
text{
\begin_inset Quotes eld
\end_inset

to
\begin_inset Quotes erd
\end_inset

} + t
\backslash
right)$
\backslash
;
\end_layout

\begin_layout Plain Layout

	} 
\backslash
uElseIf{$k < 2^{n - 1}$}{
\end_layout

\begin_layout Plain Layout

		$
\backslash
text{hanoiMove}
\backslash
left(n - 1, k, s, e, v 
\backslash
right)$
\end_layout

\begin_layout Plain Layout

	} 
\backslash
uElse{
\end_layout

\begin_layout Plain Layout

		$
\backslash
text{hanoiMove}
\backslash
left(n - 1, k, v, s, e
\backslash
right)$
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout


\backslash
end{algorithm}
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\series bold
\lang american
claim
\series default
: hanoi monster is wc 
\begin_inset Formula $\O\left(n\right)$
\end_inset

.
\end_layout

\begin_layout Standard

\lang american
\begin_inset Formula $ $
\end_inset


\end_layout

\end_body
\end_document
