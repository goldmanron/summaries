#LyX 2.4 created this file. For more info see https://www.lyx.org/
\lyxformat 620
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass article
\begin_preamble
\usepackage{centernot}
\usepackage{enumitem}
\usepackage{chngcntr}
\usepackage{tikz}
\usepackage{tikz-qtree}
\usepackage{wrapfig}
\usepackage{pgfplots}
\usepackage{hyperref}
\usepackage{xcolor}
% \usepackage[cm]{fullpage}
\usepackage{polynom}
\usepackage{booktabs}
\usepackage{fancyhdr}


% it's here?
\setlength{\tabcolsep}{1pt}
\renewcommand{\arraystretch}{1.25} % Default value: 1

% tikz
\usetikzlibrary{math}
\usetikzlibrary{shadows,trees}
\tikzset{edge from parent fork down, level distance=2cm, every node/.style= {rectangle,rounded corners, minimum height=8mm, very thick, align=center}}

% enumarte
\counterwithin*{section}{part}
\setlist{nosep, noitemsep}
\setlist[enumerate,1]{label = \arabic*., ref = \arabic*}
\setlist[enumerate,2]{label = \alph*), ref = \theenumi.\emph{\alph*}}
\setlist[enumerate,3]{label = .\roman*, ref = \theenumii.\roman*}
\setlist[itemize,1]{label={\fontfamily{david}\fontencoding{T1}\selectfont\textbullet}}

% colors
\definecolor{blue}{RGB}{14,107,217}
\definecolor{green}{RGB}{0,158,40}
\definecolor{red}{RGB}{235,16,16}
\definecolor{brown}{RGB}{164,66,0}
\definecolor{orange}{RGB}{231,135,26}
\definecolor{purple}{RGB}{94,53,177}
\definecolor{keywordcolor}{RGB}{255,117,0}
\definecolor{commentcolor}{RGB}{128,128,128}
\definecolor{stringcolor}{RGB}{0,168,0}
\definecolor{remarkcolor}{RGB}{150,145,91} % 255,225,88

\newcommand\mycommfont[1]{\footnotesize\ttfamily\textcolor{gray}{#1}}
\SetCommentSty{mycommfont}

% hyperlinks
\hypersetup{
    colorlinks=true,
    linkcolor=black,
    urlcolor=black,
}
\newcommand\colorAutoref[1]{{\hypersetup{linkcolor=blue}\autoref{#1}}}  %% allows for calls to \autoref{} that have a different color from other links.

% math font and implies arrow
% \setmathfont{NewCMMath-Regular.otf}
\let\RonMikhelmanLol\implies
\renewcommand{\implies}{\negthickspace\RonMikhelmanLol\negthickspace}
\let\RonMikhelmanLoll\iff
\renewcommand{\iff}{\negthickspace\RonMikhelmanLoll\negthickspace}
\let\RonMikhelmanLolll\impliedby
\renewcommand{\impliedby}{\negthickspace\RonMikhelmanLolll\negthickspace}

%for defnos
\usepackage{multicol}
\usepackage{color}
\setlength{\columnseprule}{1pt}
\def\columnseprulecolor{\color{black}}
\end_preamble
\options no-math
\use_default_options true
\begin_modules
algorithm2e
\end_modules
\maintain_unincluded_children no
\begin_local_layout
Format 66
PackageOptions algorithm2e vlined
\end_local_layout
\language hebrew
\language_package default
\inputencoding auto-legacy
\fontencoding auto
\font_roman "default" "David CLM"
\font_sans "default" "Times New Roman"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts true
\font_sc false
\font_roman_osf false
\font_sans_osf false
\font_typewriter_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype false
\use_dash_ligatures true
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\float_placement H
\float_alignment class
\paperfontsize default
\spacing onehalf
\use_hyperref true
\pdf_author "Ron Mikhelman"
\pdf_subject "Math Summeries"
\pdf_bookmarks true
\pdf_bookmarksnumbered false
\pdf_bookmarksopen false
\pdf_bookmarksopenlevel 1
\pdf_breaklinks false
\pdf_pdfborder false
\pdf_colorlinks false
\pdf_backref false
\pdf_pdfusetitle true
\papersize letter
\use_geometry true
\use_package amsmath 2
\use_package amssymb 2
\use_package cancel 2
\use_package esint 2
\use_package mathdots 2
\use_package mathtools 2
\use_package mhchem 2
\use_package stackrel 2
\use_package stmaryrd 2
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date true
\justification false
\use_refstyle 1
\use_formatted_ref 0
\use_minted 0
\use_lineno 0
\index Index
\shortcut idx
\color #008000
\end_index
\leftmargin 2cm
\topmargin 2cm
\rightmargin 2cm
\bottommargin 2cm
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation 0bp
\is_math_indent 0
\math_numbering_side default
\quotes_style english
\dynamic_quotes 0
\papercolumns 1
\papersides 1
\paperpagestyle empty
\tablestyle default
\tracking_changes false
\output_changes false
\change_bars false
\postpone_fragile_content false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\docbook_table_output 0
\docbook_mathml_prefix 1
\end_header

\begin_body

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand include
filename "../../macros.lyx"
literal "true"

\end_inset


\end_layout

\begin_layout Standard

\series bold
גרף מכוון קשיר
\series default
:
 גרף מכוון 
\begin_inset Formula $G$
\end_inset

 עבורו לכל 
\begin_inset Formula $u,v\in V\left(G\right)$
\end_inset

 קיים מסלול מ־
\begin_inset Formula $u$
\end_inset

 ל־
\begin_inset Formula $v$
\end_inset

 או מסלול מ־
\begin_inset Formula $v$
\end_inset

 ל־
\begin_inset Formula $u$
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
גרף מכוון קשיר חזק
\series default
:
 גרף מכוון 
\begin_inset Formula $G$
\end_inset

 עבורו לכל 
\begin_inset Formula $u,v\in V\left(G\right)$
\end_inset

 קיים מסלול מ־
\begin_inset Formula $u$
\end_inset

 ל־
\begin_inset Formula $v$
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
אלגוריתם 
\begin_inset Formula $\text{BFS}$
\end_inset


\series default
:
 יהי 
\begin_inset Formula $G$
\end_inset

 גרף ויהי 
\begin_inset Formula $s\in V\left(G\right)$
\end_inset

 אזי
\end_layout

\begin_layout Standard

\lang english
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
begin{algorithm}
\end_layout

\begin_layout Plain Layout


\backslash
SetAlgoLined
\end_layout

\begin_layout Plain Layout


\backslash
SetKwFunction{BFS}{BFS}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
SetKwProg{Fn}{function}{:}{}
\end_layout

\begin_layout Plain Layout


\backslash
Fn{
\backslash
BFS{$G,
 s$}}{
\end_layout

\begin_layout Plain Layout

    $
\backslash
left(d,
 
\backslash
pi,
 
\backslash
text{color}
\backslash
right)
\backslash
gets$ dict($V
\backslash
left(G
\backslash
right)$)
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

    
\backslash
For{$u
\backslash
in V 
\backslash
left( G
\backslash
right)
\backslash
backslash 
\backslash
{s
\backslash
}$}{
\end_layout

\begin_layout Plain Layout

        color[u] $
\backslash
leftarrow$ White
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

        d[u] $
\backslash
leftarrow
\backslash
infty$
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

        $
\backslash
pi$[u] $
\backslash
leftarrow$ Null
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    color[s] $
\backslash
leftarrow$ Grey
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

    d[s] $
\backslash
leftarrow 0$
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

    $
\backslash
pi$[s] $
\backslash
leftarrow$ Null
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

    Q $
\backslash
gets$ queue()
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

    
\backslash
While{$Q 
\backslash
ne 
\backslash
emptyset$}{
\end_layout

\begin_layout Plain Layout

        $u 
\backslash
gets $ Q.head
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

        
\backslash
For{$v
\backslash
in Neighbor(u)$}{
\end_layout

\begin_layout Plain Layout

            
\backslash
uIf{color[v] = White}{
\end_layout

\begin_layout Plain Layout

                color[$v$] $
\backslash
leftarrow$ Grey
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

                $d[v]
\backslash
leftarrow d[u]+1$
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

                $
\backslash
pi[v]
\backslash
leftarrow u$
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

                Q.enqueue($v$)
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

            }
\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

        Q.dequeue()
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

        color[$u$] $
\backslash
gets$ Black
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    
\backslash
Return $
\backslash
left(d,
 
\backslash
pi,
 
\backslash
text{color}
\backslash
right)$
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout


\backslash
end{algorithm}
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\series bold
טענה
\series default
:
 יהי 
\begin_inset Formula $G$
\end_inset

 גרף ויהי 
\begin_inset Formula $s\in V\left(G\right)$
\end_inset

 אזי סיבוכיות זמן הריצה של 
\begin_inset Formula $\text{BFS}\left(G,s\right)$
\end_inset

 הינה 
\begin_inset Formula $\O\left(\left|V\right|+\left|E\right|\right)$
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
משפט
\series default
:
 יהי 
\begin_inset Formula $G$
\end_inset

 גרף ויהי 
\begin_inset Formula $s\in V$
\end_inset

 אזי 
\begin_inset Formula $\left\{ v\in V\mid\text{BFS}\left(G,s\right).\text{color}\left[v\right]=\text{Black}\right\} =\left[s\right]_{\to}$
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
סימון
\series default
:
 יהי 
\begin_inset Formula $G$
\end_inset

 גרף ויהיו 
\begin_inset Formula $u,v\in V$
\end_inset

 אזי 
\begin_inset Formula $\d\left(v,u\right)=\min\left(\left\{ \text{len}\left(\sigma\right)\mid v,u\text{ טיול בין }\sigma\right\} \right)$
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
טענה
\series default
:
 יהי 
\begin_inset Formula $G$
\end_inset

 גרף ויהיו 
\begin_inset Formula $v,u,w\in V$
\end_inset

 באשר 
\begin_inset Formula $\left(w,u\right)\in E$
\end_inset

 אזי 
\begin_inset Formula $\d\left(v,u\right)\le\d\left(v,w\right)+1$
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
למה
\series default
:
 יהי 
\begin_inset Formula $G$
\end_inset

 גרף ויהיו 
\begin_inset Formula $s,v\in V$
\end_inset

 אזי בכל שלב בהרצת 
\begin_inset Formula $\text{BFS}\left(G,s\right)$
\end_inset

 מתקיים 
\begin_inset Formula $d\left[v\right]\ge\d\left(v\right)$
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
למה
\series default
:
 יהי 
\begin_inset Formula $G$
\end_inset

 גרף יהי שלב בהרצת 
\begin_inset Formula $\text{BFS}\left(G,s\right)$
\end_inset

 בו 
\begin_inset Formula $Q=\left(v_{1}\ldots v_{n}\right)$
\end_inset

 אזי מתקיים 
\begin_inset Formula $d\left[v_{i}\right]\le d\left[v_{i+1}\right]$
\end_inset

 וכן 
\begin_inset Formula $d\left[v_{i}\right]\le d\left[v_{1}\right]+1$
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
משפט נכונות מרחקים
\series default
:
 יהי 
\begin_inset Formula $G$
\end_inset

 גרף ויהיו 
\begin_inset Formula $s,v\in V$
\end_inset

 אזי 
\begin_inset Formula $\text{BFS}\left(G,s\right).d\left[v\right]=\d\left(v,s\right)$
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
עץ 
\begin_inset Formula $\text{BFS}$
\end_inset


\series default
:
 יהי 
\begin_inset Formula $G$
\end_inset

 גרף ויהי 
\begin_inset Formula $s\in V$
\end_inset

 נגדיר 
\begin_inset Formula $V_{\pi}=\left\{ v\in V\mid\text{BFS}\left(G,s\right).\pi\left[v\right]\ne\text{Null}\right\} \cup\left\{ s\right\} $
\end_inset

 וכן 
\begin_inset Formula $E_{\pi}=\left\{ \left(\pi\left[v\right],v\right)\mid v\in V_{\pi}\backslash\left\{ s\right\} \right\} $
\end_inset

 אזי 
\begin_inset Formula $G_{\pi}=\left(V_{\pi},E_{\pi}\right)$
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
טענה
\series default
:
 יהי 
\begin_inset Formula $G$
\end_inset

 גרף ויהי 
\begin_inset Formula $s\in V$
\end_inset

 אזי
\end_layout

\begin_layout Itemize
מתקיים 
\begin_inset Formula $\deg_{G_{\pi}}^{-}\left(s\right)=0$
\end_inset

.
\end_layout

\begin_layout Itemize
לכל 
\begin_inset Formula $v\in V\left(G_{\pi}\right)$
\end_inset

 מתקיים 
\begin_inset Formula $\deg_{G_{\pi}}^{-}\left(v\right)=1$
\end_inset

.
\end_layout

\begin_layout Itemize
לכל 
\begin_inset Formula $v\in V\left(G_{\pi}\right)$
\end_inset

 קיים מסלול ב־
\begin_inset Formula $G_{\pi}$
\end_inset

 בין 
\begin_inset Formula $s,v$
\end_inset

.
\end_layout

\begin_layout Itemize
\begin_inset Formula $G_{\pi}$
\end_inset

 הינו עץ.
\end_layout

\begin_layout Itemize
יהי 
\begin_inset Formula $v\in V\left(G_{\pi}\right)$
\end_inset

 ויהי 
\begin_inset Formula $\sigma$
\end_inset

 מסלול ב־
\begin_inset Formula $G_{\pi}$
\end_inset

 בין 
\begin_inset Formula $s,v$
\end_inset

 אזי 
\begin_inset Formula $\sigma$
\end_inset

 המסלול הקצר ביותר בין 
\begin_inset Formula $s,v$
\end_inset

 ב־
\begin_inset Formula $G$
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
מסלול אוילר
\series default
:
 מסלול העובר על כל הקשתות בגרף.
\end_layout

\begin_layout Standard

\series bold
מעגל אוילר
\series default
:
 מסלול אוילר שהינו מעגל.
\end_layout

\begin_layout Standard

\series bold
טענה
\series default
:
 יהי 
\begin_inset Formula $G$
\end_inset

 גרף קשיר ולא מכוון אזי (יש מעגל אוילר ב־
\begin_inset Formula $G$
\end_inset

)
\begin_inset Formula $\iff$
\end_inset

(לכל 
\begin_inset Formula $v\in V$
\end_inset

 מתקיים 
\begin_inset Formula $\deg\left(v\right)\in\bbn_{\text{even}}$
\end_inset

).
\end_layout

\begin_layout Standard

\series bold
אלגוריתם למציאת מעגל אוילר
\series default
:
 יהי 
\begin_inset Formula $G$
\end_inset

 גרף קשיר ולא מכוון עבורו לכל 
\begin_inset Formula $u\in V$
\end_inset

 מתקיים 
\begin_inset Formula $\deg\left(u\right)\in\bbn_{\text{even}}$
\end_inset

 אזי
\end_layout

\begin_layout Standard

\lang english
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
begin{algorithm}
\end_layout

\begin_layout Plain Layout


\backslash
SetAlgoLined
\end_layout

\begin_layout Plain Layout


\backslash
SetKwFunction{EulerCircle}{EulerCircle}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
SetKwProg{Fn}{function}{:}{}
\end_layout

\begin_layout Plain Layout


\backslash
Fn{
\backslash
EulerCircle{$G,
 v$}}{
\end_layout

\begin_layout Plain Layout

    $
\backslash
sigma 
\backslash
gets 
\backslash
text{List}(E(G))$
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

    $u 
\backslash
gets Neighbor(v)$
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

    
\backslash
While{$u
\backslash
ne v$}{
\end_layout

\begin_layout Plain Layout

        $
\backslash
sigma .
\backslash
text{append}(
\backslash
{v,
 u
\backslash
})$
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

        $G = G
\backslash
backslash 
\backslash
{
\backslash
{v,
 u
\backslash
}
\backslash
}$
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

        $u 
\backslash
gets 
\backslash
text{Neighbor}(u)$
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    
\backslash
uIf{$length(
\backslash
sigma) = |E(G)|$}{
\end_layout

\begin_layout Plain Layout

        
\backslash
Return $
\backslash
sigma$
\end_layout

\begin_layout Plain Layout

    } 
\backslash
uElse{
\end_layout

\begin_layout Plain Layout

        $w 
\backslash
gets 
\backslash
{x
\backslash
in V(G)
\backslash
mid (
\backslash
exists y
\backslash
in V(G).
 (x,
 y)
\backslash
in
\backslash
sigma)
\backslash
land(
\backslash
deg(x)>0)
\backslash
}$
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

        $
\backslash
sigma[w] = 
\backslash
EulerCircle{G,
 w}$
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    
\backslash
Return $
\backslash
sigma$
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout


\backslash
end{algorithm}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Standard

\series bold
טענה
\series default
:
 יהי 
\begin_inset Formula $G$
\end_inset

 גרף קשיר ולא מכוון עבורו לכל 
\begin_inset Formula $u\in V$
\end_inset

 מתקיים 
\begin_inset Formula $\deg\left(u\right)\in\bbn_{\text{even}}$
\end_inset

 ויהי 
\begin_inset Formula $v\in V\left(G\right)$
\end_inset

 אזי סיבוכיות זמן הריצה של 
\begin_inset Formula $\text{EulerCircle}\left(G,v\right)$
\end_inset

 הינה 
\begin_inset Formula $\O\left(\left|E\right|\right)$
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
טענה
\series default
:
 באלגוריתם 
\begin_inset Formula $\text{EulerCircle}$
\end_inset

 כל עוד לולאת ה־
\begin_inset Formula $\text{while}$
\end_inset

 פעילה מתקיים 
\begin_inset Formula $\left|\text{Neighbor}\left(u\right)\right|\ne\emptyset$
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
משפט
\series default
:
 יהי 
\begin_inset Formula $G$
\end_inset

 גרף קשיר ולא מכוון עבורו לכל 
\begin_inset Formula $v\in V$
\end_inset

 מתקיים 
\begin_inset Formula $\deg\left(v\right)\in\bbn_{\text{even}}$
\end_inset

 אזי 
\begin_inset Formula $\text{EulerCircle}\left(G\right)$
\end_inset

 הינו מעגל אוילר.
\end_layout

\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Standard

\series bold
טענה
\series default
:
 יהי 
\begin_inset Formula $G$
\end_inset

 גרף קשיר ולא מכוון אזי (יש מסלול אוילר שאינו מעגל ב־
\begin_inset Formula $G$
\end_inset

)
\begin_inset Formula $\iff$
\end_inset

(
\begin_inset Formula $\left|\left\{ v\in V\left(G\right)\mid\deg\left(v\right)\in\bbn_{\text{odd}}\right\} \right|=2$
\end_inset

).
\end_layout

\begin_layout Standard

\series bold
אלגוריתם למציאת מסלול אוילר
\series default
:
 יהי 
\begin_inset Formula $G$
\end_inset

 גרף קשיר ולא מכוון עבורו 
\begin_inset Formula $\left|\left\{ v\in V\left(G\right)\mid\deg\left(v\right)\in\bbn_{\text{odd}}\right\} \right|=2$
\end_inset

 אזי
\end_layout

\begin_layout Standard

\lang english
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
begin{algorithm}
\end_layout

\begin_layout Plain Layout


\backslash
SetAlgoLined
\end_layout

\begin_layout Plain Layout


\backslash
SetKwFunction{EulerPath}{EulerPath}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
SetKwProg{Fn}{function}{:}{}
\end_layout

\begin_layout Plain Layout


\backslash
Fn{
\backslash
EulerPath{$G$}}{
\end_layout

\begin_layout Plain Layout

    $
\backslash
{v,
 u
\backslash
}
\backslash
gets
\backslash
left
\backslash
{ v
\backslash
in V
\backslash
left(G
\backslash
right)
\backslash
mid
\backslash
deg
\backslash
left(v
\backslash
right)
\backslash
in
\backslash
mathbb{N}_{
\backslash
text{odd}}
\backslash
right
\backslash
}$
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

    $G = G + 
\backslash
{
\backslash
{v,
 u
\backslash
}
\backslash
}$
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

    $
\backslash
sigma = 
\backslash
text{EulerCircle}{(G,
 v)}$
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

    
\backslash
Return $
\backslash
sigma
\backslash
backslash 
\backslash
{v,
 u
\backslash
}$
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout


\backslash
end{algorithm}
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\series bold
טענה
\series default
:
 יהי 
\begin_inset Formula $G$
\end_inset

 גרף לא מכוון אזי (
\begin_inset Formula $G$
\end_inset

 דו־צדדי)
\begin_inset Formula $\iff$
\end_inset

(לא קיים ב־
\begin_inset Formula $G$
\end_inset

 מעגל באורך אי־זוגי).
\end_layout

\begin_layout Standard

\series bold
אלגוריתם זיהוי גרפים דו־צדדיים
\series default
:
 יהי 
\begin_inset Formula $G$
\end_inset

 גרף לא מכוון ופשוט אזי
\end_layout

\begin_layout Standard

\lang english
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
begin{algorithm}
\end_layout

\begin_layout Plain Layout


\backslash
SetAlgoLined
\end_layout

\begin_layout Plain Layout


\backslash
DontPrintSemicolon
\end_layout

\begin_layout Plain Layout


\backslash
SetKwFunction{IsBipartite}{IsBipartite}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
SetKwProg{Fn}{function}{:}{}
\end_layout

\begin_layout Plain Layout


\backslash
Fn{
\backslash
IsBipartite{$G$}}{
\end_layout

\begin_layout Plain Layout

    $
\backslash
left(d,
 
\backslash
pi,
 
\backslash
text{color}
\backslash
right)
\backslash
gets$ BFS($G$)
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

    
\backslash
For{$
\backslash
left(v,u
\backslash
right)
\backslash
in V$}{
\end_layout

\begin_layout Plain Layout

        
\backslash
lIf{$d
\backslash
left(v
\backslash
right) = d
\backslash
left(u
\backslash
right)$}{
\end_layout

\begin_layout Plain Layout

            
\backslash
Return False
\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    
\backslash
Return True
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout


\backslash
end{algorithm}
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\series bold
טענה
\series default
:
 יהי 
\begin_inset Formula $G$
\end_inset

 גרף לא מכוון ופשוט אזי (
\begin_inset Formula $G$
\end_inset

 דו־צדדי)
\begin_inset Formula $\iff$
\end_inset

(
\begin_inset Formula $\text{IsBipartite}\left(G\right)=\text{True}$
\end_inset

).
\end_layout

\begin_layout Standard

\series bold
מסלול קצר ביותר בין קודקודים
\series default
:
 יהי 
\begin_inset Formula $G$
\end_inset

 גרף ויהיו 
\begin_inset Formula $s,t\in V$
\end_inset

 אזי מסלול 
\begin_inset Formula $\sigma$
\end_inset

 מ־
\begin_inset Formula $s$
\end_inset

 ל־
\begin_inset Formula $t$
\end_inset

 עבורו 
\begin_inset Formula $\left|\sigma\right|=\min\left\{ \left|\tau\right|\mid t\text{ ל־}s\text{ מסלול מ־}\tau\right\} $
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
גרף המסלולים הקצרים ביותר מקודקוד (גרף מק
\begin_inset Quotes erd
\end_inset

ב)
\series default
:
 יהי 
\begin_inset Formula $G$
\end_inset

 גרף ויהי 
\begin_inset Formula $s\in V$
\end_inset

 נגדיר
\begin_inset Newline newline
\end_inset


\begin_inset Formula $E^{\prime}=\left\{ e\in E\mid s\text{ חלק ממסלול קצר ביותר היוצא מ־}e\right\} $
\end_inset

 אזי 
\begin_inset Formula $\left(V,E^{\prime}\right)$
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
אלגוריתם למציאת גרף המסלולים הקצרים ביותר מקודקוד
\series default
:
 יהי 
\begin_inset Formula $G$
\end_inset

 גרף ויהי 
\begin_inset Formula $s\in V$
\end_inset

 אזי
\end_layout

\begin_layout Standard

\lang english
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
begin{algorithm}
\end_layout

\begin_layout Plain Layout


\backslash
SetAlgoLined
\end_layout

\begin_layout Plain Layout


\backslash
SetKwFunction{name}{ShortestPathGraph}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
SetKwProg{Fn}{function}{:}{}
\end_layout

\begin_layout Plain Layout


\backslash
Fn{
\backslash
name{$G,
 s$}}{
\end_layout

\begin_layout Plain Layout

    $
\backslash
left(d,
 
\backslash
pi,
 
\backslash
text{color}
\backslash
right)
\backslash
gets
\backslash
text{BFS}(G)$
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

    $E^
\backslash
prime 
\backslash
gets E(G_
\backslash
pi)$
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

    
\backslash
For{$(u,
 v)
\backslash
in E(G)$}{
\end_layout

\begin_layout Plain Layout

        
\backslash
uIf{$|
\backslash
text{height}_{G_
\backslash
pi}(u) - 
\backslash
text{height}_{G_
\backslash
pi(v)}| = 1$}{
\end_layout

\begin_layout Plain Layout

            $E^
\backslash
prime .
\backslash
text{append} ((u,
 v))$
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    
\backslash
Return $(V(G),
 E^
\backslash
prime)$
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout


\backslash
end{algorithm}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Standard

\series bold
טענה
\series default
:
 תהא 
\begin_inset Formula $e\in E$
\end_inset

 אזי (
\begin_inset Formula $e$
\end_inset

 מחברת בין רמות עוקבות ביער 
\begin_inset Formula $\text{BFS}$
\end_inset

 
\begin_inset Formula $G_{\pi}$
\end_inset

)
\begin_inset Formula $\iff$
\end_inset

(
\begin_inset Formula $e$
\end_inset

 קשת במק
\begin_inset Quotes erd
\end_inset

ב).
\end_layout

\begin_layout Standard

\series bold
מסקנה
\series default
:
 יהי 
\begin_inset Formula $G$
\end_inset

 גרף ויהי 
\begin_inset Formula $s\in V$
\end_inset

 אזי 
\begin_inset Formula $\text{ShortestPathGraph}\left(G,s\right)$
\end_inset

 הינו גרף מק
\begin_inset Quotes erd
\end_inset

ב מ־
\begin_inset Formula $s$
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
גרף המסלולים הקצרים ביותר בין קודקודים
\series default
:
 יהי 
\begin_inset Formula $G$
\end_inset

 גרף ויהיו 
\begin_inset Formula $s,t\in V$
\end_inset

 נגדיר
\begin_inset Newline newline
\end_inset


\begin_inset Formula $E^{\prime}=\left\{ e\in E\mid t\text{ ל־}s\text{ חלק ממסלול קצר ביותר היוצא מ־}e\right\} $
\end_inset

 אזי 
\begin_inset Formula $\left(V,E^{\prime}\right)$
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
טענה
\series default
:
 יהי 
\begin_inset Formula $G$
\end_inset

 גרף מכוון ויהיו 
\begin_inset Formula $s,t\in V$
\end_inset

 אזי קיים אלגוריתם לחישוב גרף המסלולים הקצרים ביותר מ־
\begin_inset Formula $s$
\end_inset

 ל־
\begin_inset Formula $t$
\end_inset

 בסיבוכיות זמן ריצה 
\begin_inset Formula $\O\left(\left|V\right|+\left|E\right|\right)$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Standard

\series bold
אלגוריתם 
\begin_inset Formula $\text{DFS}$
\end_inset


\series default
:
 יהי 
\begin_inset Formula $G$
\end_inset

 גרף ויהי 
\begin_inset Formula $s\in V$
\end_inset

 אזי
\end_layout

\begin_layout Standard

\lang english
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
begin{algorithm}
\end_layout

\begin_layout Plain Layout


\backslash
SetAlgoLined
\end_layout

\begin_layout Plain Layout


\backslash
SetKwFunction{DFS}{DFS}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
SetKwProg{Fn}{function}{:}{}
\end_layout

\begin_layout Plain Layout


\backslash
Fn{
\backslash
DFS{$G,
 s$}}{
\end_layout

\begin_layout Plain Layout

    $
\backslash
left(k,
 
\backslash
pi
\backslash
right)
\backslash
gets$ dict($V$)
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

    $
\backslash
text{color}
\backslash
gets$ dict($E$)
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

    $k[s] 
\backslash
gets 1$
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

    $
\backslash
pi[s] 
\backslash
gets 
\backslash
text{Null}$
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

    
\backslash
For{$u
\backslash
in V
\backslash
backslash{s}$}{
\end_layout

\begin_layout Plain Layout

        $k[u] 
\backslash
gets 0$
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

        $
\backslash
pi[u] 
\backslash
gets 
\backslash
text{Null}$
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    
\backslash
For{$e
\backslash
in E$}{
\end_layout

\begin_layout Plain Layout

        $
\backslash
text{color}[e] 
\backslash
gets 
\backslash
text{White}$
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    $i
\backslash
gets 2$
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

    $v
\backslash
gets s$
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

    
\backslash
While{$
\backslash
left(
\backslash
exists u
\backslash
in Adj(v).
 
\backslash
text{color}[(v,u)] = 
\backslash
text{White}
\backslash
right) 
\backslash
lor 
\backslash
left(
\backslash
pi[v]
\backslash
ne
\backslash
text{Null}
\backslash
right)$}{
\end_layout

\begin_layout Plain Layout

        
\backslash
uIf{$
\backslash
{u
\backslash
in Adj(v)
\backslash
mid
\backslash
text{color}[(v,u)] = 
\backslash
text{White}
\backslash
}
\backslash
ne
\backslash
emptyset$}{
\end_layout

\begin_layout Plain Layout

            $w
\backslash
gets 
\backslash
{u
\backslash
in Adj(v)
\backslash
mid
\backslash
text{color}[(v,u)] = 
\backslash
text{White}
\backslash
}$
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

            $
\backslash
text{color}[(v,
 w)]
\backslash
gets
\backslash
text{Black}$
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

            
\backslash
uIf{$k[w] = 0$}{
\end_layout

\begin_layout Plain Layout

                $k[w]
\backslash
gets i$
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

                $
\backslash
pi[w]
\backslash
gets v$
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

                $v
\backslash
gets w$
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

                $i
\backslash
gets i+1$
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

            }
\end_layout

\begin_layout Plain Layout

        } 
\backslash
uElse{
\end_layout

\begin_layout Plain Layout

            $v
\backslash
gets
\backslash
pi[v]$
\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    
\backslash
Return $
\backslash
left(k,
 
\backslash
pi
\backslash
right)$
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout


\backslash
end{algorithm}
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\series bold
טענה
\series default
:
 יהי 
\begin_inset Formula $G$
\end_inset

 גרף ויהי 
\begin_inset Formula $s\in V$
\end_inset

 אזי סיבוכיות זמן הריצה של 
\begin_inset Formula $\text{DFS}\left(G,s\right)$
\end_inset

 הינה 
\begin_inset Formula $\O\left(\left|V\right|+\left|E\right|\right)$
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
זמן גילוי
\series default
:
 יהי 
\begin_inset Formula $G$
\end_inset

 גרף ויהי 
\begin_inset Formula $s\in V\left(G\right)$
\end_inset

 אזי 
\begin_inset Formula $k$
\end_inset

 בהרצת 
\begin_inset Formula $\text{DFS}\left(G,s\right)$
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
טענה
\series default
:
 יהי 
\begin_inset Formula $G$
\end_inset

 גרף ויהיו 
\begin_inset Formula $s,v\in V$
\end_inset

 באשר 
\begin_inset Formula $v\in\left[s\right]_{\to}$
\end_inset

 אזי בהרצת 
\begin_inset Formula $\text{DFS}\left(G,s\right)$
\end_inset

 מתקיים 
\begin_inset Formula $k\left[v\right]>0$
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
עץ 
\begin_inset Formula $\text{DFS}$
\end_inset


\series default
:
 יהי 
\begin_inset Formula $G$
\end_inset

 גרף ויהי 
\begin_inset Formula $s\in V$
\end_inset

 נגדיר 
\begin_inset Formula $V_{\pi}=\left\{ v\in V\mid\text{DFS}\left(G,s\right).\pi\left[v\right]\ne\text{Null}\right\} \cup\left\{ s\right\} $
\end_inset

 וכן 
\begin_inset Formula $E_{\pi}=\left\{ \left(\pi\left[v\right],v\right)\mid v\in V_{\pi}\backslash\left\{ s\right\} \right\} $
\end_inset

 אזי 
\begin_inset Formula $G_{\pi}=\left(V_{\pi},E_{\pi}\right)$
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
טענה
\series default
:
 עץ 
\begin_inset Formula $\text{DFS}$
\end_inset

 הינו עץ.
\end_layout

\begin_layout Standard

\series bold
קשתות ביחס לריצת 
\begin_inset Formula $\text{DFS}$
\end_inset


\series default
:
 יהי 
\begin_inset Formula $G$
\end_inset

 גרף ויהי 
\begin_inset Formula $G_{\pi}$
\end_inset

 יער 
\begin_inset Formula $\text{DFS}$
\end_inset

 אזי
\end_layout

\begin_layout Itemize
קשתות עץ:
 קשת 
\begin_inset Formula $e\in E\left(G\right)$
\end_inset

 עבורה 
\begin_inset Formula $e\in E\left(G_{\pi}\right)$
\end_inset

.
\end_layout

\begin_layout Itemize
קשתות קדמיות:
 קשת 
\begin_inset Formula $\left(u,v\right)\in E\left(G\right)$
\end_inset

 עבורה 
\begin_inset Formula $\left(u,v\right)\notin E\left(G_{\pi}\right)$
\end_inset

 וכן 
\begin_inset Formula $u$
\end_inset

 הינו אב של 
\begin_inset Formula $v$
\end_inset

.
\end_layout

\begin_layout Itemize
קשתות אחוריות:
 קשת 
\begin_inset Formula $\left(u,v\right)\in E\left(G\right)$
\end_inset

 עבורה 
\begin_inset Formula $\left(u,v\right)\notin E\left(G_{\pi}\right)$
\end_inset

 וכן 
\begin_inset Formula $v$
\end_inset

 הינו אב של 
\begin_inset Formula $u$
\end_inset

.
\end_layout

\begin_layout Itemize
קשתות חוצות:
 קשת 
\begin_inset Formula $e\in E\left(G\right)$
\end_inset

 שאינה קשת עץ או קדמית או אחורית.
\end_layout

\begin_layout Standard

\series bold
טענה
\series default
:
 יהי 
\begin_inset Formula $G$
\end_inset

 גרף לא מכוון ותהא 
\begin_inset Formula $\left(u,v\right)$
\end_inset

 קשת עץ אזי 
\begin_inset Formula $u$
\end_inset

 צאצא של 
\begin_inset Formula $v$
\end_inset

 בגרף 
\begin_inset Formula $G_{\pi}$
\end_inset

 או 
\begin_inset Formula $v$
\end_inset

 צאצא של 
\begin_inset Formula $u$
\end_inset

 בגרף 
\begin_inset Formula $G_{\pi}$
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
מסקנה
\series default
:
 יהי 
\begin_inset Formula $G$
\end_inset

 גרף לא מכוון אזי לא קיימות קשתות חוצות.
\end_layout

\begin_layout Standard

\series bold
אלגוריתם 
\begin_inset Formula $\text{DFS}$
\end_inset

 בעל זמני נסיגה
\series default
:
 יהי 
\begin_inset Formula $G$
\end_inset

 גרף אזי
\end_layout

\begin_layout Standard

\lang english
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
begin{algorithm}
\end_layout

\begin_layout Plain Layout


\backslash
SetAlgoLined
\end_layout

\begin_layout Plain Layout


\backslash
SetKwFunction{DFS}{DFS}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
SetKwProg{Fn}{function}{:}{}
\end_layout

\begin_layout Plain Layout


\backslash
Fn{
\backslash
DFS{$G$}}{
\end_layout

\begin_layout Plain Layout

    $
\backslash
left(k,
 f,
 
\backslash
pi,
 
\backslash
text{color},
 
\backslash
text{low}
\backslash
right)
\backslash
gets$ dict($V$)
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

    
\backslash
For{$u
\backslash
in V$}{
\end_layout

\begin_layout Plain Layout

        $k[u] 
\backslash
gets 0$
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

        $
\backslash
pi[u] 
\backslash
gets 
\backslash
text{Null}$
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

        $
\backslash
text{color} 
\backslash
gets 
\backslash
text{White}$
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

        $
\backslash
text{low} 
\backslash
gets 
\backslash
infty$
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    $i 
\backslash
gets 0$
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

    
\backslash
For{$s
\backslash
in V$}{
\end_layout

\begin_layout Plain Layout

        
\backslash
uIf{$k[s] = 0$}{
\end_layout

\begin_layout Plain Layout

            $
\backslash
text{DFS-VISIT}(s,k ,f ,
\backslash
pi,
 i)$
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    
\backslash
Return $
\backslash
left(k,
 f,
 
\backslash
pi,
 
\backslash
text{low}
\backslash
right)$
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout


\backslash
end{algorithm}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
begin{algorithm}
\end_layout

\begin_layout Plain Layout


\backslash
SetAlgoLined
\end_layout

\begin_layout Plain Layout


\backslash
SetKwFunction{name}{DFS-VISIT}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
SetKwProg{Fn}{function}{:}{}
\end_layout

\begin_layout Plain Layout


\backslash
Fn{
\backslash
name{$v,
 k,
 f,
 
\backslash
pi,
 
\backslash
text{color},
 
\backslash
text{low},
 i$}}{
\end_layout

\begin_layout Plain Layout

    $
\backslash
text{color}[u] 
\backslash
gets 
\backslash
text{Gray}$
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

    $i
\backslash
gets i + 1$
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

    $k[v]
\backslash
gets i$
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

    
\backslash
For{$w
\backslash
in Adj(v)$}{
\end_layout

\begin_layout Plain Layout

        
\backslash
uIf{$(
\backslash
text{color}[v] = 
\backslash
text{Gray})
\backslash
land(v
\backslash
ne
\backslash
pi[u])$}{
\end_layout

\begin_layout Plain Layout

            $
\backslash
text{low} 
\backslash
gets 
\backslash
min(
\backslash
text{low}[u],
 k[v])$
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

        } 
\backslash
uElseIf{$
\backslash
text{color}[v] = 
\backslash
text{White}$}{
\end_layout

\begin_layout Plain Layout

            $
\backslash
pi[w]
\backslash
gets v$
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

            
\backslash
name{$w,
 k,
 f,
 
\backslash
pi,
 
\backslash
text{color},
 
\backslash
text{low},
 i$}
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

            $
\backslash
text{low} 
\backslash
gets 
\backslash
min(
\backslash
text{low}[u],
 
\backslash
text{low}[v])$
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    $
\backslash
text{color}[u] 
\backslash
gets 
\backslash
text{Black}$
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

    $i
\backslash
gets i +1$
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

    $f[v] 
\backslash
gets i$
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout


\backslash
end{algorithm}
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\series bold
זמן נסיגה
\series default
:
 יהי 
\begin_inset Formula $G$
\end_inset

 גרף ויהי 
\begin_inset Formula $s\in V\left(G\right)$
\end_inset

 אזי 
\begin_inset Formula $f$
\end_inset

 בהרצת 
\begin_inset Formula $\text{DFS}\left(G\right)$
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
טענה 
\lang english

\begin_inset Formula $\text{Gray Path Lemma}$
\end_inset


\series default
\lang hebrew
:
 יהיו 
\begin_inset Formula $v,u\in V$
\end_inset

 אזי (
\begin_inset Formula $v$
\end_inset

 צאצא של 
\begin_inset Formula $u$
\end_inset

 ביער 
\begin_inset Formula $G_{\pi}$
\end_inset

)
\begin_inset Formula $\iff$
\end_inset

(
\begin_inset Formula $k\left[u\right]<k\left[v\right]<f\left[u\right]$
\end_inset

).
\end_layout

\begin_layout Standard

\series bold
טענה
\series default
:
 יהיו 
\begin_inset Formula $v,u\in V$
\end_inset

 אזי (
\begin_inset Formula $\left(u,v\right)$
\end_inset

 קשת חוצה)
\begin_inset Formula $\iff$
\end_inset

(
\begin_inset Formula $f\left[v\right]<k\left[u\right]$
\end_inset

).
\end_layout

\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Standard

\series bold
משפט הסוגריים
\series default
:
 יהי 
\begin_inset Formula $G$
\end_inset

 גרף ויהיו 
\begin_inset Formula $u,v\in V$
\end_inset

 אזי מתקיים בדיוק אחד מהבאים
\end_layout

\begin_layout Itemize
מתקיים 
\begin_inset Formula $\left[k\left(u\right),f\left(u\right)\right]\cap\left[k\left(v\right),f\left(v\right)\right]=\emptyset$
\end_inset

 וכן 
\begin_inset Formula $u,v$
\end_inset

 אינם צאצא־אב ביער 
\begin_inset Formula $G_{\pi}$
\end_inset

.
\end_layout

\begin_layout Itemize
מתקיים 
\begin_inset Formula $\left[k\left(u\right),f\left(u\right)\right]\subset\left[k\left(v\right),f\left(v\right)\right]$
\end_inset

 וכן 
\begin_inset Formula $u$
\end_inset

 צאצא של 
\begin_inset Formula $v$
\end_inset

 ביער 
\begin_inset Formula $G_{\pi}$
\end_inset

.
\end_layout

\begin_layout Itemize
מתקיים 
\begin_inset Formula $\left[k\left(u\right),f\left(u\right)\right]\supset\left[k\left(v\right),f\left(v\right)\right]$
\end_inset

 וכן 
\begin_inset Formula $v$
\end_inset

 צאצא של 
\begin_inset Formula $u$
\end_inset

 ביער 
\begin_inset Formula $G_{\pi}$
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
משפט המסלול הלבן
\series default
:
 יהי 
\begin_inset Formula $G$
\end_inset

 גרף ויהיו 
\begin_inset Formula $u,v\in V$
\end_inset

 אזי (
\begin_inset Formula $v$
\end_inset

 צאצא של 
\begin_inset Formula $u$
\end_inset

 ביער 
\begin_inset Formula $G_{\pi}$
\end_inset

)
\begin_inset Formula $\iff$
\end_inset

(בזמן 
\begin_inset Formula $k\left(u\right)$
\end_inset

 באלגוריתם 
\begin_inset Formula $\text{DFS}\left(G\right)$
\end_inset

 יש מסלול לבן מ־
\begin_inset Formula $u$
\end_inset

 ל־
\begin_inset Formula $v$
\end_inset

).
\end_layout

\begin_layout Standard

\series bold
גרף מכוון אציקל
\series default
י:
 גרף מכוון 
\begin_inset Formula $G$
\end_inset

 בו לא קיים מעגל.
\end_layout

\begin_layout Standard

\series bold
מיון טופולוגי
\series default
:
 יהי 
\begin_inset Formula $G$
\end_inset

 גרף מכוון אזי יחס סדר 
\begin_inset Formula $\prec$
\end_inset

 על 
\begin_inset Formula $V$
\end_inset

 המקיים לכל 
\begin_inset Formula $u,v\in V$
\end_inset

 אם 
\begin_inset Formula $\left(u,v\right)\in E$
\end_inset

 אזי 
\begin_inset Formula $u\prec v$
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
משפט
\series default
:
 יהי 
\begin_inset Formula $G$
\end_inset

 גרף מכוון אזי (
\begin_inset Formula $G$
\end_inset

 אציקלי)
\begin_inset Formula $\iff$
\end_inset

(קיים מיון טופולוגי על 
\begin_inset Formula $G$
\end_inset

).
\end_layout

\begin_layout Standard

\series bold
טענה אלגוריתם קנות'
\series default
:
 יהי 
\begin_inset Formula $G$
\end_inset

 גרף מכוון אזי קיים אלגוריתם לבדיקת קיום מיון טופולוגי בסיבוכיות זמן ריצה 
\begin_inset Formula $\O\left(\left|V\right|+\left|E\right|\right)$
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
משפט
\series default
:
 יהי 
\begin_inset Formula $G$
\end_inset

 גרף מכוון אזי (
\begin_inset Formula $G$
\end_inset

 אציקלי)
\begin_inset Formula $\iff$
\end_inset

(אין קשתות אחוריות ב־
\begin_inset Formula $G$
\end_inset

).
\end_layout

\begin_layout Standard

\series bold
טענה
\series default
:
 יהי 
\begin_inset Formula $G$
\end_inset

 גרף מכוון אציקלי אזי 
\begin_inset Formula $f$
\end_inset

 המתקבלת מהרצת 
\begin_inset Formula $\text{DFS}\left(G\right)$
\end_inset

 משרה מיון טופולוגי על 
\begin_inset Formula $G$
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
קודקוד מנתק
\series default
:
 יהי 
\begin_inset Formula $G$
\end_inset

 גרף מכוון אזי 
\begin_inset Formula $v\in V\left(G\right)$
\end_inset

 עבורו 
\begin_inset Formula $\left|\nicefrac{G}{\xrightarrow[G]{}}\right|<\left|\nicefrac{G-\left\{ v\right\} }{\xrightarrow[G-\left\{ v\right\} ]{}}\right|$
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
אב חורג
\series default
:
 יהי 
\begin_inset Formula $G$
\end_inset

 גרף מכוון ויהי 
\begin_inset Formula $v\in V$
\end_inset

 אזי 
\begin_inset Formula $w\in V$
\end_inset

 עבורו 
\begin_inset Formula $\left(w,v\right)$
\end_inset

 קשת אחורית.
\end_layout

\begin_layout Standard

\series bold
זמן גילוי האב החורג המוקדם ביותר
\series default
:
 יהי 
\begin_inset Formula $G$
\end_inset

 גרף אזי 
\begin_inset Formula $\text{low}$
\end_inset

 בהרצת 
\begin_inset Formula $\text{DFS}\left(G\right)$
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
אלגוריתם למציאת כל הקודקודים המנתקים
\series default
:
 יהי 
\begin_inset Formula $G$
\end_inset

 גרף מכוון וקשיר אזי
\end_layout

\begin_layout Standard

\lang english
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
begin{algorithm}
\end_layout

\begin_layout Plain Layout


\backslash
SetAlgoLined
\end_layout

\begin_layout Plain Layout


\backslash
SetKwFunction{name}{DetachableVertices}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
SetKwProg{Fn}{function}{:}{}
\end_layout

\begin_layout Plain Layout


\backslash
Fn{
\backslash
name{$G$}}{
\end_layout

\begin_layout Plain Layout

    $s 
\backslash
gets V$
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

    $
\backslash
left(k,
 f,
 
\backslash
pi,
 
\backslash
text{low}
\backslash
right)
\backslash
gets 
\backslash
text{DFS}(G,
 s)$
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

    $A 
\backslash
gets 
\backslash
text{set}(V)$
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

    
\backslash
uIf{$|Adj_{G_
\backslash
pi}(s)| 
\backslash
ne 1$}{
\end_layout

\begin_layout Plain Layout

        $A.
\backslash
text{append}(s)$
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    
\backslash
For{$u
\backslash
in V
\backslash
backslash
\backslash
{s
\backslash
}$}{
\end_layout

\begin_layout Plain Layout

        
\backslash
uIf{$
\backslash
exists v
\backslash
in children(u).
 low[v] 
\backslash
ge k[u]$}{
\end_layout

\begin_layout Plain Layout

            $A.
\backslash
text{append}(u)$
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    
\backslash
Return $A$
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout


\backslash
end{algorithm}
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\series bold
טענה
\series default
:
 יהי 
\begin_inset Formula $G$
\end_inset

 גרף מכוון וקשיר אזי סיבוכיות זמן הריצה של 
\begin_inset Formula $\text{DetachableVertices}\left(G\right)$
\end_inset

 הינה 
\begin_inset Formula $\O\left(\left|V\right|+\left|E\right|\right)$
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
טענה
\series default
:
 יהי 
\begin_inset Formula $G$
\end_inset

 גרף מכוון וקשיר אזי 
\begin_inset Formula $\text{DetachableVertices}\left(G\right)$
\end_inset

 הינה קבוצת כל הקודקודים המנתקים.
\end_layout

\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Standard

\series bold
רכיב קשיר היטב (רק
\begin_inset Quotes erd
\end_inset

ה)
\series default
:
 יהי 
\begin_inset Formula $G$
\end_inset

 גרף מכוון אזי קבוצה 
\begin_inset Formula $C\subseteq V$
\end_inset

 מקסימלית בגודלה עבורה לכל 
\begin_inset Formula $u,v\in C$
\end_inset

 קיים מסלול מ־
\begin_inset Formula $u$
\end_inset

 ל־
\begin_inset Formula $v$
\end_inset

 וכן מ־
\begin_inset Formula $v$
\end_inset

 ל־
\begin_inset Formula $u$
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
גרף הופכי/משוחלף
\series default
:
 יהי 
\begin_inset Formula $G$
\end_inset

 גרף מכוון נגדיר 
\begin_inset Formula $E^{\prime}=\left\{ \left(v,u\right)\mid\left(u,v\right)\in E\right\} $
\end_inset

 אזי 
\begin_inset Formula $G^{T}=\left(V,E^{\prime}\right)$
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
טענה
\series default
:
 יהי 
\begin_inset Formula $G$
\end_inset

 גרף מכוון ותהא 
\begin_inset Formula $C\subseteq V$
\end_inset

 אזי (
\begin_inset Formula $C$
\end_inset

 רק
\begin_inset Quotes erd
\end_inset

ה של 
\begin_inset Formula $G$
\end_inset

)
\begin_inset Formula $\iff$
\end_inset

(
\begin_inset Formula $C$
\end_inset

 רק
\begin_inset Quotes erd
\end_inset

ה של 
\begin_inset Formula $G^{T}$
\end_inset

).
\end_layout

\begin_layout Standard

\series bold
אלגוריתם קוסראג'ו־שריר למציאת רכיבים קשירים היטב
\series default
:
 יהי 
\begin_inset Formula $G$
\end_inset

 גרף מכוון אזי
\end_layout

\begin_layout Standard

\lang english
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
begin{algorithm}
\end_layout

\begin_layout Plain Layout


\backslash
SetAlgoLined
\end_layout

\begin_layout Plain Layout


\backslash
SetKwFunction{name}{SCC}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
SetKwProg{Fn}{function}{:}{}
\end_layout

\begin_layout Plain Layout


\backslash
Fn{
\backslash
name{$G$}}{
\end_layout

\begin_layout Plain Layout

    $
\backslash
left(k,
 f,
 
\backslash
pi
\backslash
right)
\backslash
gets 
\backslash
text{DFS}(G)$
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

    
\backslash
tcc{In the next line,
 in the main loop of DFS we go through the vertices in decreasing order of f[u]}
\end_layout

\begin_layout Plain Layout

    $
\backslash
left(k^
\backslash
prime,
 f^
\backslash
prime,
 
\backslash
pi^
\backslash
prime
\backslash
right)
\backslash
gets 
\backslash
text{DFS}(G^T)$
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

    $A 
\backslash
gets 
\backslash
text{set}(
\backslash
text{set}(V))$
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

    
\backslash
For{$v
\backslash
in V$}{
\end_layout

\begin_layout Plain Layout

        $A .
\backslash
text{append}
\backslash
left([v]_{
\backslash
xrightarrow[G^T_{
\backslash
pi}]{}}
\backslash
right)$
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    
\backslash
Return $A$
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout


\backslash
end{algorithm}
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\series bold
גרף הרכיבים
\series default
:
 יהי 
\begin_inset Formula $G$
\end_inset

 גרף מכוון נגדיר 
\begin_inset Formula $E^{*}=\left\{ \left(A,B\right)\in\text{SCC}\left(G\right)^{2}\mid\exists u\in A.\exists v\in B.\left(u,v\right)\in E\right\} $
\end_inset

 אזי 
\begin_inset Formula $G^{*}=\left(\text{SCC}\left(G\right),E^{*}\right)$
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
אלגוריתם למציאת גרף הרכיבים
\series default
:
 יהי 
\begin_inset Formula $G$
\end_inset

 גרף מכוון אזי
\end_layout

\begin_layout Standard

\lang english
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
begin{algorithm}
\end_layout

\begin_layout Plain Layout


\backslash
SetAlgoLined
\end_layout

\begin_layout Plain Layout


\backslash
SetKwFunction{name}{KosarajuSharir}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
SetKwProg{Fn}{function}{:}{}
\end_layout

\begin_layout Plain Layout


\backslash
Fn{
\backslash
name{$G$}}{
\end_layout

\begin_layout Plain Layout

    $V^* 
\backslash
gets 
\backslash
text{SCC}(G)$
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

    $E^* 
\backslash
gets 
\backslash
text{set}((V^*)^2)$
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

    
\backslash
For{$(u,v)
\backslash
in E$}{
\end_layout

\begin_layout Plain Layout

        
\backslash
If{$[v]_{
\backslash
xrightarrow[G^T_{
\backslash
pi}]{}} 
\backslash
ne [u]_{
\backslash
xrightarrow[G^T_{
\backslash
pi}]{}}$}{
\end_layout

\begin_layout Plain Layout

            $E^* .
 
\backslash
text{append}
\backslash
left(
\backslash
left([v]_{
\backslash
xrightarrow[G^T_{
\backslash
pi}]{}},
 [u]_{
\backslash
xrightarrow[G^T_{
\backslash
pi}]{}}
\backslash
right)
\backslash
right)$
\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    
\backslash
Return $(V^* ,
 E^*)$
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout


\backslash
end{algorithm}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Standard

\series bold
למה
\series default
:
 יהי 
\begin_inset Formula $G$
\end_inset

 גרף מכוון אזי 
\begin_inset Formula $G^{*}$
\end_inset

 אציקלי.
\end_layout

\begin_layout Standard

\series bold
הגדרה
\series default
:
 יהי 
\begin_inset Formula $G$
\end_inset

 גרף ותהא 
\begin_inset Formula $U\subseteq V$
\end_inset

 אזי
\end_layout

\begin_layout Itemize
זמן גילוי:
 
\begin_inset Formula $k\left(U\right)=\min_{u\in U}\left(k\left[u\right]\right)$
\end_inset

.
\end_layout

\begin_layout Itemize
זמן נסיגה:
 
\begin_inset Formula $f\left(U\right)=\max_{u\in U}\left(f\left[u\right]\right)$
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
למה
\series default
:
 יהי 
\begin_inset Formula $G$
\end_inset

 גרף מכוון יהיו 
\begin_inset Formula $C_{1},C_{2}\subseteq V$
\end_inset

 רק
\begin_inset Quotes erd
\end_inset

ה באשר 
\begin_inset Formula $\left(C_{1},C_{2}\right)\in E\left(G^{*}\right)$
\end_inset

 אזי 
\begin_inset Formula $f\left(C_{2}\right)<f\left(C_{1}\right)$
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
מסקנה
\series default
:
 יהי 
\begin_inset Formula $G$
\end_inset

 גרף מכוון יהיו 
\begin_inset Formula $C_{1},C_{2}\subseteq V$
\end_inset

 רק
\begin_inset Quotes erd
\end_inset

ה באשר 
\begin_inset Formula $\left(C_{1},C_{2}\right)\in E\left(\left(G^{T}\right)^{*}\right)$
\end_inset

 אזי 
\begin_inset Formula $f\left(C_{2}\right)>f\left(C_{1}\right)$
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
משפט
\series default
:
 יהי 
\begin_inset Formula $G$
\end_inset

 גרף מכוון ויהי 
\begin_inset Formula $C\subseteq V$
\end_inset

 אזי (
\begin_inset Formula $C$
\end_inset

 רק
\begin_inset Quotes erd
\end_inset

ה)
\begin_inset Formula $\iff$
\end_inset

(
\begin_inset Formula $C\in\text{SCC}\left(G\right)$
\end_inset

).
\end_layout

\begin_layout Standard

\series bold
מסקנה
\series default
:
 יהי 
\begin_inset Formula $G$
\end_inset

 גרף מכוון אזי 
\begin_inset Formula $G^{*}=\text{KosarajuSharir}\left(G\right)$
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
קבוצת מוצא
\series default
:
 יהי 
\begin_inset Formula $G$
\end_inset

 גרף מכוון אזי 
\begin_inset Formula $S\subseteq V$
\end_inset

 המקיימת 
\begin_inset Formula $\forall v\in V.\exists s\in S.s\to v$
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
אלגוריתם למציאת קבוצת מוצא מינימלית
\series default
:
 יהי 
\begin_inset Formula $G$
\end_inset

 גרף מכוון אזי
\end_layout

\begin_layout Standard

\lang english
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
begin{algorithm}
\end_layout

\begin_layout Plain Layout


\backslash
SetAlgoLined
\end_layout

\begin_layout Plain Layout


\backslash
SetKwFunction{name}{MinimalOriginSet}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
SetKwProg{Fn}{function}{:}{}
\end_layout

\begin_layout Plain Layout


\backslash
Fn{
\backslash
name{$G$}}{
\end_layout

\begin_layout Plain Layout

    $A 
\backslash
gets 
\backslash
text{set}(V(G))$
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

    $G^* 
\backslash
gets 
\backslash
text{ComponentGraph}(G)$
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

    
\backslash
For{$C
\backslash
in V(G^*)$}{
\end_layout

\begin_layout Plain Layout

        $v
\backslash
gets 
\backslash
{u
\backslash
in C
\backslash
mid 
\backslash
nexists w
\backslash
in V(G)
\backslash
backslash C.
 (w,
 u)
\backslash
in E(G)
\backslash
}$
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

        $A.
\backslash
text{append}(v)$
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    
\backslash
Return $A$
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout


\backslash
end{algorithm}
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\series bold
טענה
\series default
:
 יהי 
\begin_inset Formula $G$
\end_inset

 גרף מכוון אזי 
\begin_inset Formula $\text{MinimalOriginSet}\left(G\right)$
\end_inset

 קבוצת מוצא מינימלית.
\end_layout

\begin_layout Standard

\series bold
טענה
\series default
:
 יהי 
\begin_inset Formula $G$
\end_inset

 גרף מכוון וקשיר אזי סיבוכיות זמן הריצה של 
\begin_inset Formula $\text{MinimalOriginSet}\left(G\right)$
\end_inset

 הינה 
\begin_inset Formula $\O\left(\left|V\right|+\left|E\right|\right)$
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
טענה
\series default
:
 יהי 
\begin_inset Formula $G$
\end_inset

 גרף מכוון ותהא 
\begin_inset Formula $S\subseteq V$
\end_inset

 אזי קיים אלגוריתם הבודק האם קיים הילוך 
\begin_inset Formula $\sigma$
\end_inset

 העובר על 
\begin_inset Formula $S$
\end_inset

 בסיבוכיות זמן ריצה 
\begin_inset Formula $\O\left(\left|V\right|+\left|E\right|\right)$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Standard

\series bold
גרף ממושקל
\series default
:
 יהי 
\begin_inset Formula $G$
\end_inset

 גרף ותהא 
\begin_inset Formula $w:E\to\bbr$
\end_inset

 אזי 
\begin_inset Formula $\left(G,w\right)$
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
עץ פורש
\series default
:
 יהי 
\begin_inset Formula $G$
\end_inset

 גרף קשיר לא מכוון אזי תת־גרף 
\begin_inset Formula $T\le G$
\end_inset

 באשר 
\begin_inset Formula $T$
\end_inset

 עץ וכן 
\begin_inset Formula $V\left(T\right)=V\left(G\right)$
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
משקל עץ פורש
\series default
:
 יהי 
\begin_inset Formula $G$
\end_inset

 גרף קשיר לא מכוון ויהי 
\begin_inset Formula $T\le G$
\end_inset

 עץ פורש אזי 
\begin_inset Formula $w\left(T\right)=\sum_{e\in E\left(T\right)}w\left(e\right)$
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
עץ פורש מינימלי (עפ
\begin_inset Quotes erd
\end_inset

מ)
\series default
:
 יהי 
\begin_inset Formula $G$
\end_inset

 גרף קשיר לא מכוון אזי עץ פורש 
\begin_inset Formula $T\le G$
\end_inset

 עבורו 
\begin_inset Formula $w\left(T\right)=\min\left\{ w\left(S\right)\mid G\text{ עץ פורש של }S\right\} $
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
חתך
\series default
:
 יהי 
\begin_inset Formula $G$
\end_inset

 גרף אזי 
\begin_inset Formula $A,B\subseteq V\left(G\right)$
\end_inset

 עבורם 
\begin_inset Formula $A\uplus B=V\left(G\right)$
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
קשתות החתך/חוצות
\series default
:
 יהי 
\begin_inset Formula $G$
\end_inset

 גרף ויהי 
\begin_inset Formula $A,B\subseteq V\left(G\right)$
\end_inset

 חתך אזי 
\begin_inset Formula $\left\{ \left(u,v\right)\in E\left(G\right)\mid\left(u\in A\right)\land\left(v\in B\right)\right\} $
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
טענה
\series default
:
 יהי 
\begin_inset Formula $T\le G$
\end_inset

 עץ פורש ותהא 
\begin_inset Formula $e\in E\left(G\right)\backslash E\left(T\right)$
\end_inset

 אזי 
\begin_inset Formula $T+\left\{ e\right\} $
\end_inset

 בעל מעגל יחיד.
\end_layout

\begin_layout Standard

\series bold
טענה
\series default
:
 יהי 
\begin_inset Formula $T\le G$
\end_inset

 עץ פורש תהא 
\begin_inset Formula $e_{1}\in E\left(G\right)\backslash E\left(T\right)$
\end_inset

 ותהא 
\begin_inset Formula $e_{2}\in E\left(T+\left\{ e_{1}\right\} \right)$
\end_inset

 אשר הינה חלק ממעגל אזי 
\begin_inset Formula $T+\left\{ e_{1}\right\} -\left\{ e_{2}\right\} $
\end_inset

 עץ פורש.
\end_layout

\begin_layout Standard

\series bold
טענה
\series default
:
 יהי 
\begin_inset Formula $T\le G$
\end_inset

 עץ פורש ותהא 
\begin_inset Formula $e\in E\left(T\right)$
\end_inset

 אזי 
\begin_inset Formula $T-\left\{ e\right\} $
\end_inset

 הינו יער בעל שני עצים.
\end_layout

\begin_layout Standard

\series bold
מסקנה
\series default
:
 יהי 
\begin_inset Formula $T\le G$
\end_inset

 עץ פורש תהא 
\begin_inset Formula $e\in E\left(T\right)$
\end_inset

 ויהי 
\begin_inset Formula $v\in V\left(G\right)$
\end_inset

 אזי 
\begin_inset Formula $\left[v\right]_{\xrightarrow[T-\left\{ e\right\} ]{}},V\left(G\right)\backslash\left[v\right]_{\xrightarrow[T-\left\{ e\right\} ]{}}$
\end_inset

 חתך של 
\begin_inset Formula $G$
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
אלגוריתם גנרי למציאת עץ פורש מינימלי
\series default
:
 יהי 
\begin_inset Formula $G$
\end_inset

 גרף קשיר לא מכוון וממושקל 
\begin_inset Formula $w$
\end_inset

 אזי
\end_layout

\begin_layout Standard

\lang english
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
begin{algorithm}
\end_layout

\begin_layout Plain Layout


\backslash
SetAlgoLined
\end_layout

\begin_layout Plain Layout


\backslash
SetKwFunction{name}{MST}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
SetKwProg{Fn}{function}{:}{}
\end_layout

\begin_layout Plain Layout


\backslash
Fn{
\backslash
name{$G,
 w$}}{
\end_layout

\begin_layout Plain Layout

    $
\backslash
text{color}
\backslash
gets$ dict($E$)
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

    
\backslash
For{$e
\backslash
in E$}{
\end_layout

\begin_layout Plain Layout

        $
\backslash
text{color}[e] = 
\backslash
text{White}$
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    
\backslash
While{$
\backslash
exists e
\backslash
in E.
 color[e] = White$}{
\end_layout

\begin_layout Plain Layout

        $
\backslash
text{Blueless} 
\backslash
gets 
\backslash
{A
\backslash
subseteq V
\backslash
mid 
\backslash
forall e
\backslash
in (A^2 
\backslash
cap E).
 
\backslash
text{color}[e] 
\backslash
ne 
\backslash
text{Blue}
\backslash
}$
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

        $
\backslash
text{Redless} 
\backslash
gets 
\backslash
{
\backslash
sigma 
\backslash
text{ circle in G}
\backslash
mid
\backslash
forall i
\backslash
in [
\backslash
text{len}(
\backslash
sigma)].
 
\backslash
text{color}[(
\backslash
sigma[i],
 
\backslash
sigma[i + 1])] 
\backslash
ne 
\backslash
text{Red}
\backslash
}$
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

        
\backslash
uIf{$Blueless 
\backslash
ne 
\backslash
emptyset$}{
\end_layout

\begin_layout Plain Layout

            $A 
\backslash
gets 
\backslash
text{Blueless}$
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

            $f
\backslash
gets 
\backslash
text{argmin}_{e
\backslash
in A^2
\backslash
cap E}(w(e))$
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

            $
\backslash
text{color}[f] = 
\backslash
text{Blue}$
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

        
\backslash
uIf{$
\backslash
text{Redless} 
\backslash
ne 
\backslash
emptyset$}{
\end_layout

\begin_layout Plain Layout

            $
\backslash
sigma
\backslash
gets 
\backslash
text{Redless}$
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

            $f
\backslash
gets 
\backslash
text{argmax}_{e
\backslash
in 
\backslash
sigma}(w(e))$
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

            $
\backslash
text{color}[f] = 
\backslash
text{Red}$
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    
\backslash
Return $(V,
 
\backslash
{e
\backslash
in E
\backslash
mid 
\backslash
text{color}[e] = 
\backslash
text{Blue}
\backslash
})$
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout


\backslash
end{algorithm}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Standard

\series bold
טענה
\series default
:
 יהי 
\begin_inset Formula $G$
\end_inset

 גרף קשיר לא מכוון וממושקל 
\begin_inset Formula $w$
\end_inset

 ותהא 
\begin_inset Formula $a\in E$
\end_inset

 עבורה 
\begin_inset Formula $\text{color}\left[a\right]=\text{White}$
\end_inset

 באיטרציה של 
\begin_inset Formula $\text{MST}\left(G\right)$
\end_inset

 אזי קיימת 
\begin_inset Formula $e\in E$
\end_inset

 אשר ניתנת לצביעה.
\end_layout

\begin_layout Standard

\series bold
מסקנה
\series default
:
 יהי 
\begin_inset Formula $G$
\end_inset

 גרף קשיר לא מכוון וממושקל 
\begin_inset Formula $w$
\end_inset

 אזי 
\begin_inset Formula $\text{MST}\left(G\right)$
\end_inset

 צובעת 
\begin_inset Formula $\left|E\right|$
\end_inset

 קשתות.
\end_layout

\begin_layout Standard

\series bold
טענה
\series default
:
 יהי 
\begin_inset Formula $G$
\end_inset

 גרף קשיר לא מכוון וממושקל 
\begin_inset Formula $w$
\end_inset

 אזי בכל איטרציה של 
\begin_inset Formula $\text{MST}\left(G\right)$
\end_inset

 קיים 
\begin_inset Formula $T\le G$
\end_inset

 עפ
\begin_inset Quotes erd
\end_inset

מ עבורו
\end_layout

\begin_layout Itemize
לכל 
\begin_inset Formula $e\in E$
\end_inset

 המקיימת 
\begin_inset Formula $\text{color}\left[e\right]=\text{Blue}$
\end_inset

 מתקיים 
\begin_inset Formula $e\in E\left(T\right)$
\end_inset

.
\end_layout

\begin_layout Itemize
לכל 
\begin_inset Formula $e\in E$
\end_inset

 המקיימת 
\begin_inset Formula $\text{color}\left[e\right]=\text{Red}$
\end_inset

 מתקיים 
\begin_inset Formula $e\notin E\left(T\right)$
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
מסקנה
\series default
:
 יהי 
\begin_inset Formula $G$
\end_inset

 גרף קשיר לא מכוון וממושקל 
\begin_inset Formula $w$
\end_inset

 אזי 
\begin_inset Formula $\text{MST}\left(G\right)$
\end_inset

 עפ
\begin_inset Quotes erd
\end_inset

מ של 
\begin_inset Formula $G$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Standard

\series bold
אלגוריתם פרים למציאת עץ פורש מינימלי
\series default
:
 יהי 
\begin_inset Formula $G$
\end_inset

 גרף קשיר לא מכוון וממושקל 
\begin_inset Formula $w$
\end_inset

 אזי
\end_layout

\begin_layout Standard

\lang english
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
begin{algorithm}
\end_layout

\begin_layout Plain Layout


\backslash
SetAlgoLined
\end_layout

\begin_layout Plain Layout


\backslash
SetKwFunction{name}{Prim'sAlgorithm}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
SetKwProg{Fn}{function}{:}{}
\end_layout

\begin_layout Plain Layout


\backslash
Fn{
\backslash
name{$G$}}{
\end_layout

\begin_layout Plain Layout

    $
\backslash
text{color}
\backslash
gets 
\backslash
text{dict}(E)$
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

    $U 
\backslash
gets 
\backslash
text{set}(V)$
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

    
\backslash
For{$e
\backslash
in E$}{
\end_layout

\begin_layout Plain Layout

        $
\backslash
text{color}[e] = 
\backslash
text{White}$
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    $r 
\backslash
gets V$
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

    $U.
\backslash
text{append}(r)$
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

    
\backslash
While{$U
\backslash
ne V$}{
\end_layout

\begin_layout Plain Layout

        $(u,
 v) 
\backslash
gets 
\backslash
text{argmin}_{e
\backslash
in U
\backslash
times(V
\backslash
backslash U)}(w(e))$
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

        $
\backslash
text{color}[(u,
 v)] = 
\backslash
text{Blue}$
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

        $U.
\backslash
text{append}(v)$
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

        
\backslash
For{$w
\backslash
in U$}{
\end_layout

\begin_layout Plain Layout

            
\backslash
uIf{$(w,
 v)
\backslash
in E$}{
\end_layout

\begin_layout Plain Layout

                $
\backslash
text{color}[(w,
 v)] = 
\backslash
text{Red}$
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

            }
\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    
\backslash
Return $(V,
 
\backslash
{e
\backslash
in E
\backslash
mid 
\backslash
text{color}[e] = 
\backslash
text{Blue}
\backslash
})$
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout


\backslash
end{algorithm}
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\series bold
טענה
\series default
:
 יהי 
\begin_inset Formula $G$
\end_inset

 גרף קשיר לא מכוון וממושקל 
\begin_inset Formula $w$
\end_inset

 אזי כל צביעת קשת באלגוריתם 
\begin_inset Formula $\text{Prim'sAlgorithm}\left(G\right)$
\end_inset

 נעשית כמו באלגוריתם הגנרי.
\end_layout

\begin_layout Standard

\series bold
מסקנה
\series default
:
 יהי 
\begin_inset Formula $G$
\end_inset

 גרף קשיר לא מכוון וממושקל 
\begin_inset Formula $w$
\end_inset

 אזי 
\begin_inset Formula $\text{Prim'sAlgorithm}\left(G\right)$
\end_inset

 עפ
\begin_inset Quotes erd
\end_inset

מ של 
\begin_inset Formula $G$
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
משפט
\series default
:
 יהי 
\begin_inset Formula $G$
\end_inset

 גרף קשיר לא מכוון וממושקל 
\begin_inset Formula $w$
\end_inset

 אזי ניתן לממש את 
\begin_inset Formula $\text{Prim'sAlgorithm}\left(G\right)$
\end_inset

 עם ערימת מינימום בסיבוכיות זמן ריצה 
\begin_inset Formula $\O\left(\left|E\right|\log\left|V\right|\right)$
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
הערה
\series default
:
 יהי 
\begin_inset Formula $G$
\end_inset

 גרף קשיר לא מכוון וממושקל 
\begin_inset Formula $w$
\end_inset

 אזי ניתן לממש את 
\begin_inset Formula $\text{Prim'sAlgorithm}\left(G\right)$
\end_inset

 בסיבוכיות זמן ריצה 
\begin_inset Formula $\O\left(\left|E\right|+\left|V\right|\log\left|V\right|\right)$
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
אלגוריתם קרוסקל למציאת עץ פורש מינימלי
\series default
:
 יהי 
\begin_inset Formula $G$
\end_inset

 גרף קשיר לא מכוון וממושקל 
\begin_inset Formula $w$
\end_inset

 אזי
\end_layout

\begin_layout Standard

\lang english
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
begin{algorithm}
\end_layout

\begin_layout Plain Layout


\backslash
SetAlgoLined
\end_layout

\begin_layout Plain Layout


\backslash
SetKwFunction{name}{Kruskal'sAlgorithm}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
SetKwProg{Fn}{function}{:}{}
\end_layout

\begin_layout Plain Layout


\backslash
Fn{
\backslash
name{$G$}}{
\end_layout

\begin_layout Plain Layout

    $
\backslash
text{color}
\backslash
gets 
\backslash
text{dict}(E)$
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

    $L 
\backslash
gets 
\backslash
text{sort}(E)$
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

    
\backslash
For{$(u,
 v)
\backslash
in L$}{
\end_layout

\begin_layout Plain Layout

        
\backslash
uIf{$
\backslash
exists
\backslash
sigma 
\backslash
in 
\backslash
{u
\backslash
to v
\backslash
}.
 
\backslash
forall i
\backslash
in[n].
 
\backslash
text{color}(
\backslash
sigma(i)) = 
\backslash
text{Blue}$}{
\end_layout

\begin_layout Plain Layout

            $
\backslash
text{color}[e] = 
\backslash
text{Red}$
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

        } 
\backslash
uElse{
\end_layout

\begin_layout Plain Layout

            $
\backslash
text{color}[e] = 
\backslash
text{Blue}$
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    
\backslash
Return $(V,
 
\backslash
{e
\backslash
in E
\backslash
mid 
\backslash
text{color}[e] = 
\backslash
text{Blue}
\backslash
})$
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout


\backslash
end{algorithm}
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\series bold
טענה
\series default
:
 יהי 
\begin_inset Formula $G$
\end_inset

 גרף קשיר לא מכוון וממושקל 
\begin_inset Formula $w$
\end_inset

 אזי כל צביעת קשת באלגוריתם 
\begin_inset Formula $\text{Kruskal'sAlgorithm}\left(G\right)$
\end_inset

 נעשית כמו באלגוריתם הגנרי.
\end_layout

\begin_layout Standard

\series bold
מסקנה
\series default
:
 יהי 
\begin_inset Formula $G$
\end_inset

 גרף קשיר לא מכוון וממושקל 
\begin_inset Formula $w$
\end_inset

 אזי 
\begin_inset Formula $\text{Kruskal'sAlgorithm}\left(G\right)$
\end_inset

 עפ
\begin_inset Quotes erd
\end_inset

מ של 
\begin_inset Formula $G$
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
משפט
\series default
:
 יהי 
\begin_inset Formula $G$
\end_inset

 גרף קשיר לא מכוון וממושקל 
\begin_inset Formula $w$
\end_inset

 אזי ניתן לממש את 
\begin_inset Formula $\text{Kruskal'sAlgorithm}\left(G\right)$
\end_inset

 עם 
\begin_inset Formula $\text{Union-Find}$
\end_inset

 בסיבוכיות זמן ריצה 
\begin_inset Formula $\O\left(\left|E\right|\log\left|V\right|\right)$
\end_inset

 וכן סיבוכיות זמן 
\begin_inset Formula $\text{amortized}$
\end_inset

 
\begin_inset Formula $\O\left(\left|E\right|\cdot\a\left(\left|V\right|\right)\right)$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset FormulaMacro
\newcommand{\bor}{\text{\textsf{Borůvska}}}
{\text{\textsf{Borůvska}}}
\end_inset


\begin_inset FormulaMacro
\newcommand{\borAlg}{\text{\textsf{Borůvska'sAlgorithm}}}
{\text{\textsf{Borůvska'sAlgorithm}}}
\end_inset


\end_layout

\begin_layout Standard

\series bold
אלגוריתם 
\lang english

\begin_inset Formula $\bor$
\end_inset


\lang hebrew
 למציאת עץ פורש מינימלי
\series default
:
 יהי 
\begin_inset Formula $G$
\end_inset

 גרף קשיר לא מכוון וממושקל 
\begin_inset Formula $w$
\end_inset

 באשר 
\begin_inset Formula $w$
\end_inset

 חח
\begin_inset Quotes erd
\end_inset

ע אזי
\end_layout

\begin_layout Standard

\lang english
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
begin{algorithm}
\end_layout

\begin_layout Plain Layout


\backslash
SetAlgoLined
\end_layout

\begin_layout Plain Layout


\backslash
SetKwFunction{name}{
\backslash
borAlg}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
SetKwProg{Fn}{function}{:}{}
\end_layout

\begin_layout Plain Layout


\backslash
Fn{
\backslash
name{$G$}}{
\end_layout

\begin_layout Plain Layout

    $
\backslash
text{Trees} 
\backslash
gets 
\backslash
text{set}(
\backslash
text{set}(G))$
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

    
\backslash
For{$v
\backslash
in V$}{
\end_layout

\begin_layout Plain Layout

        $
\backslash
text{Trees}.
\backslash
text{append}(
\backslash
{v
\backslash
})$
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    
\backslash
While{$|Trees| 
\backslash
ne 1$}{
\end_layout

\begin_layout Plain Layout

        
\backslash
For{$T 
\backslash
in Tree$}{
\end_layout

\begin_layout Plain Layout

            $(u,
 v) 
\backslash
gets 
\backslash
text{argmin}_{(u,
 v)
\backslash
in V(T)
\backslash
times V(G)}(w((u,
 v)))$
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

            $S 
\backslash
gets 
\backslash
{S
\backslash
in Tree
\backslash
mid u
\backslash
in V(S)
\backslash
}$
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

            $S 
\backslash
gets S + T + 
\backslash
{(u,
 v)
\backslash
}$
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

            $
\backslash
text{Trees}.
\backslash
text{Remove}(T)$
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    $A 
\backslash
gets 
\backslash
text{Trees}$
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

    
\backslash
Return A
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout


\backslash
end{algorithm}
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\series bold
טענה
\series default
:
 יהי 
\begin_inset Formula $G$
\end_inset

 גרף קשיר לא מכוון וממושקל 
\begin_inset Formula $w$
\end_inset

 באשר 
\begin_inset Formula $w$
\end_inset

 חח
\begin_inset Quotes erd
\end_inset

ע אזי סיבוכיות זמן ריצה 
\lang english

\begin_inset Formula $\borAlg\left(G\right)$
\end_inset


\lang hebrew
 הינה 
\begin_inset Formula $\O\left(\left|E\right|\log\left|V\right|\right)$
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
משפט
\series default
:
 יהי 
\begin_inset Formula $G$
\end_inset

 גרף קשיר לא מכוון וממושקל 
\begin_inset Formula $w$
\end_inset

 באשר 
\begin_inset Formula $w$
\end_inset

 חח
\begin_inset Quotes erd
\end_inset

ע אזי קיים ויחיד 
\begin_inset Formula $T\le G$
\end_inset

 עפ
\begin_inset Quotes erd
\end_inset

מ.
\end_layout

\begin_layout Standard

\series bold
משפט
\series default
:
 יהי 
\begin_inset Formula $G$
\end_inset

 גרף קשיר לא מכוון וממושקל 
\begin_inset Formula $w$
\end_inset

 באשר 
\begin_inset Formula $w$
\end_inset

 חח
\begin_inset Quotes erd
\end_inset

ע אזי 
\lang english

\begin_inset Formula $\borAlg\left(G\right)$
\end_inset


\lang hebrew
 עפ
\begin_inset Quotes erd
\end_inset

מ של 
\begin_inset Formula $G$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Standard

\series bold
משפט
\series default
:
 יהי 
\begin_inset Formula $G$
\end_inset

 גרף קשיר לא מכוון וממושקל 
\begin_inset Formula $w$
\end_inset

 תהא 
\begin_inset Formula $A\subseteq E$
\end_inset

 יהי 
\begin_inset Formula $C$
\end_inset

 מעגל ותהא 
\begin_inset Formula $e\in E$
\end_inset

 בעלת משקל מקסימלי אזי קיים עפ
\begin_inset Quotes erd
\end_inset

מ 
\begin_inset Formula $T\le G$
\end_inset

 עבורו 
\begin_inset Formula $A\subseteq E\left(T\right)$
\end_inset

 וכן 
\begin_inset Formula $e\notin E\left(T\right)$
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
טענה
\series default
:
 יהיו 
\begin_inset Formula $T_{1},T_{2}\le G$
\end_inset

 עפ
\begin_inset Quotes erd
\end_inset

מ ויהיו 
\begin_inset Formula $\a_{1}\le\ldots\le\a_{n}$
\end_inset

 ו־
\begin_inset Formula $\b_{1}\le\ldots\le\b_{m}$
\end_inset

 משקליי הקשתות כולל כפילויות אזי 
\begin_inset Formula $n=m$
\end_inset

 וכן 
\begin_inset Formula $\a_{i}=\b_{i}$
\end_inset

 לכל 
\begin_inset Formula $i\in\left[n\right]$
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
אלגוריתם למציאת עץ פורש מינימלי המכיל מספר מקסימלי של קשתות מקבוצה מסוימת
\series default
:
 יהי 
\begin_inset Formula $G$
\end_inset

 גרף קשיר לא מכוון וממושקל 
\begin_inset Formula $w$
\end_inset

 ותהא 
\begin_inset Formula $F\subseteq E$
\end_inset

 אזי
\end_layout

\begin_layout Standard

\lang english
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
begin{algorithm}
\end_layout

\begin_layout Plain Layout


\backslash
SetAlgoLined
\end_layout

\begin_layout Plain Layout


\backslash
SetKwFunction{name}{PrioritizeMST}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
SetKwProg{Fn}{function}{:}{}
\end_layout

\begin_layout Plain Layout


\backslash
Fn{
\backslash
name{$G,
 w,
 F$}}{
\end_layout

\begin_layout Plain Layout

    $
\backslash
omega 
\backslash
gets (V(G) 
\backslash
to 
\backslash
mathbb{R})$
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

    $m 
\backslash
gets 
\backslash
min(
\backslash
{|w(e_1) - w(e_2)| 
\backslash
mid (e_1,e_2
\backslash
in E)
\backslash
land(w(e_1)
\backslash
ne w(e_2))
\backslash
}$
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

    $
\backslash
varepsilon 
\backslash
gets 
\backslash
frac{m}{2}$
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

    
\backslash
For{$e
\backslash
in E$}{
\end_layout

\begin_layout Plain Layout

        
\backslash
uIf{$e
\backslash
in F$}{
\end_layout

\begin_layout Plain Layout

             $
\backslash
omega(e) 
\backslash
gets w(e)$
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

        } 
\backslash
uElse {
\end_layout

\begin_layout Plain Layout

            $
\backslash
omega(e) 
\backslash
gets w(e) + 
\backslash
varepsilon$
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    
\backslash
Return $
\backslash
text{Kruskal'sAlgorithm}(G,
 
\backslash
omega)$
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout


\backslash
end{algorithm}
\end_layout

\end_inset


\lang hebrew

\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Standard

\series bold
טענה
\series default
:
 תהא 
\begin_inset Formula $F\subseteq E$
\end_inset

 ויהי 
\begin_inset Formula $T$
\end_inset

 עפ
\begin_inset Quotes erd
\end_inset

מ ביחס ל־
\begin_inset Formula $w^{\prime}$
\end_inset

 באלגוריתם 
\begin_inset Formula $\text{PrioritizeMST}$
\end_inset

 אזי 
\begin_inset Formula $T$
\end_inset

 עפ
\begin_inset Quotes erd
\end_inset

מ ביחס ל־
\begin_inset Formula $w$
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
מסקנה
\series default
:
 תהא 
\begin_inset Formula $F\subseteq E$
\end_inset

 אזי 
\begin_inset Formula $\text{PrioritizeMST}\left(G,w\right)$
\end_inset

 עפ
\begin_inset Quotes erd
\end_inset

מ ב־
\begin_inset Formula $G$
\end_inset

 ביחס ל־
\begin_inset Formula $w$
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
בעיית שיבוץ המשימות
\series default
:
 יהיו 
\begin_inset Formula $s_{1}\ldots s_{n},f_{1}\ldots f_{n}\in\bbr$
\end_inset

 באשר 
\begin_inset Formula $s_{i}<f_{i}$
\end_inset

 לכל 
\begin_inset Formula $i\in\left[n\right]$
\end_inset

 אזי
\begin_inset Newline newline
\end_inset


\begin_inset Formula $\max\left\{ \left|A\right|\bmid\left(A\subseteq\left\{ \left[s_{1},f_{i}\right]\right\} _{i=1}^{n}\right)\land\left(\forall I,J\in A.I\cap J=\emptyset\right)\right\} $
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
אלגוריתם חמדן לבעיית שיבוץ המשימות
\series default
:
 יהיו 
\begin_inset Formula $s_{1}\ldots s_{n},f_{1}\ldots f_{n}\in\bbr$
\end_inset

 באשר 
\begin_inset Formula $s_{i}<f_{i}$
\end_inset

 לכל 
\begin_inset Formula $i\in\left[n\right]$
\end_inset

 אזי
\end_layout

\begin_layout Standard

\lang english
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
begin{algorithm}
\end_layout

\begin_layout Plain Layout


\backslash
SetAlgoLined
\end_layout

\begin_layout Plain Layout


\backslash
SetKwFunction{name}{ActivitySelectionProblem}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
SetKwProg{Fn}{function}{:}{}
\end_layout

\begin_layout Plain Layout


\backslash
Fn{
\backslash
name{$s_1,
 
\backslash
ldots,
 s_n,
 f_1,
 
\backslash
ldots,
 f_n$}}{
\end_layout

\begin_layout Plain Layout

    $F 
\backslash
gets 
\backslash
text{list}([s_1,
 f_1],
 
\backslash
ldots,
 [s_n ,f_n])$
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

    
\backslash
tcc{In the next line,
 we put all the parameters in F and sort it based on $f_i$}
\end_layout

\begin_layout Plain Layout

    $F 
\backslash
gets 
\backslash
text{sort}(
\backslash
{f_1,
 
\backslash
ldots ,
 f_n
\backslash
})$
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

    $X 
\backslash
gets 
\backslash
text{list}([s_1,
 f_1],
 
\backslash
ldots,
 [s_n ,f_n])$
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

    $X 
\backslash
gets 
\backslash
emptyset$
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

    
\backslash
For{$k
\backslash
in [1,
\backslash
ldots,n]$}{
\end_layout

\begin_layout Plain Layout

        
\backslash
uIf{$X = 
\backslash
emptyset$}{
\end_layout

\begin_layout Plain Layout

            $X.
\backslash
text{append}(L[k])$
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

        } 
\backslash
uElseIf{$L[k]
\backslash
cap X.
\backslash
text{last} = 
\backslash
emptyset$}{
\end_layout

\begin_layout Plain Layout

            $X.
\backslash
text{append}(L[k])$
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    
\backslash
Return $X$
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout


\backslash
end{algorithm}
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\series bold
טענה
\series default
:
 יהיו 
\begin_inset Formula $s_{1}\ldots s_{n},f_{1}\ldots f_{n}\in\bbr$
\end_inset

 באשר 
\begin_inset Formula $s_{i}<f_{i}$
\end_inset

 אזי סיבוכיות זמן הריצה של 
\begin_inset Formula $\text{ActivitySelectionProblem}$
\end_inset

 הינה 
\begin_inset Formula $\O\left(n\log\left(n\right)\right)$
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
משפט
\series default
:
 לכל 
\begin_inset Formula $k\in\left[n\right]$
\end_inset

 באיטרציה ה־
\begin_inset Formula $k$
\end_inset

 בלולאה ב־
\begin_inset Formula $\text{ActivitySelectionProblem}$
\end_inset

 קיים פתרון לבעיה 
\begin_inset Formula $X^{*}$
\end_inset

 עבורו
\begin_inset Newline newline
\end_inset


\begin_inset Formula $\left(\left[s_{i},f_{i}\right]\in X^{*}\right)\iff\left(\left[s_{i},f_{i}\right]\in X\right)$
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
מסקנה
\series default
:
 יהיו 
\begin_inset Formula $s_{1}\ldots s_{n},f_{1}\ldots f_{n}\in\bbr$
\end_inset

 באשר 
\begin_inset Formula $s_{i}<f_{i}$
\end_inset

 אזי 
\begin_inset Formula $\text{ActivitySelectionProblem}$
\end_inset

 פתרון לבעיית שיבוץ המשימות.
\end_layout

\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Standard

\series bold
הערה
\series default
:
 כאשר משקל הגרף הוא 
\begin_inset Formula $\ell$
\end_inset

 הכוונה היא 
\begin_inset Quotes eld
\end_inset

אורך הקשת
\begin_inset Quotes erd
\end_inset

 ובכך אנו 
\begin_inset Quotes eld
\end_inset

מכלילים
\begin_inset Quotes erd
\end_inset

 גרף ללא משקל בתור גרף עבורו 
\begin_inset Formula $\ell=1$
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
מעגל שלילי
\series default
:
 יהי 
\begin_inset Formula $G$
\end_inset

 מעגל ממושקל 
\begin_inset Formula $\ell$
\end_inset

 אזי מעגל 
\begin_inset Formula $C$
\end_inset

 עבורו 
\begin_inset Formula $\ell\left(C\right)<0$
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
מסלול קצר ביותר בין קודקודים
\series default
:
 יהי 
\begin_inset Formula $G$
\end_inset

 גרף ממושקל 
\begin_inset Formula $\ell$
\end_inset

 ויהיו 
\begin_inset Formula $s,t\in V$
\end_inset

 אזי מסלול 
\begin_inset Formula $\sigma$
\end_inset

 מ־
\begin_inset Formula $s$
\end_inset

 ל־
\begin_inset Formula $t$
\end_inset

 עבורו 
\size small

\begin_inset Formula $\ell\left(\sigma\right)=\min\left\{ \ell\left(\tau\right)\mid\tau\in\left\{ s\to t\right\} \right\} $
\end_inset


\size default
.
\end_layout

\begin_layout Standard

\series bold
למה
\series default
:
 יהיו 
\begin_inset Formula $s,t\in V$
\end_inset

 עבורם קיים מסלול מ־
\begin_inset Formula $s$
\end_inset

 ל־
\begin_inset Formula $t$
\end_inset

 וכן כל מסלול מ־
\begin_inset Formula $s$
\end_inset

 ל־
\begin_inset Formula $t$
\end_inset

 לא עובר דרך קשת השייכת למעגל שלילי אזי קיים מסלול פשוט קצר ביותר בין 
\begin_inset Formula $s$
\end_inset

 ל־
\begin_inset Formula $t$
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
למה
\series default
:
 יהיו 
\begin_inset Formula $s,t\in V$
\end_inset

 עבורם קיים מסלול מ־
\begin_inset Formula $s$
\end_inset

 ל־
\begin_inset Formula $t$
\end_inset

 וכן קיים מסלול מ־
\begin_inset Formula $s$
\end_inset

 ל־
\begin_inset Formula $t$
\end_inset

 העובר דרך קשת השייכת למעגל שלילי אזי לא קיים מסלול פשוט קצר ביותר בין 
\begin_inset Formula $s$
\end_inset

 ל־
\begin_inset Formula $t$
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
סימון
\series default
:
 יהי 
\begin_inset Formula $G$
\end_inset

 גרף ממושקל 
\begin_inset Formula $\ell$
\end_inset

 ויהיו 
\begin_inset Formula $s,t\in V$
\end_inset

 אזי 
\begin_inset Formula $\d\left(s,t\right)=\inf_{\sigma\in\left\{ s\to t\right\} }\ell\left(\sigma\right)$
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
בעיית המסלולים הקצרים מנקודת מוצא (
\begin_inset Formula $\text{SSSP}$
\end_inset

)
\series default
:
 יהי 
\begin_inset Formula $G$
\end_inset

 גרף מכוון ממושקל 
\begin_inset Formula $\ell$
\end_inset

 ויהי 
\begin_inset Formula $s\in V$
\end_inset

 אזי 
\begin_inset Formula $T\le G$
\end_inset

 עץ פורש בו כל מסלול מ־
\begin_inset Formula $s$
\end_inset

 ל־
\begin_inset Formula $v$
\end_inset

 הינו מסלול קצר ביותר ב־
\begin_inset Formula $G$
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
למה אי־שיוויון המשולש
\series default
:
 יהיו 
\begin_inset Formula $u,v,w\in V$
\end_inset

 אזי 
\begin_inset Formula $\d\left(u,v\right)\le\d\left(u,w\right)+\d\left(w,v\right)$
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
למה תת־מסלול קצר ביותר
\series default
:
 יהי 
\begin_inset Formula $\sigma$
\end_inset

 מסלול קצר ביותר ויהי 
\begin_inset Formula $i\in\text{len}\left(\sigma\right)$
\end_inset

 אזי 
\begin_inset Formula $\left(\sigma\left[i\right],\ldots\sigma\left[i+k\right]\right)$
\end_inset

 מסלול קצר ביותר.
\end_layout

\begin_layout Standard

\series bold
אלגוריתם בלמן־פורד למציאת מסלולים קצרים ביותר מנקודת מוצא
\series default
:
 יהי 
\begin_inset Formula $G$
\end_inset

 גרף מכוון וממושקל 
\begin_inset Formula $\ell$
\end_inset

 ויהי 
\begin_inset Formula $s\in V$
\end_inset

 אזי
\end_layout

\begin_layout Standard

\lang english
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
begin{algorithm}
\end_layout

\begin_layout Plain Layout


\backslash
SetAlgoLined
\end_layout

\begin_layout Plain Layout


\backslash
SetKwFunction{name}{BellmanFord}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
SetKwProg{Fn}{function}{:}{}
\end_layout

\begin_layout Plain Layout


\backslash
Fn{
\backslash
name{$G,
 
\backslash
ell ,
 s$}}{
\end_layout

\begin_layout Plain Layout

    $
\backslash
left(d,
 
\backslash
pi
\backslash
right)
\backslash
gets$ dict($V$)
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

    $d[s] 
\backslash
gets 0$
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

    
\backslash
For{$u
\backslash
in V$}{
\end_layout

\begin_layout Plain Layout

        $d[u] 
\backslash
gets 
\backslash
infty$
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

        $
\backslash
pi[u] 
\backslash
gets 
\backslash
text{None}$
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    $(c,
 i) 
\backslash
gets 1$
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

    
\backslash
While{$(i 
\backslash
le |V|)
\backslash
land(c 
\backslash
ne 0)$}{
\end_layout

\begin_layout Plain Layout

        $c 
\backslash
gets 0$
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

        
\backslash
For{$(u,
 v) 
\backslash
in E$}{
\end_layout

\begin_layout Plain Layout

            $c 
\backslash
gets 
\backslash
text{Relax}(
\backslash
ell,
 d,
 u,
 v)$
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    
\backslash
Return $c$
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
end{algorithm}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
begin{algorithm}
\end_layout

\begin_layout Plain Layout


\backslash
SetAlgoLined
\end_layout

\begin_layout Plain Layout


\backslash
SetKwFunction{name}{Relax}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
SetKwProg{Fn}{function}{:}{}
\end_layout

\begin_layout Plain Layout


\backslash
Fn{
\backslash
name{$
\backslash
ell,
 d,
 u,
 v$}}{
\end_layout

\begin_layout Plain Layout

    
\backslash
uIf{$d[v] > d[u] + 
\backslash
ell(u,v)$}{
\end_layout

\begin_layout Plain Layout

        $d[v] 
\backslash
gets d[u] + 
\backslash
ell(u,v)$
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

        $
\backslash
pi[v] 
\backslash
gets u$
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

        
\backslash
Return 1
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    
\backslash
Return 0
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
end{algorithm}
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\series bold
למה
\series default
:
 יהיו 
\begin_inset Formula $s,u,v\in V$
\end_inset

 באשר 
\begin_inset Formula $\left(u,v\right)\in E$
\end_inset

 וכן בריצת 
\begin_inset Formula $\text{BellmanFord}$
\end_inset

 מתקיים 
\begin_inset Formula $\d\left(s,u\right)\le d\left[u\right]$
\end_inset

 אזי 
\begin_inset Formula $\d\left(s,v\right)\le d\left[u\right]+\ell\left(\left(u,v\right)\right)$
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
מסקנה
\series default
:
 יהיו 
\begin_inset Formula $s,u,v\in V$
\end_inset

 באשר 
\begin_inset Formula $\left(u,v\right)\in E$
\end_inset

 וכן בריצת 
\begin_inset Formula $\text{BellmanFord}$
\end_inset

 מתקיים 
\begin_inset Formula $\d\left(s,u\right)\le d\left[u\right]$
\end_inset

 וכן 
\begin_inset Formula $\d\left(s,v\right)\le d\left[v\right]$
\end_inset

 אזי לאחר הרצת 
\begin_inset Formula $\text{Relax}\left(u,v\right)$
\end_inset

 מתקיים 
\begin_inset Formula $\d\left(s,v\right)\le d\left[v\right]$
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
למה
\series default
:
 יהי 
\begin_inset Formula $s\in V$
\end_inset

 עבורו לכל 
\begin_inset Formula $v\in V$
\end_inset

 בריצת 
\begin_inset Formula $\text{BellmanFord}$
\end_inset

 מתקיים 
\begin_inset Formula $\d\left(s,v\right)\le d\left[v\right]$
\end_inset

 אזי לאחר כל רצף פעולות 
\begin_inset Formula $\text{Relax}$
\end_inset

 נקבל כי לכל 
\begin_inset Formula $v\in V$
\end_inset

 מתקיים 
\begin_inset Formula $\d\left(s,v\right)\le d\left[v\right]$
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
מסקנה
\series default
:
 יהיו 
\begin_inset Formula $s,v\in V$
\end_inset

 עבורם בריצת 
\begin_inset Formula $\text{BellmanFord}$
\end_inset

 מתקיים 
\begin_inset Formula $d\left[v\right]=\infty$
\end_inset

 אזי לאחר כל רצף פעולות 
\begin_inset Formula $\text{Relax}$
\end_inset

 נקבל כי 
\begin_inset Formula $d\left[v\right]=\infty$
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
מסקנה
\series default
:
 יהיו 
\begin_inset Formula $s,v\in V$
\end_inset

 עבורם בריצת 
\begin_inset Formula $\text{BellmanFord}$
\end_inset

 מתקיים 
\begin_inset Formula $d\left[v\right]=\d\left(s,v\right)$
\end_inset

 אזי לאחר כל רצף פעולות 
\begin_inset Formula $\text{Relax}$
\end_inset

 נקבל כי 
\begin_inset Formula $d\left[v\right]=\d\left(s,v\right)$
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
למה
\series default
:
 יהיו 
\begin_inset Formula $s,t\in V$
\end_inset

 עבורם בריצת 
\begin_inset Formula $\text{BellmanFord}$
\end_inset

 מתקיים 
\begin_inset Formula $d\left[s\right]=0$
\end_inset

 ויהי 
\begin_inset Formula $\sigma\in\left\{ s\to t\right\} $
\end_inset

 מסלול אזי לאחר הפעלת הרצף
\begin_inset Newline newline
\end_inset


\begin_inset Formula $\left(\text{Relax}\left(\sigma\left[0\right],\sigma\left[1\right]\right),\ldots,\text{Relax}\left(\sigma\left[n-1\right],\sigma\left[n\right]\right)\right)$
\end_inset

 נקבל כי 
\begin_inset Formula $d\left[t\right]\le\ell\left(\sigma\right)$
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
למה
\series default
:
 יהי 
\begin_inset Formula $s\in V$
\end_inset

 עבורו לא קיים מעגל שלילי אשר ניתן להגיע אליו מ־
\begin_inset Formula $s$
\end_inset

 אזי 
\begin_inset Formula $\text{BellmanFord}$
\end_inset

 יוצא מהלולאה הראשית כאשר 
\begin_inset Formula $i<\left|V\right|$
\end_inset

 וכן מחזיר 0 וכן לכל 
\begin_inset Formula $v\in V$
\end_inset

 מתקיים 
\begin_inset Formula $d\left[v\right]=\d\left(s,v\right)$
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
למה
\series default
:
 יהי 
\begin_inset Formula $s\in V$
\end_inset

 עבורו קיים מעגל שלילי אשר ניתן להגיע אליו מ־
\begin_inset Formula $s$
\end_inset

 אזי 
\begin_inset Formula $\text{BellmanFord}$
\end_inset

 יוצא מהלולאה הראשית כאשר 
\begin_inset Formula $i=\left|V\right|$
\end_inset

 וכן מחזיר 1.
\end_layout

\begin_layout Standard

\series bold
מסקנה
\series default
:
 יהי 
\begin_inset Formula $s\in V$
\end_inset

 אזי
\end_layout

\begin_layout Itemize
(
\begin_inset Formula $\text{BellmanFord}$
\end_inset

 החזיר 1)
\begin_inset Formula $\iff$
\end_inset

(קיים מעגל שלילי אשר ניתן להגיע אליו מ־
\begin_inset Formula $s$
\end_inset

).
\end_layout

\begin_layout Itemize
(
\begin_inset Formula $\text{BellmanFord}$
\end_inset

 החזיר 0)
\begin_inset Formula $\iff$
\end_inset

(לא קיים מעגל שלילי אשר ניתן להגיע אליו מ־
\begin_inset Formula $s$
\end_inset

 וכן לכל 
\begin_inset Formula $v\in V$
\end_inset

 מתקיים 
\begin_inset Formula $d\left[v\right]=\d\left(s,v\right)$
\end_inset

).
\end_layout

\begin_layout Standard

\series bold
עץ 
\begin_inset Formula $\text{BellmanFord}$
\end_inset


\series default
:
 יהי 
\begin_inset Formula $s\in V$
\end_inset

 נגדיר 
\begin_inset Formula $V_{\pi}=\left\{ v\in V\mid\text{BellmanFord}\left(G,s\right).\pi\left[v\right]\ne\text{Null}\right\} \cup\left\{ s\right\} $
\end_inset

 וכן 
\begin_inset Formula $E_{\pi}=\left\{ \left(\pi\left[v\right],v\right)\mid v\in V_{\pi}\backslash\left\{ s\right\} \right\} $
\end_inset

 אזי 
\begin_inset Formula $G_{\pi}=\left(V_{\pi},E_{\pi}\right)$
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
למה
\series default
:
 יהי 
\begin_inset Formula $s\in V$
\end_inset

 ויהי 
\begin_inset Formula $C$
\end_inset

 מעגל בעץ 
\begin_inset Formula $\text{BellmanFord}$
\end_inset

 באיזשהו שלב של הרצת 
\begin_inset Formula $\text{BellmanFord}$
\end_inset

 אזי 
\begin_inset Formula $C$
\end_inset

 מעגל שלילי.
\end_layout

\begin_layout Standard

\series bold
למה
\series default
:
 יהי 
\begin_inset Formula $s\in V$
\end_inset

 עבורו לא קיים מעגל שלילי אשר ניתן להגיע אליו מ־
\begin_inset Formula $s$
\end_inset

 אזי עץ 
\begin_inset Formula $\text{BellmanFord}$
\end_inset

 הינו עץ.
\end_layout

\begin_layout Standard

\series bold
למה
\series default
:
 יהי 
\begin_inset Formula $s\in V$
\end_inset

 עבורו קיים מעגל שלילי אשר ניתן להגיע אליו מ־
\begin_inset Formula $s$
\end_inset

 אזי עץ 
\begin_inset Formula $\text{BellmanFord}$
\end_inset

 מכיל מעגל שלילי.
\end_layout

\begin_layout Standard

\series bold
מסקנה
\series default
:
 יהי 
\begin_inset Formula $s\in V$
\end_inset

 אזי 
\begin_inset Formula $\text{BellmanFord}$
\end_inset

 פתרון לבעיית 
\begin_inset Formula $\text{SSSP}$
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
משפט
\series default
:
 יהי 
\begin_inset Formula $s\in V$
\end_inset

 אזי 
\begin_inset Formula $\text{BellmanFord}$
\end_inset

 בעל סיבוכיות זמן ריצה 
\begin_inset Formula $\O\left(\left|E\right|\cdot\left|V\right|\right)$
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
הערה
\series default
:
 נניח כי 
\begin_inset Formula $\ell:E\to\bbz$
\end_inset

 וכן 
\begin_inset Formula $\ell\left(e\right)\ge-W$
\end_inset

 אזי קיים אלגוריתם לבעיית 
\begin_inset Formula $\text{SSSP}$
\end_inset

 בסיבוכיות זמן ריצה
\begin_inset Newline newline
\end_inset


\begin_inset Formula $\O\left(\left|E\right|\log^{2}\left(\left|V\right|\right)\log\left(\left|V\right|\cdot W\right)\log\log\left(\left|V\right|\right)\right)$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Standard

\series bold
אלגוריתם לבדיקת קיום מעגל במשקל 0 בגרף מכוון חסר מעגלים שליליים
\series default
:
 יהי 
\begin_inset Formula $G$
\end_inset

 גרף מכוון חסר מעגלים שליליים אזי
\end_layout

\begin_layout Standard

\lang english
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
begin{algorithm}
\end_layout

\begin_layout Plain Layout


\backslash
SetAlgoLined
\end_layout

\begin_layout Plain Layout


\backslash
DontPrintSemicolon
\end_layout

\begin_layout Plain Layout


\backslash
SetKwFunction{name}{IsZeroCircle}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
SetKwProg{Fn}{function}{:}{}
\end_layout

\begin_layout Plain Layout


\backslash
Fn{
\backslash
name{$G,
 
\backslash
ell$}}{
\end_layout

\begin_layout Plain Layout

    $V 
\backslash
gets V 
\backslash
uplus 
\backslash
{s
\backslash
}$
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

    
\backslash
For{$v
\backslash
in V
\backslash
backslash 
\backslash
{s
\backslash
}$}{
\end_layout

\begin_layout Plain Layout

        $E 
\backslash
gets E 
\backslash
cup 
\backslash
{(s,
 v)
\backslash
}$
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

        $
\backslash
ell((s,
 v)) 
\backslash
gets 0$
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    $(c,
 d,
 
\backslash
pi)
\backslash
 gets 
\backslash
text{BellmanFord}(G,
 
\backslash
ell,
 s)$
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

    
\backslash
For{$e
\backslash
in E$}{
\end_layout

\begin_layout Plain Layout

        
\backslash
uIf{$d(v) 
\backslash
ne d(u) + 
\backslash
delta(u,v)$}{
\end_layout

\begin_layout Plain Layout

            $E 
\backslash
gets E 
\backslash
backslash 
\backslash
{(s,
 v)
\backslash
}$
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    
\backslash
lIf{$
\backslash
exists 
\backslash
text{ circle } C 
\backslash
in G$}{
\end_layout

\begin_layout Plain Layout

        
\backslash
Return 
\backslash
text{True}
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    
\backslash
Return 
\backslash
text{False}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
end{algorithm}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Standard

\series bold
טענה
\series default
:
 בריצת 
\begin_inset Formula $\text{IsZeroCircle}$
\end_inset

 לאחר מחיקת כל הקשתות נקבל את גרף מק
\begin_inset Quotes erd
\end_inset

ב מ־
\begin_inset Formula $s$
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
טענה
\series default
:
 אם בריצת 
\begin_inset Formula $\text{IsZeroCircle}$
\end_inset

 לאחר מחיקת כל הקשתות קיים מעגל 
\begin_inset Formula $C$
\end_inset

 אזי 
\begin_inset Formula $\ell\left(C\right)=0$
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
טענה
\series default
:
 יהי 
\begin_inset Formula $C$
\end_inset

 מעגל עבורו 
\begin_inset Formula $\ell\left(C\right)=0$
\end_inset

 אזי בריצת 
\begin_inset Formula $\text{IsZeroCircle}$
\end_inset

 לאחר מחיקת כל הקשתות נקבל כי 
\begin_inset Formula $C$
\end_inset

 בגרף.
\end_layout

\begin_layout Standard

\series bold
מסקנה
\series default
:
 יהי 
\begin_inset Formula $G$
\end_inset

 גרף מכוון חסר מעגלים שליליים אזי (
\begin_inset Formula $G$
\end_inset

 בעל מעגל ממשקל 0)
\begin_inset Formula $\iff$
\end_inset

(
\begin_inset Formula $\text{IsZeroCircle}$
\end_inset

 מחזיר 
\begin_inset Formula $\text{True}$
\end_inset

).
\end_layout

\begin_layout Standard

\series bold
טענה
\series default
:
 יהי 
\begin_inset Formula $G$
\end_inset

 גרף מכוון חסר מעגלים שליליים אזי סיבוכיות זמן הריצה של 
\begin_inset Formula $\text{IsZeroCircle}$
\end_inset

 הינה 
\begin_inset Formula $\O\left(\left|V\right|\cdot\left|E\right|\right)$
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
אלגוריתם למציאת מסלולים קצרים ביותר מנקודת מוצא בגרף מכוון אציקלי
\series default
:
 יהי 
\begin_inset Formula $G$
\end_inset

 מכוון אציקלי ויהי 
\begin_inset Formula $s\in V$
\end_inset

 אזי
\end_layout

\begin_layout Standard

\lang english
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
begin{algorithm}
\end_layout

\begin_layout Plain Layout


\backslash
SetAlgoLined
\end_layout

\begin_layout Plain Layout


\backslash
SetKwFunction{name}{SSSP-DAG}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
SetKwProg{Fn}{function}{:}{}
\end_layout

\begin_layout Plain Layout


\backslash
Fn{
\backslash
name{$G,
 
\backslash
ell ,
 s$}}{
\end_layout

\begin_layout Plain Layout

    $
\backslash
left(d,
 
\backslash
pi
\backslash
right)
\backslash
gets$ dict($V$)
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

    $d[s] 
\backslash
gets 0$
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

    
\backslash
For{$u
\backslash
in V$}{
\end_layout

\begin_layout Plain Layout

        $d[u] 
\backslash
gets 
\backslash
infty$
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

        $
\backslash
pi[u] 
\backslash
gets 
\backslash
text{None}$
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    
\backslash
tcc{Knuth’sAlgorithm is an algorithm to compute a topological sorting.}
\end_layout

\begin_layout Plain Layout

    $f 
\backslash
gets 
\backslash
text{Knuth’sAlgorithm}(G)$
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

    
\backslash
For{$i
\backslash
in [1,
\backslash
ldots,|V|]$}{
\end_layout

\begin_layout Plain Layout

        
\backslash
For{$v
\backslash
in 
\backslash
text{Adj}(f(i))$}{
\end_layout

\begin_layout Plain Layout

            $
\backslash
text{Relax}((f(i),
 v))$
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    
\backslash
Return $
\backslash
left(d,
 
\backslash
pi
\backslash
right)$
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
end{algorithm}
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\series bold
טענה
\series default
:
 יהי 
\begin_inset Formula $G$
\end_inset

 מכוון אציקלי ויהי 
\begin_inset Formula $s\in V$
\end_inset

 אזי 
\begin_inset Formula $\text{SSSP-DAG}\left(G\right)$
\end_inset

 פתרון לבעיית 
\begin_inset Formula $\text{SSSP}$
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
טענה
\series default
:
 יהי 
\begin_inset Formula $G$
\end_inset

 מכוון אציקלי ויהי 
\begin_inset Formula $s\in V$
\end_inset

 אזי סיבוכיות זמן הריצה של 
\begin_inset Formula $\text{SSSP-DAG}\left(G\right)$
\end_inset

 הינה 
\begin_inset Formula $\O\left(\left|E\right|+\left|V\right|\right)$
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
אלגוריתם דייקסטרה למציאת מסלולים קצרים ביותר מנקודת מוצא בגרף ללא משקלים שליליים
\series default
:
 יהי 
\begin_inset Formula $G$
\end_inset

 גרף מכוון עבורו 
\begin_inset Formula $\ell\ge0$
\end_inset

 ויהי 
\begin_inset Formula $s\in V$
\end_inset

 אזי
\end_layout

\begin_layout Standard

\lang english
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
begin{algorithm}
\end_layout

\begin_layout Plain Layout


\backslash
SetAlgoLined
\end_layout

\begin_layout Plain Layout


\backslash
SetKwFunction{name}{Dijkstra}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
SetKwProg{Fn}{function}{:}{}
\end_layout

\begin_layout Plain Layout


\backslash
Fn{
\backslash
name{$G,
 
\backslash
ell ,
 s$}}{
\end_layout

\begin_layout Plain Layout

    $Q 
\backslash
gets 
\backslash
text{heap}((V,
 
\backslash
text{int}))$
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

    $
\backslash
left(d,
 
\backslash
pi
\backslash
right)
\backslash
gets$ dict($V$)
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

    $d[s] 
\backslash
gets 0$
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

    
\backslash
For{$u
\backslash
in V$}{
\end_layout

\begin_layout Plain Layout

        $d[u] 
\backslash
gets 
\backslash
infty$
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

        $
\backslash
pi[u] 
\backslash
gets 
\backslash
text{None}$
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    $Q.
\backslash
text{insert}((s,
 d[s]))$
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    
\backslash
While{$Q
\backslash
ne 
\backslash
emptyset$}{
\end_layout

\begin_layout Plain Layout

        $u 
\backslash
gets Q.
\backslash
text{min}$
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

        
\backslash
For{$v
\backslash
in 
\backslash
text{Adj}(u)$}{
\end_layout

\begin_layout Plain Layout

            
\backslash
uIf{$d[v] = 
\backslash
infty$}{
\end_layout

\begin_layout Plain Layout

                $
\backslash
pi[v] 
\backslash
gets u$
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

                $d[v] 
\backslash
gets d[u] + 
\backslash
ell(u,
 v)$
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

                $Q.
\backslash
text{insert}((v,
 d[v]))$
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

            } 
\backslash
uElseIf{$d[u] + 
\backslash
ell(u,
 v) < d[v]$}{
\end_layout

\begin_layout Plain Layout

                $
\backslash
pi[v] 
\backslash
gets u$
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

                $d[v] 
\backslash
gets d[u] + 
\backslash
ell(u,
 v)$
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

                $Q.
\backslash
text{decrease-key}((v,
 d[v]))$
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

            }
\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    
\end_layout

\begin_layout Plain Layout

    
\backslash
Return $
\backslash
left(d,
 
\backslash
pi
\backslash
right)$
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
end{algorithm}
\end_layout

\end_inset


\lang hebrew

\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Standard

\series bold
למה
\series default
:
 יהיו 
\begin_inset Formula $s,u\in V$
\end_inset

 עבורם בריצת 
\begin_inset Formula $\text{Dijkstra}$
\end_inset

 הצומת 
\begin_inset Formula $u$
\end_inset

 נמחקה מ־
\begin_inset Formula $Q$
\end_inset

 אזי 
\begin_inset Formula $d\left[u\right]=\d\left(s,u\right)$
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
משפט
\series default
:
 יהי 
\begin_inset Formula $s\in V$
\end_inset

 אזי 
\begin_inset Formula $\text{Dijkstra}$
\end_inset

 פתרון לבעיית 
\begin_inset Formula $\text{SSSP}$
\end_inset

 כאשר 
\begin_inset Formula $\ell\ge0$
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
משפט
\series default
:
 יהי 
\begin_inset Formula $s\in V$
\end_inset

 אזי ניתן לממש את 
\begin_inset Formula $\text{Dijkstra}$
\end_inset

 עם 
\lang english

\begin_inset Formula $\text{Fibonacci heaps}$
\end_inset


\lang hebrew
 בסיבוכיות זמן ריצה 
\begin_inset Formula $\O\left(\left|E\right|+\left|V\right|\cdot\log\left(\left|V\right|\right)\right)$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Standard

\series bold
בעיית כל המסלולים הקצרים (
\begin_inset Formula $\text{APSP}$
\end_inset

)
\series default
:
 יהי 
\begin_inset Formula $G$
\end_inset

 גרף מכוון וממושקל 
\begin_inset Formula $\ell$
\end_inset

 אזי 
\begin_inset Formula $D\in\M[\left|V\right|][\bbr]$
\end_inset

 עבורו לכל 
\begin_inset Formula $u,v\in V$
\end_inset

 מתקיים 
\begin_inset Formula $D_{u,v}=\d\left(u,v\right)$
\end_inset

 וכן 
\begin_inset Formula $\Pi\in\M[\left|V\right|][V]$
\end_inset

 עבורו לכל 
\begin_inset Formula $u,v\in V$
\end_inset

 קיים מסלול קצר ביותר 
\begin_inset Formula $\sigma$
\end_inset

 מ־
\begin_inset Formula $u$
\end_inset

 ל־
\begin_inset Formula $v$
\end_inset

 המקיים 
\begin_inset Formula $\left(\Pi_{u,v},v\right)\in\sigma$
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
פונקציית פוטנציאל
\series default
:
 יהי 
\begin_inset Formula $G$
\end_inset

 גרף אזי 
\begin_inset Formula $p:V\to\bbr$
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
פונקציית משקל מותאמת
\series default
:
 תהא 
\begin_inset Formula $p$
\end_inset

 פונקציית פוטנציאל אזי פונקציית משקל 
\begin_inset Formula $\ell_{p}$
\end_inset

 עבורה לכל 
\begin_inset Formula $u,v\in V$
\end_inset

 המקיימים 
\begin_inset Formula $\left(u,v\right)\in E$
\end_inset

 מתקיים 
\begin_inset Formula $\ell_{p}\left(\left(u,v\right)\right)=\ell\left(\left(u,v\right)\right)+p\left(u\right)-p\left(v\right)$
\end_inset

 .
\end_layout

\begin_layout Standard

\series bold
משפט
\series default
:
 תהא 
\begin_inset Formula $p$
\end_inset

 פונקציית פוטנציאל יהיו 
\begin_inset Formula $s,t\in V$
\end_inset

 ויהי 
\begin_inset Formula $\sigma$
\end_inset

 מסלול מ־
\begin_inset Formula $s$
\end_inset

 ל־
\begin_inset Formula $t$
\end_inset

 אזי 
\begin_inset Formula $\ell_{p}\left(\sigma\right)=\ell\left(\sigma\right)+p\left(s\right)-p\left(t\right)$
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
מסקנה
\series default
:
 תהא 
\begin_inset Formula $p$
\end_inset

 פונקציית פוטנציאל יהיו 
\begin_inset Formula $s,t\in V$
\end_inset

 ויהי 
\begin_inset Formula $\sigma$
\end_inset

 מסלול מ־
\begin_inset Formula $s$
\end_inset

 ל־
\begin_inset Formula $t$
\end_inset

 אזי (
\begin_inset Formula $\sigma$
\end_inset

 מסלול קצר ביותר ביחס ל־
\begin_inset Formula $\ell$
\end_inset

)
\begin_inset Formula $\iff$
\end_inset

(מסלול קצר ביותר ביחס ל־
\begin_inset Formula $\ell_{p}$
\end_inset

).
\end_layout

\begin_layout Standard

\series bold
מסקנה
\series default
:
 תהא 
\begin_inset Formula $p$
\end_inset

 פונקציית פוטנציאל ויהי 
\begin_inset Formula $\sigma$
\end_inset

 מעגל אזי 
\begin_inset Formula $\ell_{p}\left(\sigma\right)=\ell\left(\sigma\right)$
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
מסקנה
\series default
:
 תהא 
\begin_inset Formula $p$
\end_inset

 פונקציית פוטנציאל ויהיו 
\begin_inset Formula $s,t\in V$
\end_inset

 אזי 
\begin_inset Formula $\d_{\ell}\left(s,t\right)=\d_{\ell_{p}}\left(s,t\right)-p\left(s\right)+p\left(t\right)$
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
פונקציית פוטנציאל פיזבילית
\series default
:
 יהי 
\begin_inset Formula $G$
\end_inset

 גרף מכוון וממושקל 
\begin_inset Formula $\ell$
\end_inset

 אזי פונקציית פוטנציאל 
\begin_inset Formula $p$
\end_inset

 עבורה 
\begin_inset Formula $\ell_{p}\ge0$
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
משפט
\series default
:
 יהי 
\begin_inset Formula $G$
\end_inset

 גרף מכוון וממושקל 
\begin_inset Formula $\ell$
\end_inset

 אזי (קיימת פונקציית פוטנציאל פיזבילית)
\begin_inset Formula $\iff$
\end_inset

(
\begin_inset Formula $G$
\end_inset

 מצוייד עם 
\begin_inset Formula $\ell$
\end_inset

 חסר מעגלים שליליים).
\end_layout

\begin_layout Standard

\series bold
אלגוריתם למציאת פונקציית פוטנאציל פיזבילית
\series default
:
 יהי 
\begin_inset Formula $G$
\end_inset

 גרף מכוון וממושקל 
\begin_inset Formula $\ell$
\end_inset

 אזי
\end_layout

\begin_layout Standard

\lang english
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
begin{algorithm}
\end_layout

\begin_layout Plain Layout


\backslash
SetAlgoLined
\end_layout

\begin_layout Plain Layout


\backslash
DontPrintSemicolon
\end_layout

\begin_layout Plain Layout


\backslash
SetKwFunction{name}{FeasiblePotential}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
SetKwProg{Fn}{function}{:}{}
\end_layout

\begin_layout Plain Layout


\backslash
Fn{
\backslash
name{$G,
 
\backslash
ell$}}{
\end_layout

\begin_layout Plain Layout

    $G^
\backslash
prime 
\backslash
gets G
\backslash
uplus 
\backslash
{s
\backslash
}$
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

    
\backslash
For{$v
\backslash
in V(G)$}{
\end_layout

\begin_layout Plain Layout

        $E(G^
\backslash
prime) 
\backslash
gets E(G^
\backslash
prime) 
\backslash
cup 
\backslash
{(s,
 v)
\backslash
}$
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

        $
\backslash
ell((s,
 v)) 
\backslash
gets 0$
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    $c
\backslash
gets 
\backslash
text{BelmanFord} (G^
\backslash
prime ,
\backslash
ell,
 s)$
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

    
\backslash
lIf{$c = 1$}{
\end_layout

\begin_layout Plain Layout

        
\backslash
Return None
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    $p
\backslash
gets (V(G)
\backslash
to 
\backslash
mathbb{R})$
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

    
\backslash
For{$v
\backslash
in V(G)$}{
\end_layout

\begin_layout Plain Layout

        $p(v) 
\backslash
gets 
\backslash
delta (s,
 v)$
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    
\backslash
Return $p$
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout


\backslash
end{algorithm}
\end_layout

\end_inset


\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Standard

\series bold
טענה
\series default
:
 יהי 
\begin_inset Formula $G$
\end_inset

 גרף מכוון וממושקל 
\begin_inset Formula $\ell$
\end_inset

 אזי
\end_layout

\begin_layout Itemize
(
\begin_inset Formula $G$
\end_inset

 מצוייד עם 
\begin_inset Formula $\ell$
\end_inset

 בעל מעגל שלילי)
\begin_inset Formula $\iff$
\end_inset

(
\begin_inset Formula $\text{FeasiblePotential}\left(G,\ell\right)$
\end_inset

 מחזיר 
\begin_inset Formula $\text{None}$
\end_inset

).
\end_layout

\begin_layout Itemize
(
\begin_inset Formula $G$
\end_inset

 מצוייד עם 
\begin_inset Formula $\ell$
\end_inset

 בעל פונקציית פוטנציאל פיזבילית)
\begin_inset Formula $\iff$
\end_inset


\begin_inset Formula $\text{FeasiblePotential}\left(G,\ell\right)$
\end_inset

 מחזיר פונקציית פוטנציאל פיזבילית).
\end_layout

\begin_layout Standard

\series bold
אלגוריתם ג'ונסון לבעיית כל המסלולים הקצרים
\series default
:
 יהי 
\begin_inset Formula $G$
\end_inset

 גרף מכוון וממושקל 
\begin_inset Formula $\ell$
\end_inset

 אזי
\end_layout

\begin_layout Standard

\lang english
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
begin{algorithm}
\end_layout

\begin_layout Plain Layout


\backslash
SetAlgoLined
\end_layout

\begin_layout Plain Layout


\backslash
DontPrintSemicolon
\end_layout

\begin_layout Plain Layout


\backslash
SetKwFunction{name}{Johnson}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
SetKwProg{Fn}{function}{:}{}
\end_layout

\begin_layout Plain Layout


\backslash
Fn{
\backslash
name{$G,
 
\backslash
ell$}}{
\end_layout

\begin_layout Plain Layout

    $p
\backslash
gets 
\backslash
text{FeasiblePotential}(G,
 
\backslash
ell)$
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

    
\backslash
lIf{$p = 
\backslash
text{None}$}{
\end_layout

\begin_layout Plain Layout

        
\backslash
Return None
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    $
\backslash
ell_p 
\backslash
gets (E 
\backslash
to 
\backslash
mathbb{R})$
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

    
\backslash
For{$(u,v)
\backslash
in E$}{
\end_layout

\begin_layout Plain Layout

        $
\backslash
ell_p ((u,
 v)) = 
\backslash
ell ((u,v)) + p(u) - p(v)$
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    $(D_{
\backslash
ell_p},
 D_
\backslash
ell) 
\backslash
gets M_{
\backslash
left|V
\backslash
right|}{(
\backslash
mathbb{R})}$
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

    $
\backslash
Pi 
\backslash
gets M_{
\backslash
left|V
\backslash
right|}{(E)}$
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

    
\backslash
For{$v
\backslash
in V$}{
\end_layout

\begin_layout Plain Layout

        $(d,
 
\backslash
pi) 
\backslash
gets 
\backslash
text{Dijkstra}(G,
\backslash
ell_p,
 v)$
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

        
\backslash
tcc{Here $D$ and $
\backslash
Pi$ will be simplified,
 to get a solution to APSP as needed we can modify a bit Dijkstra's algorithm to calculate $D$ and $
\backslash
Pi$ on the way to get constant time for this assignment.}
\end_layout

\begin_layout Plain Layout

        $D_v 
\backslash
gets d$
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

        $
\backslash
Pi_v 
\backslash
gets 
\backslash
pi$
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    
\backslash
For{$(u,v)
\backslash
in E$}{
\end_layout

\begin_layout Plain Layout

        $D_{
\backslash
ell} ((u,
 v)) = D_{
\backslash
ell_p} ((u,v)) - p(u) + p(v)$
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    
\backslash
Return $(D,
 
\backslash
Pi)$
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout


\backslash
end{algorithm}
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\series bold
משפט
\series default
:
 יהי 
\begin_inset Formula $G$
\end_inset

 גרף מכוון וממושקל 
\begin_inset Formula $\ell$
\end_inset

 אזי 
\begin_inset Formula $\text{Johnson}\left(G,\ell\right)$
\end_inset

 פתרון לבעיית 
\begin_inset Formula $\text{APSP}$
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
טענה
\series default
:
 יהי 
\begin_inset Formula $G$
\end_inset

 גרף מכוון וממושקל 
\begin_inset Formula $\ell$
\end_inset

 אזי סיבוכיות זמן הריצה של 
\begin_inset Formula $\text{Johnson}\left(G,\ell\right)$
\end_inset

 הינה 
\begin_inset Formula $\O\left(\left|E\right|\left|V\right|+\left|V\right|^{2}\log\left(\left|V\right|\right)\right)$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Standard

\series bold
מכפלת 
\lang english

\begin_inset Formula $\text{Min Plus}$
\end_inset


\series default
\lang hebrew
:
 תהא 
\begin_inset Formula $A\in\M$
\end_inset

 ותהא 
\begin_inset Formula $B\in\M[n\times k]$
\end_inset

 אזי 
\begin_inset Formula $A*B\in\M[m\times k]$
\end_inset


\begin_inset Newline newline
\end_inset

באשר 
\begin_inset Formula $\left(A*B\right)_{i,j}=\min_{k=1}^{n}\left(A_{i,k}+B_{k,j}\right)$
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
טענה
\series default
:
 תהיינה 
\begin_inset Formula $A,B\in\M[n]$
\end_inset

 אזי סיבוכיות זמן הריצה של 
\begin_inset Formula $A*B$
\end_inset

 הינה 
\begin_inset Formula $\O\left(n^{3}\right)$
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
טענה
\series default
:
 תהיינה 
\begin_inset Formula $A,B,C\in\M[n]$
\end_inset

 אזי 
\begin_inset Formula $\left(A*B\right)*C=\left(A*B\right)*C$
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
סימון
\series default
:
 יהיו 
\begin_inset Formula $s,v\in V$
\end_inset

 אזי 
\begin_inset Formula $\d_{k}\left(s,v\right)=\min\left\{ \ell\left(\sigma\right)\mid\left(\sigma\in\left\{ s\to v\right\} \right)\land\left(\left|\sigma\right|\le k\right)\right\} $
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
טענה
\series default
:
 יהיו 
\begin_inset Formula $s,v\in V$
\end_inset

 אזי 
\begin_inset Formula $\d_{k}\left(s,v\right)=\min_{u\in V}\left(\d_{k-1}\left(s,v\right)+\ell\left(u,v\right)\right)$
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
סימון
\series default
:
 יהי 
\begin_inset Formula $s\in V$
\end_inset

 אזי 
\begin_inset Formula $\d_{k}\left(s\right)\in\M[1\times\left|V\right|][\bbr]$
\end_inset

 באשר 
\begin_inset Formula $\left(\d_{k}\left(s\right)\right)_{v}=\d_{k}\left(s,v\right)$
\end_inset

 לכל 
\begin_inset Formula $v\in V$
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
מטריצת המשקל
\series default
:
 יהי 
\begin_inset Formula $G$
\end_inset

 גרף מכוון וממושקל 
\begin_inset Formula $\ell$
\end_inset

 אזי 
\begin_inset Formula $L\in\M[\left|V\right|][\bbr]$
\end_inset

 באשר לכל 
\begin_inset Formula $u,v\in V$
\end_inset

 מתקיים 
\begin_inset Formula $L_{u,v}=\left\{ \begin{smallmatrix}0 &  & u=v\\
\ell\left(\left(u,v\right)\right) &  & \left(u\ne v\right)\land\left(\left(u,v\right)\in E\right)\\
\infty &  & \left(u\ne v\right)\land\left(\left(u,v\right)\notin E\right)
\end{smallmatrix}\right.$
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
מסקנה
\series default
:
 יהי 
\begin_inset Formula $s\in V$
\end_inset

 ותהא 
\begin_inset Formula $L\in\M[\left|V\right|][\bbr]$
\end_inset

 מטריצת המשקל אזי 
\begin_inset Formula $\d_{k}\left(s\right)=\d_{k-1}\left(s\right)*L$
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
סימון
\series default
:
 יהי 
\begin_inset Formula $k\in\bbn$
\end_inset

 אזי 
\begin_inset Formula $D^{\left(k\right)}\in\M[\left|V\right|][\bbr]$
\end_inset

 באשר לכל 
\begin_inset Formula $u,v\in V$
\end_inset

 מתקיים 
\begin_inset Formula $D_{u,v}^{\left(k\right)}=\d_{k}\left(u,v\right)$
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
מסקנה
\series default
:
 תהא 
\begin_inset Formula $L\in\M[\left|V\right|][\bbr]$
\end_inset

 מטריצת המשקל אזי 
\begin_inset Formula $D^{\left(k\right)}=D^{\left(k-1\right)}*L$
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
טענה
\series default
:
 תהא 
\begin_inset Formula $L\in\M[\left|V\right|][\bbr]$
\end_inset

 מטריצת המשקל אזי 
\begin_inset Formula $D^{\left(k\right)}=L^{k}$
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
הערה
\series default
:
 יהי 
\begin_inset Formula $k\in\bbn$
\end_inset

 ותהא 
\begin_inset Formula $L\in\M[\left|V\right|][\bbr]$
\end_inset

 מטריצת המשקל אזי 
\begin_inset Formula $L^{k}=L*\ldots*L$
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
טענה
\series default
:
 יהי 
\begin_inset Formula $G$
\end_inset

 גרף מכוון וממושקל 
\begin_inset Formula $\ell$
\end_inset

 וחסר מעגלים שליליים ויהיו 
\begin_inset Formula $k,m\ge\left|V\right|-1$
\end_inset

 אזי 
\begin_inset Formula $D^{\left(k\right)}=D^{\left(m\right)}$
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
טענה
\series default
:
 יהי 
\begin_inset Formula $G$
\end_inset

 גרף מכוון וממושקל 
\begin_inset Formula $\ell$
\end_inset

 בעל מעגל שלילי ויהי 
\begin_inset Formula $v\in V$
\end_inset

 המופיע במעגל שלילי אזי 
\begin_inset Formula $D_{v,v}^{\left(\left|V\right|\right)}<0$
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
מסקנה
\series default
:
 תהא 
\begin_inset Formula $L\in\M[\left|V\right|][\bbr]$
\end_inset

 מטריצת המשקל אזי 
\begin_inset Formula $L^{\left|V\right|}$
\end_inset

 פתרון לבעיית 
\begin_inset Formula $\text{APSP}$
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
אלגוריתם חזקה איטרטיבית
\series default
:
 תהא 
\begin_inset Formula $A\in\M[n][\bbr]$
\end_inset

 תהא 
\begin_inset Formula $\star$
\end_inset

 פעולה אסוציאטיבית אזי
\end_layout

\begin_layout Standard

\lang english
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
begin{algorithm}
\end_layout

\begin_layout Plain Layout


\backslash
SetAlgoLined
\end_layout

\begin_layout Plain Layout


\backslash
SetKwFunction{name}{RepeatedSquaring}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
SetKwProg{Fn}{function}{:}{}
\end_layout

\begin_layout Plain Layout


\backslash
Fn{
\backslash
name{$A,
 
\backslash
star$}}{
\end_layout

\begin_layout Plain Layout

    $(a_k 
\backslash
ldots a_0) 
\backslash
gets (n)_2$
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

    $B 
\backslash
gets M_n (
\backslash
mathbb{R})$
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

    
\backslash
For{$i 
\backslash
in [k]$}{
\end_layout

\begin_layout Plain Layout

        
\backslash
uIf{$a_i = 1$}{
\end_layout

\begin_layout Plain Layout

            $B = B
\backslash
star A$
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

        $A = A
\backslash
star A$
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    
\backslash
Return $B$
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout


\backslash
end{algorithm}
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\series bold
טענה
\series default
:
 תהא 
\begin_inset Formula $L\in\M[\left|V\right|][\bbr]$
\end_inset

 מטריצת המשקל אזי 
\begin_inset Formula $\text{RepeatedSquaring}\left(L,*\right)$
\end_inset

 פתרון לבעיית 
\begin_inset Formula $\text{APSP}$
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
טענה
\series default
:
 תהא 
\begin_inset Formula $L\in\M[\left|V\right|][\bbr]$
\end_inset

 מטריצת המשקל אזי סיבוכיות זמן הריצה של 
\begin_inset Formula $\text{RepeatedSquaring}\left(L,*\right)$
\end_inset

 הינה 
\begin_inset Formula $\O\left(\left|V\right|^{3}\log\left(\left|V\right|\right)\right)$
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
סימון
\series default
:
 יהי 
\begin_inset Formula $\left(\left[n\right],E\right)$
\end_inset

 גרף מכוון ויהי 
\begin_inset Formula $k\in\bbn$
\end_inset

 אזי 
\begin_inset Formula $F^{\left(k\right)}\in\M[n][\bbr]$
\end_inset

 באשר לכל 
\begin_inset Formula $u,v\in V$
\end_inset

 מתקיים
\begin_inset Newline newline
\end_inset

 
\begin_inset Formula $F_{u,v}^{\left(k\right)}=\min\left\{ \ell\left(\sigma\right)\mid\left(\sigma\in\left\{ u\to v\right\} \right)\land\left(\text{ למעט בהתחלה ובסוף}\left[k\right]\text{ עוברת דרך הצמתים }\sigma\right)\right\} $
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
סימון
\series default
:
 יהי 
\begin_inset Formula $\left(\left[n\right],E\right)$
\end_inset

 גרף מכוון ותהא 
\begin_inset Formula $L\in\M[n][\bbr]$
\end_inset

 מטריצת המשקל אזי 
\begin_inset Formula $F^{\left(0\right)}\in\M[n][\bbr]$
\end_inset

 באשר לכל 
\begin_inset Formula $u,v\in V$
\end_inset

 מתקיים 
\begin_inset Formula $F_{u,v}^{\left(0\right)}=L$
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
טענה
\series default
:
 יהי 
\begin_inset Formula $\left(\left[n\right],E\right)$
\end_inset

 גרף מכוון ויהיו 
\begin_inset Formula $u,v\in\left[n\right]$
\end_inset

 אזי 
\begin_inset Formula $F_{u,v}^{\left(k\right)}=\min\left\{ F_{u,v}^{\left(k-1\right)},F_{u,k}^{\left(k-1\right)}+F_{k,v}^{\left(k-1\right)}\right\} $
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
אלגוריתם פלויד־וורשאל
\series default
:
 יהי 
\begin_inset Formula $\left(\left[n\right],E\right)$
\end_inset

 גרף מכוון ותהא 
\begin_inset Formula $L\in\M[n][\bbr]$
\end_inset

 מטריצת המשקל אזי
\end_layout

\begin_layout Standard

\lang english
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
begin{algorithm}
\end_layout

\begin_layout Plain Layout


\backslash
SetAlgoLined
\end_layout

\begin_layout Plain Layout


\backslash
SetKwFunction{name}{FloydWarshall}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
SetKwProg{Fn}{function}{:}{}
\end_layout

\begin_layout Plain Layout


\backslash
Fn{
\backslash
name{$n,
 L$}}{
\end_layout

\begin_layout Plain Layout

    $
\backslash
Pi 
\backslash
gets M_n ([n])$
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

    
\backslash
For{$u
\backslash
in [n]$}{
\end_layout

\begin_layout Plain Layout

        
\backslash
For{$v
\backslash
in [n]$}{
\end_layout

\begin_layout Plain Layout

            
\backslash
uIf{$(u
\backslash
ne v)
\backslash
land (L_{u,v} < 
\backslash
infty)$}{
\end_layout

\begin_layout Plain Layout

                $
\backslash
Pi_{u,v} 
\backslash
gets u$
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

            } 
\backslash
uElse{
\end_layout

\begin_layout Plain Layout

                $
\backslash
Pi_{u,v} 
\backslash
gets 
\backslash
text{None}$
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

            }
\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    $F 
\backslash
gets L$
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

    
\backslash
For{$k
\backslash
in [n]$}{
\end_layout

\begin_layout Plain Layout

        
\backslash
For{$u
\backslash
in [n]$}{
\end_layout

\begin_layout Plain Layout

            
\backslash
For{$v
\backslash
in [n]$}{
\end_layout

\begin_layout Plain Layout

                
\backslash
uIf{$F_{u,k} + F_{k,v} < F_{u,v}$}{
\end_layout

\begin_layout Plain Layout

                    $F_{u,v} 
\backslash
gets F_{u,k} + F_{k,v}$
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

                    $
\backslash
Pi_{u,v} 
\backslash
gets 
\backslash
Pi_{k,v}$
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

                }
\end_layout

\begin_layout Plain Layout

            }
\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    
\backslash
Return $(F,
 
\backslash
Pi)$
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout


\backslash
end{algorithm}
\end_layout

\end_inset


\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Standard

\series bold
טענה
\series default
:
 יהי 
\begin_inset Formula $\left(\left[n\right],E\right)$
\end_inset

 גרף מכוון ותהא 
\begin_inset Formula $L\in\M[n][\bbr]$
\end_inset

 מטריצת המשקל אזי 
\begin_inset Formula $\text{FloydWarshall}\left(n,L\right)$
\end_inset

 פתרון לבעיית 
\begin_inset Formula $\text{APSP}$
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
טענה
\series default
:
 יהי 
\begin_inset Formula $\left(\left[n\right],E\right)$
\end_inset

 גרף מכוון ותהא 
\begin_inset Formula $L\in\M[n][\bbr]$
\end_inset

 מטריצת המשקל אזי סיבוכיות זמן הריצה של 
\begin_inset Formula $\text{FloydWarshall}\left(n,L\right)$
\end_inset

 הינה 
\begin_inset Formula $\O\left(n^{3}\right)$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Standard

\series bold
קבוצה בלתי תלויה
\series default
:
 יהי 
\begin_inset Formula $G$
\end_inset

 גרף אזי 
\begin_inset Formula $I\subseteq V$
\end_inset

 עבורה לכל 
\begin_inset Formula $u,v\in I$
\end_inset

 מתקיים 
\begin_inset Formula $\left(u,v\right)\notin E$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset FormulaMacro
\newcommand{\mis}{\text{mis}}
{\text{mis}}
\end_inset


\end_layout

\begin_layout Standard

\series bold
סימון
\series default
:
 יהי 
\begin_inset Formula $\left(\left[n\right],E\right)$
\end_inset

 גרף שרוך ויהי 
\begin_inset Formula $w:\left[n\right]\to\bbr_{\ge0}$
\end_inset

 אזי 
\begin_inset Formula $\mis\left(i\right)=\max\left\{ w\left(I\right)\mid\left(I\subseteq\left[i\right]\right)\land\left(\text{ בלתי תלויה }I\right)\right\} $
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
טענה
\series default
:
 יהי 
\begin_inset Formula $\left(\left[n\right],E\right)$
\end_inset

 גרף שרוך ויהי 
\begin_inset Formula $w:\left[n\right]\to\bbr_{\ge0}$
\end_inset

 אזי 
\begin_inset Formula $\mis\left(0\right)=0$
\end_inset

 וכן 
\begin_inset Formula $\mis\left(1\right)=w\left(1\right)$
\end_inset

 וכן
\begin_inset Newline newline
\end_inset


\begin_inset Formula $\mis\left(i\right)=\max\left\{ w\left(i\right)+\mis\left(i-2\right),\mis\left(i-1\right)\right\} $
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
מסקנה
\series default
:
 יהי 
\begin_inset Formula $\left(\left[n\right],E\right)$
\end_inset

 גרף שרוך ויהי 
\begin_inset Formula $w:\left[n\right]\to\bbr_{\ge0}$
\end_inset

 אזי 
\begin_inset Formula $\mis\left(n\right)$
\end_inset

 בעל סיבוכיות זמן ריצה 
\begin_inset Formula $\O\left(n\right)$
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
תת־סדרה
\series default
:
 יהי 
\begin_inset Formula $\Sigma$
\end_inset

 אלפבית ותהא 
\begin_inset Formula $A\in\Sigma^{*}$
\end_inset

 אזי 
\begin_inset Formula $B\in\Sigma^{*}$
\end_inset

 עבורה קיימת 
\begin_inset Formula $f:\left[\left|B\right|\right]\to\left[\left|A\right|\right]$
\end_inset

 עולה ממש וחח
\begin_inset Quotes erd
\end_inset

ע המקיימת 
\begin_inset Formula $A_{f\left(i\right)}=B_{i}$
\end_inset

 לכל 
\begin_inset Formula $i\in\left[\left|B\right|\right]$
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
סימון
\series default
:
 יהי 
\begin_inset Formula $\Sigma$
\end_inset

 אלפבית תהא 
\begin_inset Formula $A\in\Sigma^{*}$
\end_inset

 ותהא 
\begin_inset Formula $B\in\Sigma^{*}$
\end_inset

 תת־סדרה אזי 
\begin_inset Formula $B\lhd A$
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
בעיית תת־סדרה משותפת ארוכה ביותר (
\begin_inset Formula $\text{LCS}$
\end_inset

)
\series default
:
 יהי 
\begin_inset Formula $\Sigma$
\end_inset

 אלפבית ותהיינה 
\begin_inset Formula $A,B\in\Sigma^{*}$
\end_inset

 אזי 
\size small

\begin_inset Formula $\max\left\{ \left|C\right|\mid\left(C\in\Sigma^{*}\right)\land\left(C\lhd A\right)\land\left(C\lhd B\right)\right\} $
\end_inset


\size default
.
\end_layout

\begin_layout Standard
\begin_inset FormulaMacro
\newcommand{\lcs}{\text{lcs}}
{\text{lcs}}
\end_inset


\end_layout

\begin_layout Standard

\series bold
סימון
\series default
:
 תהיינה 
\begin_inset Formula $A,B\in\Sigma^{*}$
\end_inset

 תהא 
\begin_inset Formula $k\le\left|A\right|$
\end_inset

 ותהא 
\begin_inset Formula $\ell\le\left|B\right|$
\end_inset

 אזי 
\size small

\begin_inset Formula $\lcs\left(k,\ell\right)=\max\left\{ \left|C\right|\mid\left(C\lhd\left(A_{1},\ldots,A_{k}\right)\right)\land\left(C\lhd\left(B_{1},\ldots,B_{\ell}\right)\right)\right\} $
\end_inset


\size default
.
\end_layout

\begin_layout Standard

\series bold
טענה
\series default
:
 תהיינה 
\begin_inset Formula $A,B\in\Sigma^{*}$
\end_inset

 אזי 
\begin_inset Formula $\lcs\left(k,\ell\right)=\left\{ \begin{smallmatrix}0 &  & \left(k=0\right)\lor\left(\ell=0\right)\\
\lcs\left(k-1,\ell-1\right)+1 &  & \left(k,\ell>0\right)\land\left(A_{k}=B_{\ell}\right)\\
\max\left\{ \lcs\left(k-1,\ell\right),\lcs\left(k,\ell-1\right)\right\}  &  & \left(k,\ell>0\right)\land\left(A_{k}\ne B_{\ell}\right)
\end{smallmatrix}\right.$
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
מסקנה
\series default
:
 תהיינה 
\begin_inset Formula $A,B\in\Sigma^{*}$
\end_inset

 אזי 
\begin_inset Formula $\lcs\left(\left|A\right|,\left|B\right|\right)$
\end_inset

 בעל סיבוכיות זמן ריצה 
\begin_inset Formula $\O\left(\left|A\right|\cdot\left|B\right|\right)$
\end_inset

 וסיבוכיות מקום 
\begin_inset Formula $\O\left(\left|A\right|\cdot\left|B\right|\right)$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset FormulaMacro
\newcommand{\lis}{\text{lis}}
{\text{lis}}
\end_inset


\end_layout

\begin_layout Standard

\series bold
בעיית תת־סדרה עולה ארוכה ביותר (
\begin_inset Formula $\text{LIS}$
\end_inset

)
\series default
:
 יהי 
\begin_inset Formula $\Sigma$
\end_inset

 אלפבית בעל סדר 
\begin_inset Formula $\prec$
\end_inset

 ותהא 
\begin_inset Formula $A\in\Sigma^{*}$
\end_inset

 אזי 
\begin_inset Formula $\max\left\{ \left|C\right|\mid\left(C\lhd A\right)\land\left(\forall i.C_{i-1}\prec C_{i}\right)\right\} $
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
טענה
\series default
:
 תהא 
\begin_inset Formula $A\in\Sigma^{*}$
\end_inset

 אזי בעיית 
\begin_inset Formula $\text{LIS}$
\end_inset

 של 
\begin_inset Formula $A$
\end_inset

 הינה בעיית 
\begin_inset Formula $\text{LCS}$
\end_inset

 של 
\begin_inset Formula $\left(A,\text{sort}\left(A\right)\right)$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset FormulaMacro
\newcommand{\len}{\text{len}}
{\text{len}}
\end_inset


\end_layout

\begin_layout Standard

\series bold
סימון
\series default
:
 תהא 
\begin_inset Formula $A\in\Sigma^{*}$
\end_inset

 אזי 
\begin_inset Formula $\len\lis\left(k\right)=\max\left\{ \left|X\right|\mid\left(\left(A_{1},\ldots,A_{k}\right)\text{ של }\lis\text{ הינו }X\right)\land\left(A_{k}\text{ מסתיים עם }X\right)\right\} $
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
טענה
\series default
:
 תהא 
\begin_inset Formula $A\in\Sigma^{*}$
\end_inset

 אזי 
\begin_inset Formula $\len\lis\left(1\right)=1$
\end_inset

 וכן 
\begin_inset Formula $\len\lis\left(k\right)=\max_{i\in\left[k-1\right]}\left\{ \len\lis\left(i\right)\mid A_{i}\prec A_{k}\right\} $
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
סימון
\series default
:
 תהא 
\begin_inset Formula $A\in\Sigma^{*}$
\end_inset

 אזי 
\begin_inset Formula $\pi\lis\left(1\right)=\text{None}$
\end_inset

 וכן 
\begin_inset Formula $\pi\lis\left(k\right)=\arg\max\left\{ \len\lis\left(i\right)\mid A_{i}\prec A_{k}\right\} $
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
מסקנה
\series default
:
 תהא 
\begin_inset Formula $A\in\Sigma^{*}$
\end_inset

 ויהי 
\begin_inset Formula $k=\arg\max\left\{ \len\lis\left(1\right),\ldots,\len\lis\left(\left|A\right|\right)\right\} $
\end_inset

 אזי 
\begin_inset Formula $\left(x_{\pi\lis^{\left(\ell\right)}\left(k\right)},\ldots,x_{\pi\lis^{\left(2\right)}\left(k\right)},x_{\pi\lis\left(k\right)},x_{k}\right)$
\end_inset

 פתרון של 
\begin_inset Formula $\text{LIS}$
\end_inset

 בעל סיבוכיות זמן ריצה 
\begin_inset Formula $\O\left(\left|A\right|^{2}\right)$
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
סימון
\series default
:
 תהא 
\begin_inset Formula $A\in\Sigma^{*}$
\end_inset

 אזי 
\begin_inset Formula $\min\lis\left(m\right)=\min\left\{ x_{k}\mid\len\lis\left(k\right)=m\right\} $
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
טענה
\series default
:
 תהא 
\begin_inset Formula $A\in\Sigma^{*}$
\end_inset

 אזי 
\begin_inset Formula $\min\lis$
\end_inset

 עולה ממש.
\end_layout

\begin_layout Standard

\series bold
מסקנה
\series default
:
 תהא 
\begin_inset Formula $A\in\Sigma^{*}$
\end_inset

 אזי 
\begin_inset Formula $\left(\min\lis\left(1\right),\ldots,\min\lis\left(\ell\right)\right)$
\end_inset

 פתרון של 
\begin_inset Formula $\text{LIS}$
\end_inset

 בעל סיבוכיות זמן ריצה 
\begin_inset Formula $\O\left(\left|A\right|\cdot\log\left(\left|A\right|\right)\right)$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset FormulaMacro
\newcommand{\depth}{\text{depth}}
{\text{depth}}
\end_inset


\begin_inset FormulaMacro
\newcommand{\cost}{\text{costp}}
{\text{costp}}
\end_inset


\end_layout

\begin_layout Standard

\series bold
סימון
\series default
:
 יהיו 
\begin_inset Formula $p_{1}\ldots p_{n}\in\left(0,1\right]$
\end_inset

 ויהי 
\begin_inset Formula $T$
\end_inset

 עץ חיפוש בינארי מעל 
\begin_inset Formula $\left\{ x_{1}\ldots x_{n}\right\} $
\end_inset

 אזי 
\begin_inset Formula $\cost\left(T\right)=\sum_{i=1}^{n}\left(p_{i}\cdot\depth_{T}\left(x_{i}\right)\right)$
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
בעיית עץ חיפוש בינארי סטטי אופטימלי
\series default
:
 יהיו 
\begin_inset Formula $p_{1}\ldots p_{n}\in\left(0,1\right]$
\end_inset

 אזי עץ חיפוש בינארי 
\begin_inset Formula $T$
\end_inset

 עבורו 
\begin_inset Formula $\cost\left(T\right)$
\end_inset

 מינימלי.
\end_layout

\begin_layout Standard

\series bold
טענה
\series default
:
 יהיו 
\begin_inset Formula $p_{1}\ldots p_{n}\in\left(0,1\right]$
\end_inset

 ויהי 
\begin_inset Formula $T$
\end_inset

 עץ חיפוש בינארי אזי 
\begin_inset Formula $\cost\left(T\right)=\left(\sum_{i=1}^{n}p_{i}\right)+\cost\left(T.\text{left}\right)+\cost\left(T.\text{right}\right)$
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
מסקנה
\series default
:
 יהיו 
\begin_inset Formula $p_{1}\ldots p_{n}\in\left(0,1\right]$
\end_inset

 ויהי 
\begin_inset Formula $T$
\end_inset

 פתרון לבעיית עץ חיפוש בינארי סטטי אופטימלי אזי 
\begin_inset Formula $T.\text{left},T.\text{right}$
\end_inset

 הינם פתרונות לבעיית עץ חיפוש בינארי סטטי אופטימלי.
\end_layout

\begin_layout Standard
\begin_inset FormulaMacro
\newcommand{\pp}{\text{pp}}
{\text{pp}}
\end_inset


\begin_inset FormulaMacro
\newcommand{\cp}{\text{cp}}
{\text{cp}}
\end_inset


\end_layout

\begin_layout Standard

\series bold
סימון
\series default
:
 יהיו 
\begin_inset Formula $p_{1}\ldots p_{n}\in\left(0,1\right]$
\end_inset

 אזי 
\begin_inset Formula $\pp\left(i,j\right)=\sum_{k=i}^{j}p_{k}$
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
סימון
\series default
:
 יהיו 
\begin_inset Formula $p_{1}\ldots p_{n}\in\left(0,1\right]$
\end_inset

 ויהיו 
\begin_inset Formula $x_{1}\ldots x_{n}$
\end_inset

 אזי 
\begin_inset Formula $\cp\left(i,j\right)=\min\left\{ \cost\left(T\right)\mid\left\{ x_{i}\ldots x_{j}\right\} \text{ עץ חיפוש בינארי מעל }T\right\} $
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
טענה
\series default
:
 יהיו 
\begin_inset Formula $p_{1}\ldots p_{n}\in\left(0,1\right]$
\end_inset

 ויהיו 
\begin_inset Formula $x_{1}\ldots x_{n}$
\end_inset

 אזי 
\begin_inset Formula $\cp\left(i,i-1\right)=0$
\end_inset

 וכן 
\begin_inset Formula $\cp\left(i,i\right)=p_{i}$
\end_inset

 וכן
\begin_inset Newline newline
\end_inset


\begin_inset Formula $\cp\left(i,j\right)=\pp\left(i,j\right)+\min_{i\le k\le j}\left(\cp\left(i,k-1\right)+\cp\left(k+1,j\right)\right)$
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
מסקנה אלגוריתם לבעיית עץ חיפוש בינארי סטטי אופטימלי
\series default
:
 יהיו 
\begin_inset Formula $p_{1}\ldots p_{n}\in\left(0,1\right]$
\end_inset

 ויהיו 
\begin_inset Formula $x_{1}\ldots x_{n}$
\end_inset

 אזי
\end_layout

\begin_layout Standard

\lang english
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
begin{algorithm}
\end_layout

\begin_layout Plain Layout


\backslash
SetAlgoLined
\end_layout

\begin_layout Plain Layout


\backslash
SetKwFunction{OSBST}{OSBST}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
SetKwProg{Fn}{function}{:}{}
\end_layout

\begin_layout Plain Layout


\backslash
Fn{
\backslash
OSBST{pp}}{
\end_layout

\begin_layout Plain Layout

    $K,
 C 
\backslash
gets 
\backslash
text{List}([n]^2)$
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

    
\backslash
For{$i 
\backslash
gets [n + 1]$}{
\end_layout

\begin_layout Plain Layout

        $C(i,
 i-1) 
\backslash
gets 0$
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    
\backslash
For{$d 
\backslash
gets 
\backslash
{0,
\backslash
ldots ,
 n-1
\backslash
}$}{
\end_layout

\begin_layout Plain Layout

        
\backslash
For{$i 
\backslash
gets [n-d]$}{
\end_layout

\begin_layout Plain Layout

            $C(i,
 i + d)
\backslash
gets 
\backslash
infty$
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

            
\backslash
For{$k
\backslash
gets 
\backslash
{i,
\backslash
ldots ,
 i+d
\backslash
}$}{
\end_layout

\begin_layout Plain Layout

                $t
\backslash
gets 
\backslash
text{pp}(i,j) + C(i,
 k-1) + C(k+1,
 j)$
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

                
\backslash
uIf{$t < C(i,j)$}{
\end_layout

\begin_layout Plain Layout

                    $C(i,j) 
\backslash
gets t$
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

                    $K(i,j) 
\backslash
gets k$
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

                }
\end_layout

\begin_layout Plain Layout

            }
\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout


\backslash
end{algorithm}
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\lang english
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Standard

\series bold
מסקנה
\series default
:
 יהיו 
\begin_inset Formula $p_{1}\ldots p_{n}\in\left(0,1\right]$
\end_inset

 אזי 
\begin_inset Formula $\text{OSBST}\left(\pp\right).K$
\end_inset

 משרה פתרון לבעיית עץ חיפוש בינארי סטטי אופטימלי.
\end_layout

\begin_layout Standard

\series bold
מסקנה
\series default
:
 יהיו 
\begin_inset Formula $p_{1}\ldots p_{n}\in\left(0,1\right]$
\end_inset

 אזי 
\begin_inset Formula $\text{OSBST}\left(\pp\right)$
\end_inset

 בעל סיבוכיות זמן ריצה 
\begin_inset Formula $\O\left(n^{3}\right)$
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
הערה
\series default
:
 קיים אלגוריתם קנות' לבעיית עץ חיפוש בינארי סטטי אופטימלי בסיבוכיות זמן ריצה 
\begin_inset Formula $\O\left(n^{2}\right)$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Standard

\series bold
בעיית 0/1 תרמיל הגב
\series default
:
 יהיו 
\begin_inset Formula $W,w_{1}\ldots w_{n},v_{1}\ldots v_{n}\ge0$
\end_inset

 אזי 
\begin_inset Formula $S\subseteq\left[n\right]$
\end_inset

 באשר 
\begin_inset Formula $\sum_{i\in S}v_{i}$
\end_inset

 מקסימלית וכן 
\begin_inset Formula $\sum_{i\in S}w_{i}\le W$
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
בעיית שבר תרמיל הגב
\series default
:
 יהיו 
\begin_inset Formula $W,w_{1}\ldots w_{n},v_{1}\ldots v_{n}\ge0$
\end_inset

 אזי 
\begin_inset Formula $f:\left[n\right]\to\left[0,1\right]$
\end_inset

 באשר 
\begin_inset Formula $\sum_{i\in\left[n\right]}f\left(i\right)v_{i}$
\end_inset

 מקסימלית וכן
\begin_inset Newline newline
\end_inset


\begin_inset Formula $\sum_{i\in\left[n\right]}f\left(i\right)w_{i}\le W$
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
אלגוריתם חמדן לבעיית שבר תרמיל הגב
\series default
:
 יהיו 
\begin_inset Formula $W,w_{1}\ldots w_{n}>0$
\end_inset

 ויהיו 
\begin_inset Formula $v_{1}\ldots v_{n}\ge0$
\end_inset

 אזי
\end_layout

\begin_layout Standard

\lang english
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
begin{algorithm}
\end_layout

\begin_layout Plain Layout


\backslash
SetAlgoLined
\end_layout

\begin_layout Plain Layout


\backslash
SetKwFunction{func}{FractionalKnapsack}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
SetKwProg{Fn}{function}{:}{}
\end_layout

\begin_layout Plain Layout


\backslash
Fn{
\backslash
func{$W,
 w_1,
 
\backslash
ldots ,
 w_n,
 v_1,
 
\backslash
ldots ,
 v_n$}}{
\end_layout

\begin_layout Plain Layout

    $f
\backslash
gets ([n] 
\backslash
to [0,
 1])$
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

    $P 
\backslash
gets 
\backslash
text{List}([n]
\backslash
times 
\backslash
mathbb{R})$
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

    
\backslash
For{$i
\backslash
gets [n]$}{
\end_layout

\begin_layout Plain Layout

        $P(i) 
\backslash
gets (i,
 
\backslash
frac{v_i}{w_i})$
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

        $f(i) 
\backslash
gets 0$
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    $P 
\backslash
gets 
\backslash
text{sort}(P)$ 
\backslash
tcp{Sort from high to low based on second coordinate.}
\end_layout

\begin_layout Plain Layout

    $t 
\backslash
gets 0$
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

    $i 
\backslash
gets 1$
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

    
\backslash
While {$(t < W)
\backslash
land (i 
\backslash
le n)$}{
\end_layout

\begin_layout Plain Layout

        $j 
\backslash
gets P(i)[0]$
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

        
\backslash
uIf{$t + w_{j} 
\backslash
le W$}{
\end_layout

\begin_layout Plain Layout

            $f(j) 
\backslash
gets 1$
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

            $t 
\backslash
gets t + w_{j}$
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

        
\backslash
uElse{
\end_layout

\begin_layout Plain Layout

            $f(j) 
\backslash
gets 
\backslash
frac{W - t}{w_{j}}$
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

            $t 
\backslash
gets W$
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    
\backslash
Return $f$
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout


\backslash
end{algorithm}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset FormulaMacro
\newcommand{\bknap}{\text{bknap}}
{\text{bknap}}
\end_inset


\end_layout

\begin_layout Standard

\series bold
סימון
\series default
:
 יהיו 
\begin_inset Formula $W,w_{1}\ldots w_{n},v_{1}\ldots v_{n}\ge0$
\end_inset

 אזי 
\begin_inset Formula $\bknap\left(k,W\right)=\max\left\{ \sum_{i\in S}v_{i}\mid\left(S\subseteq\left[k\right]\right)\land\left(\sum_{i\in S}w_{i}\le W\right)\right\} $
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
טענה
\series default
:
 יהיו 
\begin_inset Formula $w_{1}\ldots w_{n},v_{1}\ldots v_{n}\ge0$
\end_inset

 אזי
\end_layout

\begin_layout Itemize
יהי 
\begin_inset Formula $m\ge0$
\end_inset

 אזי 
\begin_inset Formula $\bknap\left(0,m\right)=0$
\end_inset

.
\end_layout

\begin_layout Itemize
יהי 
\begin_inset Formula $i\in\left[n\right]$
\end_inset

 אזי 
\begin_inset Formula $\bknap\left(i,0\right)=0$
\end_inset

.
\end_layout

\begin_layout Itemize
יהי 
\begin_inset Formula $m\ge0$
\end_inset

 ויהי 
\begin_inset Formula $i\in\left[n\right]$
\end_inset

 אזי 
\begin_inset Formula $\bknap\left(i,m\right)=\left\{ \begin{smallmatrix}\bknap\left(i-1,m\right) &  & w_{i}>m\\
\max\left\{ \bknap\left(i-1,m\right),\bknap\left(i-1,m-w_{i}\right)+v_{i}\right\}  &  & w_{i}\le m
\end{smallmatrix}\right.$
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
מסקנה
\series default
:
 יהיו 
\begin_inset Formula $W,w_{1}\ldots w_{n},v_{1}\ldots v_{n}\ge0$
\end_inset

 אזי חישוב 
\begin_inset Formula $\bknap\left(n,W\right)$
\end_inset

 בעל סיבוכיות זמן ריצה 
\begin_inset Formula $\O\left(nW\right)$
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
מסקנה אלגוריתם לבעיית 0/1 תרמיל הגב
\series default
:
 יהיו 
\begin_inset Formula $W,w_{1}\ldots w_{n},v_{1}\ldots v_{n}\ge0$
\end_inset

 אזי
\lang english

\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Standard

\lang english
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
begin{algorithm}
\end_layout

\begin_layout Plain Layout


\backslash
SetAlgoLined
\end_layout

\begin_layout Plain Layout


\backslash
SetKwFunction{func}{ZeroOneKnapsack}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
SetKwProg{Fn}{function}{:}{}
\end_layout

\begin_layout Plain Layout


\backslash
Fn{
\backslash
func{$W,
 w_1,
 
\backslash
ldots ,
 w_n,
 v_1,
 
\backslash
ldots ,
 v_n$}}{
\end_layout

\begin_layout Plain Layout

    $k 
\backslash
gets n$
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

    $w
\backslash
gets W$
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

    $S
\backslash
gets 
\backslash
text{Set}([n])$
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

    $S
\backslash
gets 
\backslash
emptyset$
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

    
\backslash
While{$(k>0)
\backslash
land (w > 0)$}{
\end_layout

\begin_layout Plain Layout

        
\backslash
uIf{$
\backslash
text{bknap}(k,
 w) 
\backslash
ne 
\backslash
text{bknap}(k - 1,
 w)$}{
\end_layout

\begin_layout Plain Layout

            $S
\backslash
gets S
\backslash
cup 
\backslash
{k
\backslash
}$
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

            $k
\backslash
gets k-1$
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

            $w
\backslash
gets w - w_k$
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

        }
\backslash
uElse{
\end_layout

\begin_layout Plain Layout

            $k
\backslash
gets k-1$
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout


\backslash
end{algorithm}
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\series bold
מסקנה
\series default
:
 יהיו 
\begin_inset Formula $W,w_{1}\ldots w_{n},v_{1}\ldots v_{n}\ge0$
\end_inset

 אזי 
\begin_inset Formula $\text{ZeroOneKnapsack}\left(W,w_{1}\ldots w_{n},v_{1}\ldots v_{n}\right)$
\end_inset

 פתרון לבעיית 0/1 תרמיל הגב.
\end_layout

\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Standard

\series bold
רשת זרימה
\series default
:
 יהי 
\begin_inset Formula $G$
\end_inset

 גרף מכוון וממושקל 
\begin_inset Formula $c\ge0$
\end_inset

 ותהיינה 
\begin_inset Formula $s,t\in V$
\end_inset

 אזי 
\begin_inset Formula $\left(V,E,c,s,t\right)$
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
פונקציית קיבולת
\series default
:
 תהא 
\begin_inset Formula $\left(V,E,c,s,t\right)$
\end_inset

 רשת זרימה אזי 
\begin_inset Formula $c$
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
קודקוד מקור
\series default
:
 תהא 
\begin_inset Formula $\left(V,E,c,s,t\right)$
\end_inset

 רשת זרימה אזי 
\begin_inset Formula $s$
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
קודקוד בור
\series default
:
 תהא 
\begin_inset Formula $\left(V,E,c,s,t\right)$
\end_inset

 רשת זרימה אזי 
\begin_inset Formula $t$
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
עודף זרימה
\series default
:
 תהא 
\begin_inset Formula $\left(V,E,c,s,t\right)$
\end_inset

 רשת זרימה ותהא 
\begin_inset Formula $f:E\to\bbr_{\ge0}$
\end_inset

 אזי 
\begin_inset Formula $\chi_{f}:V\to\bbr$
\end_inset

 המוגדרת
\begin_inset Newline newline
\end_inset


\begin_inset Formula $\chi_{f}\left(v\right)=\sum_{\substack{u\in V\\
\left(u,v\right)\in E
}
}f\left(\left(u,v\right)\right)-\sum_{\substack{u\in V\\
\left(v,u\right)\in E
}
}f\left(\left(v,u\right)\right)$
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
פונקציית זרימה
\series default
:
 תהא 
\begin_inset Formula $\left(V,E,c,s,t\right)$
\end_inset

 רשת זרימה אזי 
\begin_inset Formula $f:E\to\bbr_{\ge0}$
\end_inset

 עבורה
\end_layout

\begin_layout Itemize
חסם קיבולת:
 
\begin_inset Formula $f\le c$
\end_inset

.
\end_layout

\begin_layout Itemize
שימור זרם:
 לכל 
\begin_inset Formula $v\in V\backslash\left\{ s,t\right\} $
\end_inset

 מתקיים 
\begin_inset Formula $\chi_{f}\left(v\right)=0$
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
בעיית הזרימה המקסימלית
\series default
:
 תהא 
\begin_inset Formula $\left(V,E,c,s,t\right)$
\end_inset

 רשת זרימה אזי פונקציית זרימה 
\begin_inset Formula $f$
\end_inset

 עבורה 
\begin_inset Formula $\chi_{f}\left(t\right)$
\end_inset

 מקסימלית.
\end_layout

\begin_layout Standard
\begin_inset FormulaMacro
\newcommand{\st}{\text{s-t}}
{\text{s-t}}
\end_inset


\end_layout

\begin_layout Standard

\series bold
חתך 
\begin_inset Formula $\st$
\end_inset


\series default
:
 תהא 
\begin_inset Formula $\left(V,E,c,s,t\right)$
\end_inset

 רשת זרימה אזי 
\begin_inset Formula $\left(S,T\right)$
\end_inset

 באשר 
\begin_inset Formula $S,T\subseteq V$
\end_inset

 וכן 
\begin_inset Formula $S\uplus T=V$
\end_inset

 וכן 
\begin_inset Formula $s\in S$
\end_inset

 וכן 
\begin_inset Formula $t\in T$
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
קשתות חוצות
\series default
:
 תהא 
\begin_inset Formula $G$
\end_inset

 רשת זרימה ויהי 
\begin_inset Formula $\left(S,T\right)$
\end_inset

 חתך 
\begin_inset Formula $\st$
\end_inset

 אזי 
\begin_inset Formula $E\left(S,T\right)=\left\{ \left(u,v\right)\in E\mid\left(u\in S\right)\land\left(v\in T\right)\right\} $
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
קשתות אחוריות
\series default
:
 תהא 
\begin_inset Formula $G$
\end_inset

 רשת זרימה ויהי 
\begin_inset Formula $\left(S,T\right)$
\end_inset

 חתך 
\begin_inset Formula $\st$
\end_inset

 אזי 
\begin_inset Formula $E\left(T,S\right)=\left\{ \left(u,v\right)\in E\mid\left(u\in T\right)\land\left(v\in S\right)\right\} $
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
קיבולת של חתך
\series default
:
 יהי 
\begin_inset Formula $\left(S,T\right)$
\end_inset

 חתך 
\begin_inset Formula $\st$
\end_inset

 אזי 
\begin_inset Formula $c\left(S,T\right)=\sum_{e\in E\left(S,T\right)}c\left(e\right)$
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
זרימה על פני חתך
\series default
:
 יהי 
\begin_inset Formula $\left(S,T\right)$
\end_inset

 חתך 
\begin_inset Formula $\st$
\end_inset

 אזי 
\begin_inset Formula $f\left(S,T\right)=\sum_{e\in E\left(S,T\right)}f\left(e\right)-\sum_{e\in E\left(T,S\right)}f\left(e\right)$
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
ערך/גודל של זרימה
\series default
:
 תהא 
\begin_inset Formula $f$
\end_inset

 זרימה אזי 
\begin_inset Formula $\left|f\right|=f\left(V\backslash\left\{ t\right\} ,\left\{ t\right\} \right)$
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
למה
\series default
:
 תהא 
\begin_inset Formula $f$
\end_inset

 זרימה ויהי 
\begin_inset Formula $\left(S,T\right)$
\end_inset

 חתך 
\begin_inset Formula $\st$
\end_inset

 אזי 
\begin_inset Formula $\left|f\right|=f\left(S,T\right)$
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
מסקנה
\series default
:
 תהא 
\begin_inset Formula $f$
\end_inset

 זרימה אזי 
\begin_inset Formula $\left|f\right|=f\left(\left\{ s\right\} ,V\backslash\left\{ s\right\} \right)$
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
למה
\series default
:
 תהא 
\begin_inset Formula $f$
\end_inset

 זרימה ויהי 
\begin_inset Formula $\left(S,T\right)$
\end_inset

 חתך 
\begin_inset Formula $\st$
\end_inset

 אזי 
\begin_inset Formula $f\left(S,T\right)\le c\left(S,T\right)$
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
מסקנה
\series default
:
 תהא 
\begin_inset Formula $f$
\end_inset

 זרימה ויהי 
\begin_inset Formula $\left(S,T\right)$
\end_inset

 חתך 
\begin_inset Formula $\st$
\end_inset

 עבורו 
\begin_inset Formula $f\left(S,T\right)=c\left(S,T\right)$
\end_inset

 אזי
\end_layout

\begin_layout Itemize
\begin_inset Formula $f$
\end_inset

 זרימה מקסימלית.
\end_layout

\begin_layout Itemize
לכל חתך 
\begin_inset Formula $\st$
\end_inset

 
\begin_inset Formula $\left(A,B\right)$
\end_inset

 מתקיים 
\begin_inset Formula $c\left(\left(S,T\right)\right)\le c\left(\left(A,B\right)\right)$
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
מסלול ניתן להגדלה 
\begin_inset Formula $\st$
\end_inset


\series default
:
 תהא 
\begin_inset Formula $f$
\end_inset

 זרימה אזי 
\begin_inset Formula $P\in\left\{ s\to t\right\} $
\end_inset

 באשר 
\begin_inset Formula $f\left(e\right)<c\left(e\right)$
\end_inset

 לכל 
\begin_inset Formula $e\in P$
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
טענה הגדלת מסלול
\series default
:
 תהא 
\begin_inset Formula $f$
\end_inset

 זרימה ויהי 
\begin_inset Formula $P\in\left\{ s\to t\right\} $
\end_inset

 מסלול ניתן להגדלה 
\begin_inset Formula $\st$
\end_inset

 אזי קיימת פונקציית זרימה 
\begin_inset Formula $g$
\end_inset

 עבורה 
\begin_inset Formula $g_{\upharpoonright_{E\backslash P}}=f_{\upharpoonright_{E\backslash P}}$
\end_inset

 וכן 
\begin_inset Formula $\left|f\right|<\left|g\right|$
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
זרימה חוסמת
\series default
:
 פונקציית זרימה 
\begin_inset Formula $f$
\end_inset

 עבורה לא קיים מסלול ניתן להגדלה 
\begin_inset Formula $\st$
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
קשת אנטי־מקבילה
\series default
:
 יהי 
\begin_inset Formula $G$
\end_inset

 גרף מכוון ותהא 
\begin_inset Formula $e\in E$
\end_inset

 עבורה 
\begin_inset Formula $e^{-1}\in E$
\end_inset

 אזי 
\begin_inset Formula $e^{-1}$
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
רשת זרימה שיורית
\series default
:
 תהא 
\begin_inset Formula $\left(V,E,c,s,t\right)$
\end_inset

 רשת זרימה חסרת קשתות אנטי־מקבילות ותהא 
\begin_inset Formula $f$
\end_inset

 זרימה אזי 
\begin_inset Formula $\left(V,E_{f},c_{f},s,t\right)$
\end_inset

 באשר
\end_layout

\begin_layout Itemize
\begin_inset Formula $E_{f}=\left\{ e\in E\mid c\left(e\right)>f\left(e\right)\right\} \cup E^{-1}$
\end_inset

.
\end_layout

\begin_layout Itemize
פונקציית שיוריות הקיבולת:
 תהא 
\begin_inset Formula $e\in E_{f}$
\end_inset

 אזי 
\begin_inset Formula $c_{f}\left(e\right)=\left\{ \begin{smallmatrix}c\left(e\right)-f\left(e\right) &  & e\in E\\
f\left(e^{-1}\right) &  & e\in E^{-1}
\end{smallmatrix}\right.$
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
רשת זרימה שיורית
\series default
:
 תהא 
\begin_inset Formula $\left(V,E,c,s,t\right)$
\end_inset

 רשת זרימה בעלת קשתות אנטי־מקבילות ותהא 
\begin_inset Formula $f$
\end_inset

 זרימה אזי 
\begin_inset Formula $\left(V,E_{f},c_{f},s,t\right)$
\end_inset

 באשר
\end_layout

\begin_layout Itemize
פונקציית שיוריות הקיבולת:
 תהא 
\begin_inset Formula $e\in E$
\end_inset

 אזי 
\begin_inset Formula $c_{f}\left(e\right)=c\left(e\right)-f\left(e\right)+f\left(e^{-1}\right)$
\end_inset

.
\end_layout

\begin_layout Itemize
\begin_inset Formula $E_{f}=\left\{ e\in E\mid c_{f}\left(e\right)>0\right\} $
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
הערה
\series default
:
 יהיו 
\begin_inset Formula $u,v\in V$
\end_inset

 עבורם 
\begin_inset Formula $\left(u,v\right)\notin E$
\end_inset

 אזי 
\begin_inset Formula $c\left(\left(u,v\right)\right)=0$
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
סימון
\series default
:
 תהא 
\begin_inset Formula $G$
\end_inset

 רשת זרימה ותהא 
\begin_inset Formula $f$
\end_inset

 זרימה אזי 
\begin_inset Formula $G_{f}$
\end_inset

 הינה רשת הזרימה השיורית.
\end_layout

\begin_layout Standard

\series bold
מסלול ניתן לשיפור 
\begin_inset Formula $\st$
\end_inset


\series default
:
 תהא 
\begin_inset Formula $G$
\end_inset

 רשת זרימה ותהא 
\begin_inset Formula $f$
\end_inset

 זרימה אזי מסלול 
\begin_inset Formula $P\in\left\{ s\to t\right\} $
\end_inset

 בגרף 
\begin_inset Formula $G_{f}$
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
מחסום/שיורית הקיבולת של מסלול
\series default
:
 תהא 
\begin_inset Formula $f$
\end_inset

 זרימה ויהי 
\begin_inset Formula $P$
\end_inset

 מסלול ניתן לשיפור 
\begin_inset Formula $\st$
\end_inset

 אזי 
\begin_inset Formula $c_{f}\left(P\right)=\min\left\{ c_{f}\left(e\right)\mid e\in P\right\} $
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
זרימה משופרת
\series default
:
 תהא 
\begin_inset Formula $f$
\end_inset

 זרימה ויהי 
\begin_inset Formula $P$
\end_inset

 מסלול ניתן לשיפור 
\begin_inset Formula $\st$
\end_inset

 אזי 
\begin_inset Formula $f_{P}\left(e\right)=\left\{ \begin{smallmatrix}f\left(e\right)+c_{f}\left(P\right) &  & e\in P\\
f\left(e\right)-c_{f}\left(P\right) &  & e^{-1}\in P\\
f\left(e\right) &  & \text{else}
\end{smallmatrix}\right.$
\end_inset

 לכל 
\begin_inset Formula $e\in E\left(G\right)$
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
למה
\series default
:
 תהא 
\begin_inset Formula $f$
\end_inset

 זרימה ויהי 
\begin_inset Formula $P$
\end_inset

 מסלול ניתן לשיפור 
\begin_inset Formula $\st$
\end_inset

 אזי 
\begin_inset Formula $f_{P}$
\end_inset

 זרימה של 
\begin_inset Formula $G$
\end_inset

 וכן 
\begin_inset Formula $\left|f_{P}\right|=\left|f\right|+c_{f}\left(P\right)$
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
משפט
\series default
:
 תהא 
\begin_inset Formula $f$
\end_inset

 זרימה התב
\begin_inset Quotes erd
\end_inset

ש
\end_layout

\begin_layout Itemize
\begin_inset Formula $f$
\end_inset

 זרימה מקסימלית ב־
\begin_inset Formula $G$
\end_inset

.
\end_layout

\begin_layout Itemize
לכל מסלול 
\begin_inset Formula $P\in\left\{ s\to t\right\} $
\end_inset

 בגרף 
\begin_inset Formula $G_{f}$
\end_inset

 מתקיים כי 
\begin_inset Formula $P$
\end_inset

 אינו מסלול ניתן לשיפור 
\begin_inset Formula $\st$
\end_inset

.
\end_layout

\begin_layout Itemize
קיים 
\begin_inset Formula $\left(S,T\right)$
\end_inset

 חתך 
\begin_inset Formula $\st$
\end_inset

 מינימלי ל־
\begin_inset Formula $G$
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
משפט זרימה מקסימלית קיבולת מינימלית
\series default
:
 תהא 
\begin_inset Formula $G$
\end_inset

 רשת זרימה אזי 
\begin_inset Formula $\max\left\{ \left|f\right|\mid\text{ זרימה}f\right\} =\min\left\{ c\left(S,T\right)\mid\st\text{ חתך }\left(S,T\right)\right\} $
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
אלגוריתם פורד־פלקרסון
\series default
:
 תהא 
\begin_inset Formula $\left(V,E,c,s,t\right)$
\end_inset

 רשת זרימה אזי
\end_layout

\begin_layout Standard

\lang english
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
begin{algorithm}
\end_layout

\begin_layout Plain Layout


\backslash
SetAlgoLined
\end_layout

\begin_layout Plain Layout


\backslash
DontPrintSemicolon
\end_layout

\begin_layout Plain Layout


\backslash
SetKwFunction{func}{FordFulkerson}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
SetKwProg{Fn}{function}{:}{}
\end_layout

\begin_layout Plain Layout


\backslash
Fn{
\backslash
func{$V,E,c,s,t$}}{
\end_layout

\begin_layout Plain Layout

    $f
\backslash
gets (E
\backslash
to 
\backslash
mathbb{R})$
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

    $f 
\backslash
gets 0$
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

    
\backslash
While{True}{
\end_layout

\begin_layout Plain Layout

        $G_f 
\backslash
gets 
\backslash
text{ResidualNetwork}(G,
 c,s,t,
 f)$ 
\backslash
tcp{Construct it like any graph.}
\end_layout

\begin_layout Plain Layout

        $
\backslash
pi_{G_f} 
\backslash
gets 
\backslash
text{BFS}(G,
 s)$
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

        
\backslash
lIf{$
\backslash
{s 
\backslash
to t
\backslash
}
\backslash
cap
\backslash
pi_{G_f} = 
\backslash
emptyset$}{
\end_layout

\begin_layout Plain Layout

            
\backslash
Return $f$
\end_layout

\begin_layout Plain Layout

        } 
\backslash
uElse{
\end_layout

\begin_layout Plain Layout

            $P 
\backslash
gets 
\backslash
{s 
\backslash
to t
\backslash
}
\backslash
cap
\backslash
pi_{G_f}$ 
\backslash
tcp{The path is taken from $
\backslash
pi_{G_f}$.}
\end_layout

\begin_layout Plain Layout

            $f 
\backslash
gets f_P$
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

    }    
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout


\backslash
end{algorithm}
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\series bold
סימון
\series default
:
 תהא 
\begin_inset Formula $\left(V,E,c,s,t\right)$
\end_inset

 רשת זרימה אזי 
\begin_inset Formula $\text{FF}=\text{FordFulkerson}\left(V,E,c,s,t\right)$
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
משפט
\series default
:
 תהא 
\begin_inset Formula $\left(V,E,c,s,t\right)$
\end_inset

 רשת זרימה באשר 
\begin_inset Formula $c\left(E\right)\subseteq\bbn$
\end_inset

 אזי קיימת זרימה מקסימלית 
\begin_inset Formula $f$
\end_inset

 באשר 
\begin_inset Formula $f\left(E\right)\subseteq\bbn$
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
טענה
\series default
:
 תהא 
\begin_inset Formula $\left(V,E,c,s,t\right)$
\end_inset

 רשת זרימה באשר 
\begin_inset Formula $c\left(E\right)\subseteq\bbn$
\end_inset

 אזי בכל איטרציה של 
\begin_inset Formula $\text{FF}$
\end_inset

 מתקיים
\end_layout

\begin_layout Itemize
\begin_inset Formula $f$
\end_inset

 זרימה של 
\begin_inset Formula $G$
\end_inset

.
\end_layout

\begin_layout Itemize
\begin_inset Formula $f\left(E\right)\subseteq\bbn$
\end_inset

.
\end_layout

\begin_layout Itemize
\begin_inset Formula $c_{f}\left(P\right)\ge1$
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
משפט
\series default
:
 תהא 
\begin_inset Formula $\left(V,E,c,s,t\right)$
\end_inset

 רשת זרימה באשר 
\begin_inset Formula $c\left(E\right)\subseteq\bbn$
\end_inset

 ותהא 
\begin_inset Formula $f$
\end_inset

 זרימה מקסימלית באשר 
\begin_inset Formula $f\left(E\right)\subseteq\bbn$
\end_inset

 אזי
\end_layout

\begin_layout Itemize
\begin_inset Formula $\text{FF}$
\end_inset

 פתרון לבעיית הזרימה המקסימלית לכל בחירת מסלולים באלגוריתם.
\end_layout

\begin_layout Itemize
\begin_inset Formula $\text{FF}$
\end_inset

 עושה לכל היותר 
\begin_inset Formula $\left|f\right|$
\end_inset

 שיפורי מסלול.
\end_layout

\begin_layout Itemize
\begin_inset Formula $\text{FF}\left(E\right)\subseteq\bbn$
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
מסקנה
\series default
:
 תהא 
\begin_inset Formula $\left(V,E,c,s,t\right)$
\end_inset

 רשת זרימה באשר 
\begin_inset Formula $c\left(E\right)\subseteq\bbn$
\end_inset

 ותהא 
\begin_inset Formula $f$
\end_inset

 זרימה מקסימלית באשר 
\begin_inset Formula $f\left(E\right)\subseteq\bbn$
\end_inset

 אזי סיבוכיות זמן הריצה של 
\begin_inset Formula $\text{FF}$
\end_inset

 הינה 
\begin_inset Formula $\O\left(\left|E\right|\left|f\right|\right)$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Standard

\series bold
זיווג
\series default
:
 יהי 
\begin_inset Formula $G$
\end_inset

 גרף לא מכוון אזי 
\begin_inset Formula $M\subseteq E\left(G\right)$
\end_inset

 עבורה לכל 
\begin_inset Formula $e_{1},e_{2}\in M$
\end_inset

 מתקיים 
\begin_inset Formula $\left|e_{1}\cap e_{2}\right|\ne1$
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
בעיית זיווג מקסימלי
\series default
:
 יהי 
\begin_inset Formula $G$
\end_inset

 גרף לא מכוון אזי 
\begin_inset Formula $\arg\max\left\{ \left|M\right|\mid G\text{ זיווג של }M\right\} $
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
זיווג מושלם
\series default
:
 יהי 
\begin_inset Formula $G$
\end_inset

 גרף לא מכוון אזי זיווג 
\begin_inset Formula $M\subseteq E\left(G\right)$
\end_inset

 עבורו 
\begin_inset Formula $\bigcup M=V\left(G\right)$
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
סימון
\series default
:
 יהי 
\begin_inset Formula $G$
\end_inset

 גרף דו־צדדי לא מכוון ויהיו 
\begin_inset Formula $A,B\subseteq V\left(G\right)$
\end_inset

 עבורם 
\begin_inset Formula $A\uplus B=V\left(G\right)$
\end_inset

 וכן לכל 
\begin_inset Formula $e\in E\left(G\right)$
\end_inset

 מתקיים 
\begin_inset Formula $\left|e\cap A\right|=\left|e\cap B\right|=1$
\end_inset

 אזי 
\begin_inset Formula $G_{L}=A$
\end_inset

 וכן 
\begin_inset Formula $G_{R}=B$
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
סימון
\series default
:
 יהי 
\begin_inset Formula $G$
\end_inset

 גרף דו־צדדי לא מכוון ויהיו 
\begin_inset Formula $s,t\notin V\left(G\right)$
\end_inset

 אזי 
\begin_inset Formula $V^{\perp}=V\left(G\right)\cup\left\{ s,t\right\} $
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
סימון
\series default
:
 יהי 
\begin_inset Formula $G$
\end_inset

 גרף דו־צדדי לא מכוון אזי 
\begin_inset Formula $E^{\to}=\left\{ \left<v,u\right>\mid\left(\left\{ v,u\right\} \in E\left(G\right)\right)\land\left(v\in G_{L}\right)\land\left(u\in G_{R}\right)\right\} $
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
סימון
\series default
:
 יהי 
\begin_inset Formula $G$
\end_inset

 גרף דו־צדדי לא מכוון ויהיו 
\begin_inset Formula $s,t\notin V\left(G\right)$
\end_inset

 אזי 
\begin_inset Formula $E^{\perp}=\left(\left\{ s\right\} \times G_{L}\right)\cup E^{\to}\cup\left(G_{R}\times\left\{ t\right\} \right)$
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
סימון
\series default
:
 יהי 
\begin_inset Formula $G$
\end_inset

 גרף דו־צדדי לא מכוון ויהיו 
\begin_inset Formula $s,t\notin V\left(G\right)$
\end_inset

 אזי 
\begin_inset Formula $c^{\perp}:E^{\perp}\to\bbr_{+}$
\end_inset

 המוגדרת 
\begin_inset Formula $c_{\upharpoonright_{\left(\left\{ s\right\} \times G_{L}\right)\cup\left(G_{R}\times\left\{ t\right\} \right)}}^{\perp}=1$
\end_inset

 וכן 
\begin_inset Formula $c_{\upharpoonright_{E^{\to}}}^{\perp}=\infty$
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
סימון
\series default
:
 יהי 
\begin_inset Formula $G$
\end_inset

 גרף דו־צדדי לא מכוון ויהיו 
\begin_inset Formula $s,t\notin V\left(G\right)$
\end_inset

 אזי 
\begin_inset Formula $G^{\perp}=\left(V^{\perp},E^{\perp},c^{\perp},s,t\right)$
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
אלגוריתם לבעיית זיווג מקסימלי בגרף דו־צדדי
\series default
:
 יהי 
\begin_inset Formula $G$
\end_inset

 גרף דו־צדדי לא מכוון אזי
\end_layout

\begin_layout Standard

\lang english
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
begin{algorithm}
\end_layout

\begin_layout Plain Layout


\backslash
SetAlgoLined
\end_layout

\begin_layout Plain Layout


\backslash
SetKwFunction{name}{BMMF}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
SetKwProg{Fn}{function}{:}{}
\end_layout

\begin_layout Plain Layout


\backslash
Fn{
\backslash
name{$G$}}{
\end_layout

\begin_layout Plain Layout

    $(s,
 t) 
\backslash
not
\backslash
gets V
\backslash
left(G
\backslash
right)$
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

    $G^{
\backslash
perp} 
\backslash
gets (V^{
\backslash
perp},E^{
\backslash
perp},c^{
\backslash
perp},s,t)$
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

    $f
\backslash
gets 
\backslash
text{FordFulkerson}(G^{
\backslash
perp})$
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

    
\backslash
Return $
\backslash
{e
\backslash
in E(G) 
\backslash
mid f(e) = 1 
\backslash
}$
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout


\backslash
end{algorithm}
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\series bold
טענה
\series default
:
 יהי 
\begin_inset Formula $G$
\end_inset

 גרף דו־צדדי לא מכוון אזי 
\begin_inset Formula $\text{BMMF}\left(G\right)$
\end_inset

 הינו זיווג מקסימלי.
\end_layout

\begin_layout Standard

\series bold
טענה
\series default
:
 יהי 
\begin_inset Formula $G$
\end_inset

 גרף דו־צדדי לא מכוון אזי 
\begin_inset Formula $\text{BMMF}\left(G\right)$
\end_inset

 בעל סיבוכיות זמן ריצה 
\begin_inset Formula $\O\left(\left|E\right|\cdot\left|V\right|\right)$
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
משפט
\series default
:
 יהי 
\begin_inset Formula $G$
\end_inset

 גרף דו־צדדי לא מכוון ויהיו 
\begin_inset Formula $s,t\notin V\left(G\right)$
\end_inset

 אזי 
\begin_inset Formula $\max\left\{ \left|M\right|\mid G\text{ זיווג של }M\right\} =\max\left\{ \left|f\right|\mid G^{\perp}\text{ זרימה של }f\right\} $
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
כיסוי צמתים
\series default
:
 יהי 
\begin_inset Formula $G$
\end_inset

 גרף לא מכוון אזי 
\begin_inset Formula $C\subseteq V\left(G\right)$
\end_inset

 עבורה לכל 
\begin_inset Formula $e\in E$
\end_inset

 מתקיים 
\begin_inset Formula $e\cap C\ne\emptyset$
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
בעיית כיסוי צמתים מינימלי
\series default
:
 יהי 
\begin_inset Formula $G$
\end_inset

 גרף לא מכוון אזי 
\begin_inset Formula $\arg\min\left\{ \left|C\right|\mid G\text{ כיסוי צמתים של }C\right\} $
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
למה
\series default
:
 יהי 
\begin_inset Formula $G$
\end_inset

 גרף דו־צדדי לא מכוון אזי 
\begin_inset Formula $\max\left\{ \left|M\right|\mid G\text{ זיווג של }M\right\} \le\min\left\{ \left|C\right|\mid G\text{ כיסוי צמתים של }C\right\} $
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
אלגוריתם לבעיית כיסוי צמתים מינימלי בגרף דו־צדדי
\series default
:
 יהי 
\begin_inset Formula $G$
\end_inset

 גרף דו־צדדי לא מכוון אזי
\end_layout

\begin_layout Standard

\lang english
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
begin{algorithm}
\end_layout

\begin_layout Plain Layout


\backslash
SetAlgoLined
\end_layout

\begin_layout Plain Layout


\backslash
SetKwFunction{name}{BMVC}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
SetKwProg{Fn}{function}{:}{}
\end_layout

\begin_layout Plain Layout


\backslash
Fn{
\backslash
name{$G$}}{
\end_layout

\begin_layout Plain Layout

    $(M,
 s,
 t,
 G^{
\backslash
perp},
 f)
\backslash
gets
\backslash
text{BMMF}(G)$
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

    $C 
\backslash
gets V(G)$
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

    
\backslash
For{$
\backslash
{u,
 v
\backslash
}
\backslash
in M
\backslash
cap (G_{L} 
\backslash
times G_{R})$}{
\end_layout

\begin_layout Plain Layout

        
\backslash
uIf{$
\backslash
left
\backslash
{ 
\backslash
tau :
 s 
\backslash
to v 
\backslash
bmid G^{
\backslash
perp}_{f} 
\backslash
text{ בגרף מסלול } 
\backslash
tau 
\backslash
right
\backslash
} 
\backslash
ne 
\backslash
emptyset$}{
\end_layout

\begin_layout Plain Layout

            $C 
\backslash
gets C 
\backslash
cup 
\backslash
{v
\backslash
}$
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

        
\backslash
uElse{
\end_layout

\begin_layout Plain Layout

            $C 
\backslash
gets C 
\backslash
cup 
\backslash
{u
\backslash
}$
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    
\backslash
Return $C$
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout


\backslash
end{algorithm}
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\series bold
טענה
\series default
:
 יהי 
\begin_inset Formula $G$
\end_inset

 גרף דו־צדדי לא מכוון אזי 
\begin_inset Formula $\text{BMVC}\left(G\right)$
\end_inset

 הינו כיסוי צמתים.
\end_layout

\begin_layout Standard

\series bold
טענה
\series default
:
 יהי 
\begin_inset Formula $G$
\end_inset

 גרף דו־צדדי לא מכוון ויהי 
\begin_inset Formula $M$
\end_inset

 זיווג מקסימלי אזי 
\begin_inset Formula $\left|\text{BMVC}\left(G\right)\right|=\left|M\right|$
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
מסקנה
\series default
:
 יהי 
\begin_inset Formula $G$
\end_inset

 גרף דו־צדדי לא מכוון אזי 
\begin_inset Formula $\text{BMVC}\left(G\right)$
\end_inset

 הינו כיסוי צמתים מינימלי.
\end_layout

\begin_layout Standard

\series bold
משפט
\series default
:
 יהי 
\begin_inset Formula $G$
\end_inset

 גרף דו־צדדי לא מכוון אזי 
\begin_inset Formula $\max\left\{ \left|M\right|\mid G\text{ זיווג של }M\right\} =\min\left\{ \left|C\right|\mid G\text{ כיסוי צמתים של }C\right\} $
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
סימון
\series default
:
 יהי 
\begin_inset Formula $G$
\end_inset

 גרף מכוון ויהיו 
\begin_inset Formula $s,t\in V$
\end_inset

 אזי 
\begin_inset Formula $\text{DP}_{s,t}=\max\left\{ n\in\bbn\mid t\text{ ל־}s\text{ מסלולים זרים בקשתות מ־}n\text{קיימים }\right\} $
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
סימון
\series default
:
 יהי 
\begin_inset Formula $G$
\end_inset

 גרף מכוון ויהיו 
\begin_inset Formula $s,t\in V$
\end_inset

 אזי 
\begin_inset Formula $\text{DE}_{s,t}=\min\left\{ n\in\bbn\mid t\text{ ל־}s\text{ קשתות שאם נסירן לא יהיה מסלול מ־}n\text{קיימות }\right\} $
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
רשת 0/1
\series default
:
 יהי 
\begin_inset Formula $G$
\end_inset

 גרף מכוון ויהיו 
\begin_inset Formula $s,t\in V$
\end_inset

 אזי 
\begin_inset Formula $\left(V,E,1,s,t\right)$
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
טענה
\series default
:
 יהי 
\begin_inset Formula $G$
\end_inset

 גרף מכוון ויהיו 
\begin_inset Formula $s,t\in V$
\end_inset

 אזי 
\begin_inset Formula $\text{DP}_{s,t}=\max\left\{ \left|f\right|\mid\text{ זרימה ברשת 0/1}f\right\} $
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
טענה
\series default
:
 יהי 
\begin_inset Formula $G$
\end_inset

 גרף מכוון ויהיו 
\begin_inset Formula $s,t\in V$
\end_inset

 אזי 
\begin_inset Formula $\text{DE}_{s,t}=\min\left\{ c\left(S,T\right)\mid\text{ ברשת 0/1}\st\text{ חתך }\left(S,T\right)\right\} $
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
מסקנה משפט מנגר
\series default
:
 יהי 
\begin_inset Formula $G$
\end_inset

 גרף מכוון ויהיו 
\begin_inset Formula $s,t\in V$
\end_inset

 אזי 
\begin_inset Formula $\text{DP}_{s,t}=\text{DE}_{s,t}$
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
סימון
\series default
:
 יהי 
\begin_inset Formula $G$
\end_inset

 גרף דו־צדדי לא מכוון ותהא 
\begin_inset Formula $A\subseteq G_{L}$
\end_inset

 אזי 
\begin_inset Formula $N\left(A\right)=\left\{ y\in G_{R}\mid\left(A\times\left\{ y\right\} \right)\cap E\ne\emptyset\right\} $
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
משפט החתונה/הול
\series default
:
 יהי 
\begin_inset Formula $G$
\end_inset

 גרף דו־צדדי לא מכוון באשר 
\begin_inset Formula $\left|G_{L}\right|=\left|G_{R}\right|$
\end_inset

 אזי (קיים זיווג מושלם ב־
\begin_inset Formula $G$
\end_inset

)
\begin_inset Formula $\iff$
\end_inset

(לכל 
\begin_inset Formula $A\subseteq G_{L}$
\end_inset

 מתקיים 
\begin_inset Formula $\left|A\right|\le\left|N\left(A\right)\right|$
\end_inset

).
\end_layout

\begin_layout Standard

\series bold
גרף 
\begin_inset Formula $k$
\end_inset

־קשיר בקשתות
\series default
:
 יהי 
\begin_inset Formula $k\in\bbn_{+}$
\end_inset

 אזי גרף מכוון 
\begin_inset Formula $G$
\end_inset

 עבורו לכל 
\begin_inset Formula $u,v\in G$
\end_inset

 קיימים 
\begin_inset Formula $k$
\end_inset

 מסלולים זרים בקשתות מ־
\begin_inset Formula $u$
\end_inset

 ל־
\begin_inset Formula $v$
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
אלגוריתם לבדיקת 
\begin_inset Formula $k$
\end_inset

־קשירות בקשתות
\series default
:
 יהי 
\begin_inset Formula $k\in\bbn_{+}$
\end_inset

 ויהי 
\begin_inset Formula $G$
\end_inset

 גרף מכוון אזי
\end_layout

\begin_layout Standard

\lang english
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
begin{algorithm}
\end_layout

\begin_layout Plain Layout


\backslash
SetAlgoLined
\end_layout

\begin_layout Plain Layout


\backslash
DontPrintSemicolon
\end_layout

\begin_layout Plain Layout


\backslash
SetKwFunction{name}{kConnected}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
SetKwProg{Fn}{function}{:}{}
\end_layout

\begin_layout Plain Layout


\backslash
Fn{
\backslash
name{$k,
 G$}}{
\end_layout

\begin_layout Plain Layout

    $v
\backslash
gets V$
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

    
\backslash
For{$u
\backslash
in V
\backslash
backslash 
\backslash
{v
\backslash
}$}{
\end_layout

\begin_layout Plain Layout

        
\backslash
tcc{The following FordFulkerson calls will return True if the flow size is bigger then $k$ after $k$ augmenting paths else False}
\end_layout

\begin_layout Plain Layout

        $ b_1 
\backslash
gets 
\backslash
text{FordFulkerson}(V,E,1,v,u)$
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

        $ b_2 
\backslash
gets 
\backslash
text{FordFulkerson}(V,E,1,u,v)$
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

        
\backslash
lIf{$(
\backslash
neg b_1) 
\backslash
lor (
\backslash
neg b_2)$}{
\end_layout

\begin_layout Plain Layout

            
\backslash
Return False
\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    
\backslash
Return True
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout


\backslash
end{algorithm}
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\lang english
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Standard

\series bold
טענה
\series default
:
 יהי 
\begin_inset Formula $k\in\bbn_{+}$
\end_inset

 ויהי 
\begin_inset Formula $G$
\end_inset

 גרף מכוון אזי (
\begin_inset Formula $G$
\end_inset

 גרף 
\begin_inset Formula $k$
\end_inset

־קשיר בקשתות)
\begin_inset Formula $\iff$
\end_inset

(
\begin_inset Formula $\text{kConnected}\left(G\right)=\text{True}$
\end_inset

).
\end_layout

\begin_layout Standard

\series bold
טענה
\series default
:
 יהי 
\begin_inset Formula $k\in\bbn_{+}$
\end_inset

 ויהי 
\begin_inset Formula $G$
\end_inset

 גרף מכוון אזי סיבוכיות זמן הריצה של 
\begin_inset Formula $\text{kConnected}\left(G\right)$
\end_inset

 הינה 
\begin_inset Formula $\O\left(\left|V\right|\cdot k\left|E\right|\right)$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Standard

\series bold
פונקציית פרה־זרימה/קדם זרימה
\series default
:
 תהא 
\begin_inset Formula $\left(V,E,c,s,t\right)$
\end_inset

 רשת זרימה אזי 
\begin_inset Formula $f:E\to\bbr_{\ge0}$
\end_inset

 עבורה
\end_layout

\begin_layout Itemize
חסם קיבולת:
 
\begin_inset Formula $f\le c$
\end_inset

.
\end_layout

\begin_layout Itemize
לכל 
\begin_inset Formula $v\in V\backslash\left\{ s,t\right\} $
\end_inset

 מתקיים 
\begin_inset Formula $\chi_{f}\left(v\right)\ge0$
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
צומת גולשת/בעלת עודף זרימה
\series default
:
 תהא 
\begin_inset Formula $\left(V,E,c,s,t\right)$
\end_inset

 רשת זרימה ותהא 
\begin_inset Formula $f$
\end_inset

 פונקציית קדם זרימה אזי 
\begin_inset Formula $v\in V\backslash\left\{ s,t\right\} $
\end_inset

 עבורה 
\begin_inset Formula $\chi_{f}\left(v\right)>0$
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
סימון
\series default
:
 תהא 
\begin_inset Formula $\left(V,E,c,s,t\right)$
\end_inset

 רשת זרימה חסרת קשתות אנטי־מקבילות ותהא 
\begin_inset Formula $f$
\end_inset

 קדם זרימה אזי 
\begin_inset Formula $E_{f}=\left\{ e\in E\mid c\left(e\right)>f\left(e\right)\right\} \cup E^{-1}$
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
סימון
\series default
:
 תהא 
\begin_inset Formula $\left(V,E,c,s,t\right)$
\end_inset

 רשת זרימה בעלת קשתות אנטי־מקבילות ותהא 
\begin_inset Formula $f$
\end_inset

 קדם זרימה אזי 
\begin_inset Formula $E_{f}=E_{f}=\left\{ e\in E\mid c_{f}\left(e\right)>0\right\} $
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
פונקציית שיוריות הקיבולת
\series default
:
 תהא 
\begin_inset Formula $\left(V,E,c,s,t\right)$
\end_inset

 רשת זרימה ותהא 
\begin_inset Formula $f$
\end_inset

 קדם זרימה אזי 
\begin_inset Formula $c_{f}:E_{f}\to\bbr_{+}$
\end_inset

 המוגדרת 
\begin_inset Formula $c_{f}\left(e\right)=\left\{ \begin{smallmatrix}c\left(e\right)-f\left(e\right) &  & e\in E\\
f\left(e^{-1}\right) &  & e\in E^{-1}
\end{smallmatrix}\right.$
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
סימון
\series default
:
 תהא 
\begin_inset Formula $\left(V,E,c,s,t\right)$
\end_inset

 רשת זרימה תהא 
\begin_inset Formula $f$
\end_inset

 קדם זרימה ויהיו 
\begin_inset Formula $u,v\in V$
\end_inset

 אזי 
\begin_inset Formula $\Delta_{u,v}=\min\left\{ \chi_{f}\left(u\right),c_{f}\left(\left(u,v\right)\right)\right\} $
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
אלגוריתם דחיפה
\series default
:
 תהא 
\begin_inset Formula $\left(V,E,c,s,t\right)$
\end_inset

 רשת זרימה תהא 
\begin_inset Formula $f$
\end_inset

 קדם זרימה ויהיו 
\begin_inset Formula $u,v\in V$
\end_inset

 אזי
\end_layout

\begin_layout Standard

\lang english
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
begin{algorithm}
\end_layout

\begin_layout Plain Layout


\backslash
SetAlgoLined
\end_layout

\begin_layout Plain Layout


\backslash
SetKwFunction{name}{Push}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
SetKwProg{Fn}{function}{:}{}
\end_layout

\begin_layout Plain Layout


\backslash
Fn{
\backslash
name{$(V,
 E,
 c,
 s,
 t),
 f,
 u,
 v$}}{
\end_layout

\begin_layout Plain Layout

    $f^* 
\backslash
gets f$
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

    
\backslash
uIf{$(u,
 v)
\backslash
in E$}{
\end_layout

\begin_layout Plain Layout

        $f^*((u,
 v)) 
\backslash
gets f((u,
 v)) + 
\backslash
Delta_{u,
 v}$
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    
\backslash
uIf{$(v,
 u)
\backslash
in E$}{
\end_layout

\begin_layout Plain Layout

        $f^*((v,
 u)) 
\backslash
gets f((v,
 u)) - 
\backslash
Delta_{u,
 v}$
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    
\backslash
Return $f^*$
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout


\backslash
end{algorithm}
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\series bold
סימון
\series default
:
 תהא 
\begin_inset Formula $\left(V,E,c,s,t\right)$
\end_inset

 רשת זרימה תהא 
\begin_inset Formula $f$
\end_inset

 קדם זרימה ויהיו 
\begin_inset Formula $u,v\in V$
\end_inset

 אזי 
\begin_inset Formula $\text{Push}\left(f,u,v\right)=\text{Push}\left(\left(V,E,c,s,t\right),f,u,v\right)$
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
טענה
\series default
:
 תהא 
\begin_inset Formula $\left(V,E,c,s,t\right)$
\end_inset

 רשת זרימה תהא 
\begin_inset Formula $f$
\end_inset

 קדם זרימה ויהיו 
\begin_inset Formula $u,v\in V$
\end_inset

 אזי 
\begin_inset Formula $\text{Push}\left(f,u,v\right)$
\end_inset

 קדם זרימה.
\end_layout

\begin_layout Standard

\series bold
טענה
\series default
:
 תהא 
\begin_inset Formula $\left(V,E,c,s,t\right)$
\end_inset

 רשת זרימה תהא 
\begin_inset Formula $f$
\end_inset

 קדם זרימה ויהיו 
\begin_inset Formula $u,v\in V$
\end_inset

 אזי 
\begin_inset Formula $\chi_{\text{Push}\left(f,u,v\right)}\left(u\right)=\chi_{f}\left(u\right)-\Delta_{u,v}$
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
דחיפה מרווה
\series default
:
 תהא 
\begin_inset Formula $\left(V,E,c,s,t\right)$
\end_inset

 רשת זרימה תהא 
\begin_inset Formula $f$
\end_inset

 קדם זרימה ויהיו 
\begin_inset Formula $u,v\in V$
\end_inset

 עבורם 
\begin_inset Formula $\Delta_{u,v}=c_{f}\left(\left(u,v\right)\right)$
\end_inset

 אזי 
\begin_inset Formula $\text{Push}\left(f,u,v\right)$
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
פונקציית גובה
\series default
:
 תהא 
\begin_inset Formula $\left(V,E,c,s,t\right)$
\end_inset

 רשת זרימה ותהא 
\begin_inset Formula $f$
\end_inset

 קדם זרימה אזי 
\begin_inset Formula $h:V\to\bbn$
\end_inset

 עבורה
\end_layout

\begin_layout Itemize
\begin_inset Formula $h\left(s\right)=\left|V\right|$
\end_inset

.
\end_layout

\begin_layout Itemize
\begin_inset Formula $h\left(t\right)=0$
\end_inset

.
\end_layout

\begin_layout Itemize
יהי 
\begin_inset Formula $\left(u,v\right)\in E_{f}$
\end_inset

 אזי 
\begin_inset Formula $h\left(u\right)\le h\left(v\right)+1$
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
קשת קבילה
\series default
:
 תהא 
\begin_inset Formula $\left(V,E,c,s,t\right)$
\end_inset

 רשת זרימה ותהא 
\begin_inset Formula $f$
\end_inset

 קדם זרימה אזי 
\begin_inset Formula $\left(u,v\right)\in E_{f}$
\end_inset

 עבורה 
\begin_inset Formula $\chi_{f}\left(u\right)>0$
\end_inset

 וכן 
\begin_inset Formula $h\left(u\right)=h\left(v\right)+1$
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
אלגוריתם שינוי שם
\series default
:
 תהא 
\begin_inset Formula $\left(V,E,c,s,t\right)$
\end_inset

 רשת זרימה תהא 
\begin_inset Formula $f$
\end_inset

 קדם זרימה תהא 
\begin_inset Formula $h$
\end_inset

 פונקציית גובה ותהא 
\begin_inset Formula $u\in V$
\end_inset

 אזי
\end_layout

\begin_layout Standard

\lang english
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
begin{algorithm}
\end_layout

\begin_layout Plain Layout


\backslash
SetAlgoLined
\end_layout

\begin_layout Plain Layout


\backslash
SetKwFunction{name}{Relabel}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
SetKwProg{Fn}{function}{:}{}
\end_layout

\begin_layout Plain Layout


\backslash
Fn{
\backslash
name{$(V,
 E,
 c,
 s,
 t),
 f,
 h,
 u$}}{
\end_layout

\begin_layout Plain Layout

    $h^* 
\backslash
gets h$
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

    $h^*(u) 
\backslash
gets 
\backslash
min
\backslash
{ h(v) 
\backslash
mid (u,v)
\backslash
in E_f 
\backslash
} + 1$
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

    
\backslash
Return $h^*$
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout


\backslash
end{algorithm}
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\series bold
סימון
\series default
:
 תהא 
\begin_inset Formula $\left(V,E,c,s,t\right)$
\end_inset

 רשת זרימה תהא 
\begin_inset Formula $f$
\end_inset

 קדם זרימה תהא 
\begin_inset Formula $h$
\end_inset

 פונקציית גובה ותהא 
\begin_inset Formula $u\in V$
\end_inset

 אזי 
\begin_inset Formula $\text{Relabel}\left(f,h,u\right)=\text{Push}\left(\left(V,E,c,s,t\right),f,h,u\right)$
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
טענה
\series default
:
 תהא 
\begin_inset Formula $\left(V,E,c,s,t\right)$
\end_inset

 רשת זרימה תהא 
\begin_inset Formula $f$
\end_inset

 קדם זרימה תהא 
\begin_inset Formula $h$
\end_inset

 פונקציית גובה ותהא 
\begin_inset Formula $u\in V$
\end_inset

 אזי
\end_layout

\begin_layout Itemize
יהי 
\begin_inset Formula $\left(u,v\right)\in E_{f}$
\end_inset

 אזי 
\begin_inset Formula $\text{Relabel}\left(f,h,u\right)\left(u\right)\le\text{Relabel}\left(f,h,u\right)\left(v\right)+1$
\end_inset

.
\end_layout

\begin_layout Itemize
יהי 
\begin_inset Formula $\left(w,u\right)\in E_{f}$
\end_inset

 אזי 
\begin_inset Formula $\text{Relabel}\left(f,h,u\right)\left(w\right)\le\text{Relabel}\left(f,h,u\right)\left(u\right)+1$
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
מסקנה
\series default
:
 תהא 
\begin_inset Formula $\left(V,E,c,s,t\right)$
\end_inset

 רשת זרימה תהא 
\begin_inset Formula $f$
\end_inset

 קדם זרימה תהא 
\begin_inset Formula $h$
\end_inset

 פונקציית גובה ותהא 
\begin_inset Formula $u\in V\backslash\left\{ s,t\right\} $
\end_inset

 אזי 
\begin_inset Formula $\text{Relabel}\left(f,h,u\right)$
\end_inset

 פונקציית גובה.
\end_layout

\begin_layout Standard

\series bold
למה
\series default
:
 תהא 
\begin_inset Formula $\left(V,E,c,s,t\right)$
\end_inset

 רשת זרימה תהא 
\begin_inset Formula $f$
\end_inset

 קדם זרימה תהא 
\begin_inset Formula $h$
\end_inset

 פונקציית גובה ותהא 
\begin_inset Formula $u\in V\backslash\left\{ s,t\right\} $
\end_inset

 אזי קיימת 
\begin_inset Formula $\left(u,v\right)\in E_{f}$
\end_inset

 קבילה ביחס ל־
\begin_inset Formula $\text{Relabel}\left(f,h,u\right)$
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
למה
\series default
:
 תהא 
\begin_inset Formula $\left(V,E,c,s,t\right)$
\end_inset

 רשת זרימה תהא 
\begin_inset Formula $f$
\end_inset

 קדם זרימה תהא 
\begin_inset Formula $h$
\end_inset

 פונקציית גובה ותהיינה 
\begin_inset Formula $u,v\in V$
\end_inset

 אזי 
\begin_inset Formula $h\left(u\right)\le h\left(v\right)+\d_{G_{f}}\left(u,v\right)$
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
מסקנה
\series default
:
 תהא 
\begin_inset Formula $\left(V,E,c,s,t\right)$
\end_inset

 רשת זרימה תהא 
\begin_inset Formula $f$
\end_inset

 קדם זרימה תהא 
\begin_inset Formula $h$
\end_inset

 פונקציית גובה ויהי 
\begin_inset Formula $u\in V$
\end_inset

 עבורו קיים מסלול מ־
\begin_inset Formula $u$
\end_inset

 ל־
\begin_inset Formula $t$
\end_inset

 ב־
\begin_inset Formula $G_{f}$
\end_inset

 אזי 
\begin_inset Formula $h\left(u\right)\le\left|V\right|-1$
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
מסקנה
\series default
:
 תהא 
\begin_inset Formula $\left(V,E,c,s,t\right)$
\end_inset

 רשת זרימה תהא 
\begin_inset Formula $f$
\end_inset

 קדם זרימה תהא 
\begin_inset Formula $h$
\end_inset

 פונקציית גובה ויהי 
\begin_inset Formula $u\in V$
\end_inset

 עבורו קיים מסלול מ־
\begin_inset Formula $u$
\end_inset

 ל־
\begin_inset Formula $s$
\end_inset

 ב־
\begin_inset Formula $G_{f}$
\end_inset

 אזי 
\begin_inset Formula $h\left(u\right)\le2\left|V\right|-1$
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
מסקנה
\series default
:
 תהא 
\begin_inset Formula $\left(V,E,c,s,t\right)$
\end_inset

 רשת זרימה תהא 
\begin_inset Formula $f$
\end_inset

 קדם זרימה ותהא 
\begin_inset Formula $h$
\end_inset

 פונקציית גובה אזי לא קיים מסלול מ־
\begin_inset Formula $s$
\end_inset

 ל־
\begin_inset Formula $t$
\end_inset

 ב־
\begin_inset Formula $G_{f}$
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
למה
\series default
:
 תהא 
\begin_inset Formula $\left(V,E,c,s,t\right)$
\end_inset

 רשת זרימה תהא 
\begin_inset Formula $f$
\end_inset

 קדם זרימה ותהא 
\begin_inset Formula $u\in V$
\end_inset

 באשר 
\begin_inset Formula $\chi_{f}\left(u\right)>0$
\end_inset

 אזי קיים מסלול 
\begin_inset Formula $P$
\end_inset

 מ־
\begin_inset Formula $s$
\end_inset

 ל־
\begin_inset Formula $u$
\end_inset

 ב־
\begin_inset Formula $G$
\end_inset

 עבורו 
\begin_inset Formula $f\left(e\right)>0$
\end_inset

 לכל 
\begin_inset Formula $e\in P$
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
מסקנה
\series default
:
 תהא 
\begin_inset Formula $\left(V,E,c,s,t\right)$
\end_inset

 רשת זרימה תהא 
\begin_inset Formula $f$
\end_inset

 קדם זרימה ותהא 
\begin_inset Formula $u\in V$
\end_inset

 באשר 
\begin_inset Formula $\chi_{f}\left(u\right)>0$
\end_inset

 אזי קיים מסלול 
\begin_inset Formula $P$
\end_inset

 מ־
\begin_inset Formula $u$
\end_inset

 ל־
\begin_inset Formula $s$
\end_inset

 ב־
\begin_inset Formula $G_{f}$
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
מסקנה
\series default
:
 תהא 
\begin_inset Formula $\left(V,E,c,s,t\right)$
\end_inset

 רשת זרימה תהא 
\begin_inset Formula $f$
\end_inset

 קדם זרימה ותהא 
\begin_inset Formula $u\in V$
\end_inset

 באשר 
\begin_inset Formula $\chi_{f}\left(u\right)>0$
\end_inset

 אזי 
\begin_inset Formula $h\left(u\right)\le2\left|V\right|-1$
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
אלגוריתם דחיפה ושינוי שם
\series default
:
 תהא 
\begin_inset Formula $\left(V,E,c,s,t\right)$
\end_inset

 רשת זרימה אזי
\end_layout

\begin_layout Standard

\lang english
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
begin{algorithm}
\end_layout

\begin_layout Plain Layout


\backslash
SetAlgoLined
\end_layout

\begin_layout Plain Layout


\backslash
SetKwFunction{name}{GoldbergTarjan}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
SetKwProg{Fn}{function}{:}{}
\end_layout

\begin_layout Plain Layout


\backslash
Fn{
\backslash
name{$(V,
 E,
 c,
 s,
 t)$}}{
\end_layout

\begin_layout Plain Layout

    $f
\backslash
gets (E
\backslash
to
\backslash
mathbb{R}_+)$
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

    $f
\backslash
gets 0$
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

    
\backslash
For{$(s,v)
\backslash
in E$}{
\end_layout

\begin_layout Plain Layout

        $f((s,
 v)) 
\backslash
gets c((s,
 v))$
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    $h
\backslash
gets (V
\backslash
to
\backslash
mathbb{N})$
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

    $h
\backslash
gets 0$
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

    $h(s)
\backslash
gets |V|$
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

    
\end_layout

\begin_layout Plain Layout

    
\backslash
While{$
\backslash
{u
\backslash
in V
\backslash
backslash
\backslash
{s,t
\backslash
}
\backslash
mid
\backslash
chi_f(u)>0
\backslash
} 
\backslash
ne 
\backslash
emptyset $}{
\end_layout

\begin_layout Plain Layout

        $u 
\backslash
gets 
\backslash
{u
\backslash
in V
\backslash
backslash
\backslash
{s,t
\backslash
}
\backslash
mid
\backslash
chi_f(u)>0
\backslash
}$
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

        
\backslash
uIf{$
\backslash
left
\backslash
{ 
\backslash
left(u,v
\backslash
right)
\backslash
in E_{f}
\backslash
mid h
\backslash
left(u
\backslash
right)=h
\backslash
left(v
\backslash
right)+1
\backslash
right
\backslash
} 
\backslash
ne
\backslash
emptyset$}{
\end_layout

\begin_layout Plain Layout

            $
\backslash
left(u,v
\backslash
right) 
\backslash
gets 
\backslash
left
\backslash
{ 
\backslash
left(u,v
\backslash
right)
\backslash
in E_{f}
\backslash
mid h
\backslash
left(u
\backslash
right)=h
\backslash
left(v
\backslash
right)+1
\backslash
right
\backslash
} $
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

            $f 
\backslash
gets 
\backslash
text{Push}(f,
 u,
 v)$
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

        } 
\backslash
uElse {
\end_layout

\begin_layout Plain Layout

            $h
\backslash
gets 
\backslash
text{Relabel}(f,
 h,
 u)$
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    
\backslash
Return $f$
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout


\backslash
end{algorithm}
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\series bold
סימון
\series default
:
 תהא 
\begin_inset Formula $\left(V,E,c,s,t\right)$
\end_inset

 רשת זרימה אזי 
\begin_inset Formula $f_{s}:E\to\bbr_{+}$
\end_inset

 המוגדרת 
\begin_inset Formula $f_{s}\left(\left(u,v\right)\right)=\left\{ \begin{smallmatrix}c\left(\left(u,v\right)\right) &  & u=s\\
0 &  & \text{else}
\end{smallmatrix}\right.$
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
סימון
\series default
:
 תהא 
\begin_inset Formula $\left(V,E,c,s,t\right)$
\end_inset

 רשת זרימה אזי 
\begin_inset Formula $\mathds{1}_{s}:V\to\bbn$
\end_inset

 המוגדרת 
\begin_inset Formula $\mathds{1}_{s}\left(u\right)=\left\{ \begin{smallmatrix}1 &  & u=s\\
0 &  & \text{else}
\end{smallmatrix}\right.$
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
למה
\series default
:
 תהא 
\begin_inset Formula $\left(V,E,c,s,t\right)$
\end_inset

 רשת זרימה אזי 
\begin_inset Formula $\left|V\right|\cdot\mathds{1}_{s}$
\end_inset

 פונקציית גובה וכן לא קיים מסלול מ־
\begin_inset Formula $s$
\end_inset

 ל־
\begin_inset Formula $t$
\end_inset

 ב־
\begin_inset Formula $G_{f_{s}}$
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
למה
\series default
:
 תהא 
\begin_inset Formula $\left(V,E,c,s,t\right)$
\end_inset

 רשת זרימה אזי לאחר כל איטרציה של 
\begin_inset Formula $\text{GoldbergTarjan}$
\end_inset

 מתקיים
\end_layout

\begin_layout Itemize
\begin_inset Formula $f$
\end_inset

 הינה קדם זרימה.
\end_layout

\begin_layout Itemize
\begin_inset Formula $h$
\end_inset

 פונקציית גובה.
\end_layout

\begin_layout Itemize
לא קיים מסלול מ־
\begin_inset Formula $s$
\end_inset

 ל־
\begin_inset Formula $t$
\end_inset

 ב־
\begin_inset Formula $G_{f}$
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
למה
\series default
:
 תהא 
\begin_inset Formula $\left(V,E,c,s,t\right)$
\end_inset

 רשת זרימה אזי 
\begin_inset Formula $\text{GoldbergTarjan}$
\end_inset

 קוראת לפונקציה 
\begin_inset Formula $\text{Relabel}$
\end_inset

 לכל היותר 
\begin_inset Formula $2\cdot\left|V\right|^{2}$
\end_inset

 פעמים.
\end_layout

\begin_layout Standard

\series bold
למה
\series default
:
 תהא 
\begin_inset Formula $\left(V,E,c,s,t\right)$
\end_inset

 רשת זרימה אזי 
\begin_inset Formula $\text{GoldbergTarjan}$
\end_inset

 מבצעת דחיפה מרווה לכל היותר 
\begin_inset Formula $2\left|E\right|\left|V\right|$
\end_inset

 פעמים.
\end_layout

\begin_layout Standard

\series bold
למה
\series default
:
 תהא 
\begin_inset Formula $\left(V,E,c,s,t\right)$
\end_inset

 רשת זרימה אזי 
\begin_inset Formula $\text{GoldbergTarjan}$
\end_inset

 מבצעת דחיפה לא מרווה לכל היותר 
\begin_inset Formula $2\left(\left|E\right|\left|V\right|+\left|V\right|^{2}\right)\cdot2\left|V\right|$
\end_inset

 פעמים.
\end_layout

\begin_layout Standard

\series bold
משפט
\series default
:
 תהא 
\begin_inset Formula $\left(V,E,c,s,t\right)$
\end_inset

 רשת זרימה אזי 
\begin_inset Formula $\text{GoldbergTarjan}$
\end_inset

 הינה זרימה מקסימלית.
\end_layout

\begin_layout Standard

\series bold
טענה
\series default
:
 תהא 
\begin_inset Formula $\left(V,E,c,s,t\right)$
\end_inset

 רשת זרימה אזי ניתן לממש את 
\begin_inset Formula $\text{GoldbergTarjan}$
\end_inset

 עם 
\begin_inset Formula $\text{List}$
\end_inset

 בסיבוכיות זמן ריצה 
\begin_inset Formula $\O\left(\left|E\right|\cdot\left|V\right|^{2}\right)$
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
הערה
\series default
:
 תהא 
\begin_inset Formula $\left(V,E,c,s,t\right)$
\end_inset

 רשת זרימה אזי ניתן לממש את 
\begin_inset Formula $\text{GoldbergTarjan}$
\end_inset

 עם 
\lang english

\begin_inset Formula $\text{Dynamic Trees}$
\end_inset


\lang hebrew
 בסיבוכיות זמן ריצה
\begin_inset Newline newline
\end_inset


\begin_inset Formula $\O\left(\left|E\right|\left|V\right|\log\left(\left|V\right|\right)\right)$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Standard

\series bold
סימון
\series default
:
 תהיינה 
\begin_inset Formula $x,y\in\bbr^{n}$
\end_inset

 עבורן 
\begin_inset Formula $x_{i}\le y_{i}$
\end_inset

 לכל 
\begin_inset Formula $i\in\left[n\right]$
\end_inset

 אזי 
\begin_inset Formula $x\le y$
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
סימון
\series default
:
 תהיינה 
\begin_inset Formula $x,y\in\bbr^{n}$
\end_inset

 עבורן 
\begin_inset Formula $x_{i}\ge y_{i}$
\end_inset

 לכל 
\begin_inset Formula $i\in\left[n\right]$
\end_inset

 אזי 
\begin_inset Formula $x\ge y$
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
תוכנה לינארית
\series default
:
 יהיו 
\begin_inset Formula $n,m,k,\ell\in\bbn$
\end_inset

 יהי 
\begin_inset Formula $c\in\bbr^{n}$
\end_inset

 תהא 
\begin_inset Formula $P\in M_{m\times n}\left(\bbr\right)$
\end_inset

 יהי 
\begin_inset Formula $p\in\bbr^{m}$
\end_inset

 תהא 
\begin_inset Formula $Q\in M_{k\times n}\left(\bbr\right)$
\end_inset

 יהי 
\begin_inset Formula $q\in\bbr^{k}$
\end_inset

 תהא 
\begin_inset Formula $R\in M_{\ell\times n}\left(\bbr\right)$
\end_inset

 יהי 
\begin_inset Formula $r\in\bbr^{\ell}$
\end_inset

 אזי 
\begin_inset Formula $\left(c,P,p,Q,q,R,r\right)$
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
בעיית תכנות לינארי
\series default
:
 תהא 
\begin_inset Formula $\left(c,P,p,Q,q,R,r\right)$
\end_inset

 תוכנה לינארית אזי מציאת נקודת קיצון של 
\begin_inset Formula $c^{T}x$
\end_inset

 תחת ההנחות
\begin_inset Newline newline
\end_inset


\begin_inset Formula $\left\{ Px\le p,Qx=q,Rx\ge r\right\} $
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
בעיית תכנות לינארי מקסימלית
\series default
:
 תהא 
\begin_inset Formula $\left(c,P,p,Q,q,R,r\right)$
\end_inset

 תוכנה לינארית אזי מציאת נקודת מקסימום של 
\begin_inset Formula $c^{T}x$
\end_inset

 תחת ההנחות 
\begin_inset Formula $\left\{ Px\le p,Qx=q,Rx\ge r\right\} $
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
בעיית תכנות לינארי מינימלית
\series default
:
 תהא 
\begin_inset Formula $\left(c,P,p,Q,q,R,r\right)$
\end_inset

 תוכנה לינארית אזי מציאת נקודת מינימום של 
\begin_inset Formula $c^{T}x$
\end_inset

 תחת ההנחות 
\begin_inset Formula $\left\{ Px\le p,Qx=q,Rx\ge r\right\} $
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
הערה
\series default
:
 מכאן והלאה נשתמש במונח תוכנה לינארית גם עבור בעיית תכנות לינארי.
\end_layout

\begin_layout Standard

\series bold
סימון
\series default
:
 תהא 
\begin_inset Formula $\left(c,P,p,Q,q,R,r\right)$
\end_inset

 בעיית תכנות לינארית מקסימלית אזי
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
setlength
\backslash
abovedisplayskip{1pt}
\end_layout

\begin_layout Plain Layout


\backslash
begin{flalign*}
\end_layout

\begin_layout Plain Layout


\backslash
max
\backslash
quad & c^Tx &
\backslash

\backslash

\end_layout

\begin_layout Plain Layout


\backslash
text{s.t.}
\backslash
quad &  Px
\backslash
le p &
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

& Qx=q &
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

& Rx
\backslash
ge r
\end_layout

\begin_layout Plain Layout


\backslash
end{flalign*}
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\series bold
סימון
\series default
:
 תהא 
\begin_inset Formula $\left(c,P,p,Q,q,R,r\right)$
\end_inset

 בעיית תכנות לינארית מינימלית אזי
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
setlength
\backslash
abovedisplayskip{1pt}
\end_layout

\begin_layout Plain Layout


\backslash
begin{flalign*}
\end_layout

\begin_layout Plain Layout


\backslash
min
\backslash
quad & c^Tx &
\backslash

\backslash

\end_layout

\begin_layout Plain Layout


\backslash
text{s.t.}
\backslash
quad &  Px
\backslash
le p &
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

& Qx=q &
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

& Rx
\backslash
ge r
\end_layout

\begin_layout Plain Layout


\backslash
end{flalign*}
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\series bold
פתרון פיזיבילי של תוכנה לינארית
\series default
:
 תהא 
\begin_inset Formula $\left(c,P,p,Q,q,R,r\right)$
\end_inset

 תוכנה לינארית אזי 
\begin_inset Formula $x\in\bbr^{n}$
\end_inset

 עבורו 
\begin_inset Formula $Px\le p$
\end_inset

 וכן 
\begin_inset Formula $Qx=q$
\end_inset

 וכן 
\begin_inset Formula $Rx\ge r$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset FormulaMacro
\newcommand{\lp}{\text{LP}}
{\text{LP}}
\end_inset


\end_layout

\begin_layout Standard

\series bold
פתרון אופטימלי של תוכנה לינארית
\series default
:
 תהא 
\begin_inset Formula $\lp$
\end_inset

 תוכנה לינארית אזי 
\begin_inset Formula $x\in\bbr^{n}$
\end_inset

 המהווה פתרון של בעיית התכנות הלינארי.
\end_layout

\begin_layout Standard

\series bold
תוכנה לינארית פיזבילית
\series default
:
 תוכנה לינארית 
\begin_inset Formula $\lp$
\end_inset

 עבורה קיים פתרון אופטימלי.
\end_layout

\begin_layout Standard

\series bold
תוכנה לינארית מקסימלית חסומה
\series default
:
 תוכנה לינארית 
\begin_inset Formula $\left(c,P,p,Q,q,R,r\right)$
\end_inset

 עבורה קיים 
\begin_inset Formula $B\in\bbr$
\end_inset

 המקיים כי לכל פתרון פיזבילי 
\begin_inset Formula $x\in\bbr^{n}$
\end_inset

 מתקיים 
\begin_inset Formula $c^{T}x\le B$
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
משפט
\series default
:
 תהא 
\begin_inset Formula $\lp$
\end_inset

 תוכנה לינארית מקסימלית אזי (
\begin_inset Formula $\lp$
\end_inset

 בעלת פתרון אופטימלי)
\begin_inset Formula $\iff$
\end_inset

(
\begin_inset Formula $\lp$
\end_inset

 חסומה ופיזבילית).
\end_layout

\begin_layout Standard

\series bold
תוכנה לינארית בצורה סטנדרטית
\series default
:
 יהיו 
\begin_inset Formula $n,m\in\bbn$
\end_inset

 יהי 
\begin_inset Formula $c\in\bbr^{n}$
\end_inset

 תהא 
\begin_inset Formula $A\in M_{m\times n}\left(\bbr\right)$
\end_inset

 ויהי 
\begin_inset Formula $b\in\bbr^{m}$
\end_inset

 אזי התוכנה הלינארית המקסימלית 
\begin_inset Formula $\left(c,A,b,0,0,I_{n},0\right)$
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
הערה
\series default
:
 יהיו 
\begin_inset Formula $n,m\in\bbn$
\end_inset

 יהי 
\begin_inset Formula $c\in\bbr^{n}$
\end_inset

 תהא 
\begin_inset Formula $A\in M_{m\times n}\left(\bbr\right)$
\end_inset

 ויהי 
\begin_inset Formula $b\in\bbr^{m}$
\end_inset

 אזי 
\begin_inset Formula $\left(c,A,b,0,0,I_{n},0\right)$
\end_inset

 הינה
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
setlength
\backslash
abovedisplayskip{1pt}
\end_layout

\begin_layout Plain Layout


\backslash
begin{flalign*}
\end_layout

\begin_layout Plain Layout


\backslash
max
\backslash
quad & c^Tx &
\backslash

\backslash

\end_layout

\begin_layout Plain Layout


\backslash
text{s.t.}
\backslash
quad &  Ax
\backslash
le b &
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

& x
\backslash
ge 0
\end_layout

\begin_layout Plain Layout


\backslash
end{flalign*}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset FormulaMacro
\newcommand{\slp}{\text{SLP}}
{\text{SLP}}
\end_inset


\end_layout

\begin_layout Standard

\series bold
טענה
\series default
:
 תהא 
\begin_inset Formula $\lp$
\end_inset

 תוכנה לינארית אזי קיימת תוכנה לינארית בצורה סטנדרטית 
\begin_inset Formula $\slp$
\end_inset

 אשר שקולה ל־
\begin_inset Formula $\lp$
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
מצולע/פאון/פוליהדרון הפיזביליות
\series default
:
 תהא 
\begin_inset Formula $\left(c,P,p,Q,q,R,r\right)$
\end_inset

 תוכנה לינארית אזי 
\begin_inset Formula $\left\{ Px\le p,Qx=q,Rx\ge r\right\} $
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
קבוצה קמורה
\series default
:
 קבוצה 
\begin_inset Formula $K\subseteq\bbr^{n}$
\end_inset

 עבורה לכל 
\begin_inset Formula $x,y\in K$
\end_inset

 ולכל 
\begin_inset Formula $\a\in\left[0,1\right]$
\end_inset

 מתקיים 
\begin_inset Formula $\a x+\left(1-\a\right)y\in K$
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
נקודה קיצונית בקבוצה
\series default
:
 תהא 
\begin_inset Formula $K\subseteq\bbr^{n}$
\end_inset

 אזי 
\begin_inset Formula $x\in K$
\end_inset

 עבורה לכל 
\begin_inset Formula $y,z\in K$
\end_inset

 ולכל 
\begin_inset Formula $\a\in\left(0,1\right)$
\end_inset

 מתקיים 
\begin_inset Formula $x\ne\a y+\left(1-\a\right)z$
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
קודקוד של פאון
\series default
:
 יהי 
\begin_inset Formula $P\subseteq\bbr^{n}$
\end_inset

 פאון אזי נקודה קיצונית 
\begin_inset Formula $x\in P$
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
תוכנה לינארית בצורה משוואתית
\series default
:
 יהיו 
\begin_inset Formula $n,m\in\bbn$
\end_inset

 יהי 
\begin_inset Formula $c\in\bbr^{n}$
\end_inset

 תהא 
\begin_inset Formula $A\in M_{m\times n}\left(\bbr\right)$
\end_inset

 ויהי 
\begin_inset Formula $b\in\bbr^{m}$
\end_inset

 אזי התוכנה הלינארית 
\begin_inset Formula $\left(c,0,0,A,b,I_{n},0\right)$
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
הערה
\series default
:
 יהיו 
\begin_inset Formula $n,m\in\bbn$
\end_inset

 יהי 
\begin_inset Formula $c\in\bbr^{n}$
\end_inset

 תהא 
\begin_inset Formula $A\in M_{m\times n}\left(\bbr\right)$
\end_inset

 ויהי 
\begin_inset Formula $b\in\bbr^{m}$
\end_inset

 אזי 
\begin_inset Formula $\left(c,0,0,A,b,I_{n},0\right)$
\end_inset

 הינה
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
setlength
\backslash
abovedisplayskip{1pt}
\end_layout

\begin_layout Plain Layout


\backslash
begin{flalign*}
\end_layout

\begin_layout Plain Layout


\backslash
max
\backslash
quad & c^Tx &
\backslash

\backslash

\end_layout

\begin_layout Plain Layout


\backslash
text{s.t.}
\backslash
quad &  Ax=b &
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

& x
\backslash
ge 0
\end_layout

\begin_layout Plain Layout


\backslash
end{flalign*}
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\series bold
צורת סלאק/צורה רפויה של תוכנה לינארית סטנדרטית
\series default
:
 תהא 
\begin_inset Formula $\left(c,A,b,0,0,I_{n},0\right)$
\end_inset

 תוכנה לינארית בצורה סטנדרטית אזי
\begin_inset Newline newline
\end_inset


\begin_inset Formula $\left(\left(\begin{smallmatrix}c\\
0
\end{smallmatrix}\right),0,0,\left(A|I_{m}\right),b,I_{n+m},0\right)$
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
הערה
\series default
:
 תהא 
\begin_inset Formula $\left(c,A,b,0,0,I_{n},0\right)$
\end_inset

 תוכנה לינארית בצורה סטנדרטית אזי 
\begin_inset Formula $\left(\left(\begin{smallmatrix}c\\
0
\end{smallmatrix}\right),0,0,\left(A|I_{m}\right),b,I_{n+m},0\right)$
\end_inset

 הינה
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
setlength
\backslash
abovedisplayskip{1pt}
\end_layout

\begin_layout Plain Layout


\backslash
begin{flalign*}
\end_layout

\begin_layout Plain Layout


\backslash
max
\backslash
quad & c^Tx &
\backslash

\backslash

\end_layout

\begin_layout Plain Layout


\backslash
text{s.t.}
\backslash
quad &  Ax + s=b &
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

& 
\backslash
left(
\backslash
begin{smallmatrix}x
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

s
\end_layout

\begin_layout Plain Layout


\backslash
end{smallmatrix}
\backslash
right)
\backslash
ge 0
\end_layout

\begin_layout Plain Layout


\backslash
end{flalign*}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset FormulaMacro
\newcommand{\sf}{\text{SF}}
{\text{SF}}
\end_inset


\end_layout

\begin_layout Standard

\series bold
משתנים בסיסיים בצורה רפויה
\series default
:
 תהא 
\begin_inset Formula $\sf$
\end_inset

 צורה רפויה אזי 
\begin_inset Formula $\left\{ x_{n+1},\ldots,x_{n+m}\right\} $
\end_inset

 בבעיית התכנות הלינארי.
\end_layout

\begin_layout Standard

\series bold
משתנים לא בסיסיים בצורה רפויה
\series default
:
 תהא 
\begin_inset Formula $\sf$
\end_inset

 צורה רפויה אזי 
\begin_inset Formula $\left\{ x_{1},\ldots,x_{n}\right\} $
\end_inset

 בבעיית התכנות הלינארי.
\end_layout

\begin_layout Standard

\series bold
טענה צורה רפויה
\series default
:
 תהא 
\begin_inset Formula $\slp$
\end_inset

 תוכנה לינארית בצורה סטנדרטית ויהי 
\begin_inset Formula $x\in\bbr^{n}$
\end_inset

 אזי (קיים 
\begin_inset Formula $y\in\bbr^{m}$
\end_inset

 עבורו 
\begin_inset Formula $\left(\begin{smallmatrix}x\\
y
\end{smallmatrix}\right)$
\end_inset

 פתרון פיזבילי של הצורה הרפויה)
\begin_inset Formula $\iff$
\end_inset

(
\begin_inset Formula $x$
\end_inset

 פתרון פיזבילי של 
\begin_inset Formula $\slp$
\end_inset

).
\end_layout

\begin_layout Standard

\series bold
אלגוריתם סימפלקס
\series default
:
 ...
\end_layout

\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Standard

\series bold
טענה
\series default
:
 בעיית הזרימה המקסימלית הינה בעיית תכנות לינארי מקסימלית.
\end_layout

\begin_layout Standard

\series bold
מסקנה
\series default
:
 תהא 
\begin_inset Formula $\left(V,E,c,s,t\right)$
\end_inset

 רשת זרימה אזי בעיית הזרימה המקסימלית הינה
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
setlength
\backslash
abovedisplayskip{1pt}
\end_layout

\begin_layout Plain Layout


\backslash
begin{flalign*}
\end_layout

\begin_layout Plain Layout


\backslash
max
\backslash
quad & 
\backslash
sum_{
\backslash
substack{u
\backslash
in V
\backslash

\backslash

\end_layout

\begin_layout Plain Layout


\backslash
left(u,v
\backslash
right)
\backslash
in E
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

}f
\backslash
left(
\backslash
left(u,t
\backslash
right)
\backslash
right)-
\backslash
sum_{
\backslash
substack{u
\backslash
in V
\backslash

\backslash

\end_layout

\begin_layout Plain Layout


\backslash
left(v,u
\backslash
right)
\backslash
in E
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

}f
\backslash
left(
\backslash
left(v,t
\backslash
right)
\backslash
right) &
\backslash

\backslash

\end_layout

\begin_layout Plain Layout


\backslash
text{s.t.}
\backslash
quad &  
\backslash
sum_{
\backslash
substack{u
\backslash
in V
\backslash

\backslash

\end_layout

\begin_layout Plain Layout


\backslash
left(u,v
\backslash
right)
\backslash
in E
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

}f
\backslash
left(
\backslash
left(u,v
\backslash
right)
\backslash
right)-
\backslash
sum_{
\backslash
substack{u
\backslash
in V
\backslash

\backslash

\end_layout

\begin_layout Plain Layout


\backslash
left(v,u
\backslash
right)
\backslash
in E
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

}f
\backslash
left(
\backslash
left(v,u
\backslash
right)
\backslash
right)=0 
\backslash
qquad,
 
\backslash
forall v
\backslash
in V
\backslash
backslash
\backslash
left
\backslash
{ s,t
\backslash
right
\backslash
} &
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

& f
\backslash
left(
\backslash
left(u,v
\backslash
right)
\backslash
right)
\backslash
le c
\backslash
left(
\backslash
left(u,v
\backslash
right)
\backslash
right) 
\backslash
qquad,
 
\backslash
forall
\backslash
left(u,v
\backslash
right)
\backslash
in E &
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

& f
\backslash
left(
\backslash
left(u,v
\backslash
right)
\backslash
right)
\backslash
ge0 
\backslash
qquad,
 
\backslash
forall
\backslash
left(u,v
\backslash
right)
\backslash
in E
\end_layout

\begin_layout Plain Layout


\backslash
end{flalign*}
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\series bold
רשת זרימה בעלת עלות
\series default
:
 תהא 
\begin_inset Formula $\left(V,E,c,s,t\right)$
\end_inset

 רשת זרימה ותהא 
\begin_inset Formula $a:E\to\bbr$
\end_inset

 אזי 
\begin_inset Formula $\left(V,E,c,s,t,a\right)$
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
עלות זרימה
\series default
:
 תהא 
\begin_inset Formula $\left(V,E,c,s,t\right)$
\end_inset

 רשת זרימה ותהא 
\begin_inset Formula $f$
\end_inset

 זרימה אזי 
\begin_inset Formula $a\cdot f$
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
בעיית העלות המינימלית
\series default
:
 תהא 
\begin_inset Formula $\left(V,E,c,s,t,a\right)$
\end_inset

 רשת זרימה בעלת עלות ויהי 
\begin_inset Formula $d\in\bbn_{+}$
\end_inset

 אזי פונקציית זרימה 
\begin_inset Formula $f$
\end_inset

 עבורה 
\begin_inset Formula $\chi_{f}\left(t\right)=d$
\end_inset

 וכן 
\begin_inset Formula $\sum_{e\in E}a\left(e\right)\cdot f\left(e\right)$
\end_inset

 מינימלית.
\end_layout

\begin_layout Standard

\series bold
טענה
\series default
:
 בעיית העלות המינימלית הינה בעיית תכנות לינארי מינימלית.
\end_layout

\begin_layout Standard

\series bold
מסקנה
\series default
:
 תהא 
\begin_inset Formula $\left(V,E,c,s,t,a\right)$
\end_inset

 רשת זרימה בעלת עלות ויהי 
\begin_inset Formula $d\in\bbn_{+}$
\end_inset

 אזי בעיית העלות המינימלית הינה
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
setlength
\backslash
abovedisplayskip{1pt}
\end_layout

\begin_layout Plain Layout


\backslash
begin{flalign*}
\end_layout

\begin_layout Plain Layout


\backslash
min
\backslash
quad & 
\backslash
sum_{
\backslash
left(u,v
\backslash
right)
\backslash
in E}a
\backslash
left(
\backslash
left(a,v
\backslash
right)
\backslash
right)
\backslash
cdot f
\backslash
left(
\backslash
left(a,v
\backslash
right)
\backslash
right) &
\backslash

\backslash

\end_layout

\begin_layout Plain Layout


\backslash
text{s.t.}
\backslash
quad & 
\backslash
sum_{
\backslash
substack{u
\backslash
in V
\backslash

\backslash

\end_layout

\begin_layout Plain Layout


\backslash
left(u,v
\backslash
right)
\backslash
in E
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

}f
\backslash
left(
\backslash
left(u,t
\backslash
right)
\backslash
right)-
\backslash
sum_{
\backslash
substack{u
\backslash
in V
\backslash

\backslash

\end_layout

\begin_layout Plain Layout


\backslash
left(v,u
\backslash
right)
\backslash
in E
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

}f
\backslash
left(
\backslash
left(v,t
\backslash
right)
\backslash
right)=d &
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

&  
\backslash
sum_{
\backslash
substack{u
\backslash
in V
\backslash

\backslash

\end_layout

\begin_layout Plain Layout


\backslash
left(u,v
\backslash
right)
\backslash
in E
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

}f
\backslash
left(
\backslash
left(u,v
\backslash
right)
\backslash
right)-
\backslash
sum_{
\backslash
substack{u
\backslash
in V
\backslash

\backslash

\end_layout

\begin_layout Plain Layout


\backslash
left(v,u
\backslash
right)
\backslash
in E
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

}f
\backslash
left(
\backslash
left(v,u
\backslash
right)
\backslash
right)=0 
\backslash
qquad,
 
\backslash
forall v
\backslash
in V
\backslash
backslash
\backslash
left
\backslash
{ s,t
\backslash
right
\backslash
} &
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

& f
\backslash
left(
\backslash
left(u,v
\backslash
right)
\backslash
right)
\backslash
le c
\backslash
left(
\backslash
left(u,v
\backslash
right)
\backslash
right) 
\backslash
qquad,
 
\backslash
forall
\backslash
left(u,v
\backslash
right)
\backslash
in E &
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

& f
\backslash
left(
\backslash
left(u,v
\backslash
right)
\backslash
right)
\backslash
ge0 
\backslash
qquad,
 
\backslash
forall
\backslash
left(u,v
\backslash
right)
\backslash
in E
\end_layout

\begin_layout Plain Layout


\backslash
end{flalign*}
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\series bold
מסקנה
\series default
:
 תהא 
\begin_inset Formula $\left(V,E,c,s,t,a\right)$
\end_inset

 רשת זרימה בעלת עלות יהי 
\begin_inset Formula $d\in\bbn_{+}$
\end_inset

 ותהא 
\begin_inset Formula $f$
\end_inset

 זרימה מקסימלית של 
\begin_inset Formula $\left(V,E,c,s,t\right)$
\end_inset

 אזי (בעיית העלות המינימלית פיזבילית)
\begin_inset Formula $\iff$
\end_inset

(
\begin_inset Formula $\left|f\right|\ge d$
\end_inset

).
\end_layout

\begin_layout Standard

\series bold
טענה
\series default
:
 תהא 
\begin_inset Formula $\left(V,E,c,s,t,a\right)$
\end_inset

 רשת זרימה בעלת עלות ויהי 
\begin_inset Formula $d\in\bbn_{+}$
\end_inset

 עבורו בעיית העלות המינימלית פיזבילית אזי בעיית העלות המינימלית בעיית פתרון אופטימלי.
\end_layout

\begin_layout Standard

\series bold
בעיית העלות המינימלית עם היצע וביקוש
\series default
:
 תהא 
\begin_inset Formula $\left(V,E,c,s,t,a\right)$
\end_inset

 רשת זרימה בעלת עלות ותהא 
\begin_inset Formula $d:V\to\bbz$
\end_inset

 אזי פונקציה 
\begin_inset Formula $f:E\to\bbr_{+}$
\end_inset

 עבורה 
\begin_inset Formula $f\le c$
\end_inset

 וכן 
\begin_inset Formula $\chi_{f}=d$
\end_inset

 וכן 
\begin_inset Formula $\sum_{e\in E}a\left(e\right)\cdot f\left(e\right)$
\end_inset

 מינימלית.
\end_layout

\begin_layout Standard

\series bold
טענה
\series default
:
 בעיית העלות המינימלית עם היצע וביקוש הינה בעיית תכנות לינארי מינימלית.
\end_layout

\begin_layout Standard

\series bold
מסקנה
\series default
:
 תהא 
\begin_inset Formula $\left(V,E,c,s,t,a\right)$
\end_inset

 רשת זרימה בעלת עלות ותהא 
\begin_inset Formula $d:V\to\bbz$
\end_inset

 אזי בעיית העלות המינימלית עם היצע וביקוש הינה
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
setlength
\backslash
abovedisplayskip{1pt}
\end_layout

\begin_layout Plain Layout


\backslash
begin{flalign*}
\end_layout

\begin_layout Plain Layout


\backslash
min
\backslash
quad & 
\backslash
sum_{
\backslash
left(u,v
\backslash
right)
\backslash
in E}a
\backslash
left(
\backslash
left(a,v
\backslash
right)
\backslash
right)
\backslash
cdot f
\backslash
left(
\backslash
left(a,v
\backslash
right)
\backslash
right) &
\backslash

\backslash

\end_layout

\begin_layout Plain Layout


\backslash
text{s.t.}
\backslash
quad & 
\backslash
sum_{
\backslash
substack{u
\backslash
in V
\backslash

\backslash

\end_layout

\begin_layout Plain Layout


\backslash
left(u,v
\backslash
right)
\backslash
in E
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

}f
\backslash
left(
\backslash
left(u,v
\backslash
right)
\backslash
right)-
\backslash
sum_{
\backslash
substack{u
\backslash
in V
\backslash

\backslash

\end_layout

\begin_layout Plain Layout


\backslash
left(v,u
\backslash
right)
\backslash
in E
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

}f
\backslash
left(
\backslash
left(v,u
\backslash
right)
\backslash
right)= d
\backslash
left(v
\backslash
right) 
\backslash
qquad,
 
\backslash
forall v
\backslash
in V &
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

& f
\backslash
left(
\backslash
left(u,v
\backslash
right)
\backslash
right)
\backslash
le c
\backslash
left(
\backslash
left(u,v
\backslash
right)
\backslash
right) 
\backslash
qquad,
 
\backslash
forall
\backslash
left(u,v
\backslash
right)
\backslash
in E &
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

& f
\backslash
left(
\backslash
left(u,v
\backslash
right)
\backslash
right)
\backslash
ge0 
\backslash
qquad,
 
\backslash
forall
\backslash
left(u,v
\backslash
right)
\backslash
in E
\end_layout

\begin_layout Plain Layout


\backslash
end{flalign*}
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\series bold
טענה
\series default
:
 תהא 
\begin_inset Formula $\left(V,E,c,s,t,a\right)$
\end_inset

 רשת זרימה בעלת עלות ותהא 
\begin_inset Formula $d:V\to\bbz$
\end_inset

 עבורה בעיית העלות המינימלית עם היצע וביקוש פיזבילית אזי 
\begin_inset Formula $\sum_{v\in V}d\left(v\right)=0$
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
בעיית הזרימה הרב־סחורתית המקסימלית
\series default
:
 יהי 
\begin_inset Formula $G$
\end_inset

 גרף מכוון וממושקל 
\begin_inset Formula $c\ge0$
\end_inset

 יהי 
\begin_inset Formula $k\in\bbn_{+}$
\end_inset

 יהיו 
\begin_inset Formula $s_{1}\ldots s_{k},t_{1}\ldots t_{k}\in V$
\end_inset

 ותהא 
\begin_inset Formula $d:\left[k\right]\to\bbn_{+}$
\end_inset

 אזי
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
setlength
\backslash
abovedisplayskip{1pt}
\end_layout

\begin_layout Plain Layout


\backslash
begin{flalign*}
\end_layout

\begin_layout Plain Layout


\backslash
max
\backslash
quad & 
\backslash
alpha &
\backslash

\backslash

\end_layout

\begin_layout Plain Layout


\backslash
text{s.t.}
\backslash
quad & 
\backslash
sum_{u
\backslash
in V}f
\backslash
left(
\backslash
left(u,t_{i}
\backslash
right),i
\backslash
right)-
\backslash
sum_{u
\backslash
in V}f
\backslash
left(
\backslash
left(t_{i},u
\backslash
right),i
\backslash
right)=
\backslash
alpha
\backslash
cdot d
\backslash
left(i
\backslash
right)
\backslash
qquad,
\backslash
forall i
\backslash
in
\backslash
left[k
\backslash
right] &
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

& 
\backslash
sum_{
\backslash
substack{u
\backslash
in V
\backslash

\backslash

\end_layout

\begin_layout Plain Layout


\backslash
left(u,v
\backslash
right)
\backslash
in E
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

}f
\backslash
left(
\backslash
left(u,v
\backslash
right),i
\backslash
right)-
\backslash
sum_{
\backslash
substack{u
\backslash
in V
\backslash

\backslash

\end_layout

\begin_layout Plain Layout


\backslash
left(v,u
\backslash
right)
\backslash
in E
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

}f
\backslash
left(
\backslash
left(v,u
\backslash
right),i
\backslash
right)=0
\backslash
qquad,
\backslash
forall i
\backslash
in
\backslash
left[k
\backslash
right].
\backslash
forall v
\backslash
in V
\backslash
backslash
\backslash
left
\backslash
{ s_{i},t_{i}
\backslash
right
\backslash
}  &
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

& 
\backslash
sum_{i=1}^{k}f
\backslash
left(
\backslash
left(u,v
\backslash
right),i
\backslash
right)
\backslash
le c
\backslash
left(
\backslash
left(u,v
\backslash
right)
\backslash
right)
\backslash
qquad,
\backslash
forall
\backslash
left(u,v
\backslash
right)
\backslash
in E &
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

& f
\backslash
left(
\backslash
left(u,v
\backslash
right),i
\backslash
right)
\backslash
ge0
\backslash
qquad,
\backslash
forall i
\backslash
in
\backslash
left[k
\backslash
right].
\backslash
forall
\backslash
left(u,v
\backslash
right)
\backslash
in E &
\backslash

\backslash

\end_layout

\begin_layout Plain Layout


\backslash
end{flalign*}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Standard

\series bold
פונקציית תת־משקל
\series default
:
 יהי 
\begin_inset Formula $G$
\end_inset

 גרף מכוון ממושקל 
\begin_inset Formula $\ell$
\end_inset

 חסר מעגלים שליליים ויהי 
\begin_inset Formula $s\in V$
\end_inset

 עבורו 
\begin_inset Formula $\d\left(s,v\right)<\infty$
\end_inset

 לכל 
\begin_inset Formula $v\in V$
\end_inset

 אזי 
\begin_inset Formula $y:V\to\bbr$
\end_inset

 עבורה 
\begin_inset Formula $y\left(s\right)=0$
\end_inset

 וכן 
\begin_inset Formula $y\left(e_{2}\right)\le y\left(e_{1}\right)+\ell\left(e\right)$
\end_inset

 לכל 
\begin_inset Formula $e\in E$
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
למה
\series default
:
 יהי 
\begin_inset Formula $G$
\end_inset

 גרף מכוון ממושקל 
\begin_inset Formula $\ell$
\end_inset

 חסר מעגלים שליליים יהי 
\begin_inset Formula $s\in V$
\end_inset

 עבורו 
\begin_inset Formula $\d\left(s,v\right)<\infty$
\end_inset

 לכל 
\begin_inset Formula $v\in V$
\end_inset

 ותהא 
\begin_inset Formula $y:V\to\bbr$
\end_inset

 תת־משקל אזי 
\begin_inset Formula $u\left(v\right)\le\d_{\ell}\left(v\right)$
\end_inset

 לכל 
\begin_inset Formula $v\in V$
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
קשת הדוקה
\series default
:
 יהי 
\begin_inset Formula $G$
\end_inset

 גרף מכוון ממושקל 
\begin_inset Formula $\ell$
\end_inset

 חסר מעגלים שליליים יהי 
\begin_inset Formula $s\in V$
\end_inset

 עבורו 
\begin_inset Formula $\d\left(s,v\right)<\infty$
\end_inset

 לכל 
\begin_inset Formula $v\in V$
\end_inset

 ותהא 
\begin_inset Formula $y:V\to\bbr$
\end_inset

 תת־משקל אזי קשת 
\begin_inset Formula $e\in E$
\end_inset

 עבורה 
\begin_inset Formula $y\left(e_{2}\right)=y\left(e_{1}\right)+\ell\left(e\right)$
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
למה
\series default
:
 יהי 
\begin_inset Formula $G$
\end_inset

 גרף מכוון ממושקל 
\begin_inset Formula $\ell$
\end_inset

 חסר מעגלים שליליים יהי 
\begin_inset Formula $s\in V$
\end_inset

 עבורו 
\begin_inset Formula $\d\left(s,v\right)<\infty$
\end_inset

 לכל 
\begin_inset Formula $v\in V$
\end_inset

 תהא 
\begin_inset Formula $y:V\to\bbr$
\end_inset

 תת־משקל ויהי 
\begin_inset Formula $u\in V$
\end_inset

 עבורו קיים מסלול 
\begin_inset Formula $\sigma$
\end_inset

 מ־
\begin_inset Formula $s$
\end_inset

 ל־
\begin_inset Formula $u$
\end_inset

 המכיל רק קשתות הדוקות אזי 
\begin_inset Formula $y\left(u\right)=\d_{\ell}\left(s,u\right)$
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
מסקנה
\series default
:
 יהי 
\begin_inset Formula $G$
\end_inset

 גרף מכוון ממושקל 
\begin_inset Formula $\ell$
\end_inset

 חסר מעגלים שליליים יהי 
\begin_inset Formula $s\in V$
\end_inset

 עבורו 
\begin_inset Formula $\d\left(s,v\right)<\infty$
\end_inset

 לכל 
\begin_inset Formula $v\in V$
\end_inset

 ותהא 
\begin_inset Formula $y:V\to\bbr$
\end_inset

 תת־משקל אזי 
\begin_inset Formula $y$
\end_inset

 הינה פונקציית פוטנציאל פיזבילית.
\end_layout

\begin_layout Standard

\series bold
טענה
\series default
:
 בעיית המסלולים הקצרים מנקודת מוצא הינה בעיית תכנות לינארי מינימלית.
\end_layout

\begin_layout Standard

\series bold
מסקנה
\series default
:
 יהי 
\begin_inset Formula $G$
\end_inset

 גרף מכוון ממושקל 
\begin_inset Formula $\ell$
\end_inset

 ויהי 
\begin_inset Formula $s\in V$
\end_inset

 אזי בעיית המסלולים הקצרים מנקודת מוצא הינה
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
setlength
\backslash
abovedisplayskip{1pt}
\end_layout

\begin_layout Plain Layout


\backslash
begin{flalign*}
\end_layout

\begin_layout Plain Layout


\backslash
max
\backslash
quad & 
\backslash
sum_{u
\backslash
in V} y(u) &
\backslash

\backslash

\end_layout

\begin_layout Plain Layout


\backslash
text{s.t.}
\backslash
quad & y(v) - y(u) 
\backslash
le 
\backslash
ell(u,
 v) 
\backslash
qquad,
\backslash
forall (u,v)
\backslash
in E &
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

& y(s) = 0
\end_layout

\begin_layout Plain Layout


\backslash
end{flalign*}
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\series bold
משפט
\series default
:
 יהי 
\begin_inset Formula $G$
\end_inset

 גרף מכוון ממושקל 
\begin_inset Formula $\ell$
\end_inset

 חסר מעגלים שליליים ויהי 
\begin_inset Formula $s\in V$
\end_inset

 עבורו 
\begin_inset Formula $\d\left(s,v\right)<\infty$
\end_inset

 לכל 
\begin_inset Formula $v\in V$
\end_inset

 אזי
\end_layout

\begin_layout Itemize
בעיית המסלולים הקצרים מנקודת מוצא בעלת פתאון אופטימלי.
\end_layout

\begin_layout Itemize
יהי 
\begin_inset Formula $y$
\end_inset

 פתרון אופטימלי של בעיית המסלולים הקצרים מנקודת מוצא אזי 
\begin_inset Formula $y\left(u\right)=\d_{\ell}\left(s,u\right)$
\end_inset

 לכל 
\begin_inset Formula $u\in V$
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
טענה
\series default
:
 יהי 
\begin_inset Formula $G$
\end_inset

 גרף מכוון ממושקל 
\begin_inset Formula $\ell$
\end_inset

 בעל מעגל שלילי ויהי 
\begin_inset Formula $s\in V$
\end_inset

 אזי בעיית המסלולים הקצרים מנקודת מוצא לא פיזבילית.
\end_layout

\begin_layout Standard

\series bold
טענה
\series default
:
 יהי 
\begin_inset Formula $G$
\end_inset

 גרף מכוון ממושקל 
\begin_inset Formula $\ell$
\end_inset

 ויהי 
\begin_inset Formula $s\in V$
\end_inset

 עבורו קיים 
\begin_inset Formula $u\in V$
\end_inset

 המקיים 
\begin_inset Formula $\d\left(s,u\right)=\infty$
\end_inset

 אזי בעיית המסלולים הקצרים מנקודת מוצא לא חסומה.
\end_layout

\end_body
\end_document
